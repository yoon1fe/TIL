# CH2. System Structure

![img](https://blog.kakaocdn.net/dn/cv6ZuS/btqFN3DgOwe/Kz2gUZ0LQEw2iOfcQA7qk1/img.png)컴퓨터 시스템의 대략적인 구조



CPU는 메모리에서 인스트럭션을 읽어와서 실행하는 역할을 수행한다.

CPU 안에는 메모리보다 빠른 작은 저장 공간이 있다 ▷ 레지스터

 

**Device Controller**가 각 IO 디바이스마다 붙어 있어서 그 장치들을 전담하는 작은 CPU 역할을 한다. ex) '디스크에서 데이터를 읽어 와라' 요청이 들어오면 CPU가 직접 가서 읽어 오는 것이 아니라 `disk controller`에 요청을 해서 `disk controller`가 요청을 수행한다.

제어 정보를 위해 `control register, status register`를 가지고 있다.

CPU가 `Main Memory`라는 작업 공간이 있듯이, 각각의 `Device Controller`들에게도 `local buffer(일종의 data register)`라는 작업 공간이 있다. I/O는 실제 `device`와 `local buffer` 사이에서 일어난다. `Device controller`는 I/O가 끝났을 때 `interrupt`로 CPU에 그 사실을 알린다.

- Device Driver(장치 구동기) - OS코드 중 각 장치별 처리 루틴 -> SW
- Device Controller(장치 제어기) - 각 장치를 통제하는 일종의 작은 CPU -> HW

 

#### Interrupt line

CPU는 항상 메모리에 있는 인스트럭션만 실행한다. 인스트럭션 하나가 실행되고 나면, 다음에 실행할 인스트럭션의 주소값이 증가하고 다음 사이클에서는 다음 인스트럭션을 수행한다. 이 때, 인스트럭션들 수행 사이에 interrupt가 있는지 확인해주는 역할을 한다.

 

#### Timer

`특정 프로그램이 CPU를 독점하는 것을 방지하는 장치`이다. time sharing을 구현하기 위해 많이 이용된다. 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킨다. 타이머는 매 클럭마다 1씩 감소하고 타이머 값이 0이 되면 타이머 인터럽트를 발생시킨다.

*모든 사용자 프로그램은 직접 IO 장치에 접근할 수 없다. 접근하는 모든 인스트럭션은 OS를 통해서만 접근할 수 있도록 막아놨다.

요청했던 프로그램은 언제 다시 CPU를 가질 수 있을까?

▷ 요청한 작업이 끝나면 IO Controller가 CPU에 인터럽트를 건다. CPU가 다른 작업을 수행하고 있더라도 인터럽트가 들어오면 CPU 제어권이 운영체제에게 간다. 운영체제가 인터럽트가 왜 들어왔는지를 확인하고 입력된 값`(요청한 값)`을 아까 IO를 요청했던 프로그램의 메모리 공간에다가 카피를 해주고, 원래 CPU를 갖고 있던 프로그램에게 다시 넘겨준다. IO를 요청했던 프로그램은 CPU Scheduling 정책에 따라 자기 차례가 오면 CPU를 차지하게 된다.

 

#### Mode bit

사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치가 필요하다. ▷Mode bit를 통해 하드웨어적으로 두 가지 모드의 operation을 지원한다.

```
1(사용자 모드): 사용자 프로그램 수행
0(모니터 모드): OS 코드 수행
```

- 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 `특권 명령`으로 규정
- Interrupt나 Exception 발생시 하드웨어가 mode bit를 0으로 세팅
- 사용자 프로그램에게 CPU를 넘기기 전에 mode bit를 1로 세팅

```
모니터 모드 = 커널 모드, 시스템 모드. 운영체제가 CPU에서 실행 중인 상태
```

####  

#### DMA(Direct Memory Access) Controller

직접 메모리에 접근할 수 있는 컨트롤러. 원래 메모리에 접근할 수 있는 장치는 CPU 뿐이었는데, `DMA`를 두어 메모리에 접근 가능하게 한다. 이 때 동시에 같은 공간에 접근하는 것을 방지하기 위해 `memory controller`가 접근 순서 등을 조율한다.

작업이 들어 왔을 때 CPU에게 인터럽트를 걸어서 메모리에 카피하게 하면 오버헤드가 너무 크다. ▷ CPU는 계속 자기 일을 하고, IO 장치에서 작업이 끝나면 `DMA`가 `local buffer`에 있는 데이터를 직접 메모리에 복사해준다. 이 작업이 모두 끝나면 CPU에 인터럽트를 한 번만 걸어줌으로써 인터럽트 횟수를 줄인다.

 

#### Program Counter

CPU가 다음에 실행해야 할 인스트럭션의 주소값을 가지고 있는 레지스터.

 

#### I/O의 수행

모든 입출력 명령은 `특권 명령`이다.

그럼 사용자 프로그램은 어떻게 `I/O`를 할까?

- 시스템 콜(system call) - 사용자 프로그램이 운영체제(커널)의 함수를 호출하는 것
- `trap`을 사용하여 인터럽트 벡터의 특정 위치로 이동
- 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
- 올바른 I/O 요청인지 확인 후 I/O 수행
- I/O 완료 시 제어권을 시스템 콜 다음 명령으로 옮김

인터럽트 당한 시점의 레지스터와 Program Counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.

사용자 프로그램이 운영체제에게 무언갈 요청하기 위해서 소프트웨어적으로 직접 인터럽트를 걸 수도 있다(이를 소트프웨어 인터럽트(=trap)라고 부른다). 인터럽트가 들어오면 mode bit가 0으로 바뀌고 CPU 제어권이 운영체제에게 넘어가게 된다.

 

#### 시스템 콜(System Call)

사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것.

 

#### 인터럽트

`Interrupt(하드웨어 인터럽트)` - 하드웨어가 발생시킨 인터럽트. 타이머 인터럽트, IO Controller가 거는 인터럽트 등..

`Trap(소프트웨어 인터럽트)`

- `Exception`: 프로그램이 오류를 범한 경우
- `System call`: 프로그램이 커널 함수를 호출하는 경우

인터럽트 관련 용어

- `인터럽트 벡터`: 해당 인터럽트의 처리 루틴 주소를 가지고 있다.
- `인터럽트 처리 루틴(Interrupt Service Routine, 인터럽트 핸들러)`: 해당 인터럽트를 처리하는 커널 함수

 

 

#### 현대의 운영체제는 인터럽트에 의해 구동된다. 즉, 운영체제는 CPU를 사용할 일이 없고 인터럽트가 들어올 때만 CPU를 사용한다.

### 동기식 입출력과 비동기식 입출력

입출력 방식에는 크게 동기식 입출력과 비동기식 입출력으로 나뉜다.

 

#### 동기식 입출력(Synchronous I/O)

I/O 요청 후 `입출력 작업이 완료된 후`에 제어가 사용자 프로그램에 넘어간다.

구현 방법 1

- I/O가 끝날 때까지 CPU를 낭비시키는 방법. 매 시점 하나의 I/O만 일어날 수 있다.

구현 방법 2

- I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗는 방법.
- I/O 처리를 기다리는 줄에 그 프로그램을 줄 세운다.
- 다른 프로그램에게 CPU를 준다.

#### 비동기식 입출력(Asynchronous I/O)

I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고, 제어가 사용자 프로그램에 `즉시 넘어간다.```

#####  

##### 두 경우 모두 I/O의 완료는 인터럽트로 알려준다.



![img](https://blog.kakaocdn.net/dn/Wq5ho/btqFQ93KEsw/Z15nu8CpQKaeURVK7ZjhV0/img.png)



I/O는 커널을 통해서만 할 수 있다.

Synchronous I/O는 사용자가 I/O 작업을 요청하고 결과가 돌아올 때까지 기다린다.

Asynchronous I/O는 결과를 기다리지 않고 요청만 해놓고 CPU 제어권을 얻어서 다른 작업을 한다. I/O 작업이 끝나면 인터럽트를 통해서 알려준다.

 

#### DMA 보충

빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용한다. `CPU`의 중재없이 `device controller`가 `device`의 `buffer storage`의 내용을 메모리에 `block` 단위로 직접 전송한다. 바이트 단위가 아니라 `block` 단위로 인터럽트를 발생시킨다.

 

### 저장장치 계층 구조



![img](https://blog.kakaocdn.net/dn/qoPHO/btqFRBFISwU/iCgEvB0KwDALuKzvthuMGK/img.png)



위로 갈수록 속도가 빠르고, 단위 공간당 가격이 비싸다. 그래서 용량이 적어진다.

이러한 계층 구조를 갖는 이유는 Caching(재사용)이다. 데이터를 접근 속도라 빠른 저장 공간에 올려서 재사용하는 것이 목적이다.

 

### 프로그램의 실행(메모리 Load)

프로그램이 어떻게 컴퓨터에서 실행될까?



![img](https://blog.kakaocdn.net/dn/b9B4pk/btqFQwZouP3/o2PoCaI59mSM3Lpa1xWoWk/img.png)



프로그램은 보통 실행 파일 형태로 파일 시스템에 저장되어 있다. 프로그램을 실행하면 메모리에 올라가서 프로세스가 된다.

정확하게는 물리적인 메모리에 바로 올라가는 것이 아니라, Virtual Memory를 거친다.

프로그램을 실행하면 그 프로세스만의 독자적인 메모리 주소 공간(Address space)이 형성된다. (code, data, stack으로 이루어 짐) -> Virtual Memory

이를 물리적인 메모리 공간에 올려서 실행을 시키게 되는데, 이 때 프로그램이 통째로 올라가지 않고 당장 실행에 필요한 부분만 올라간다. 메모리 낭비를 방지하기 위해 필요한 부분만 올리는 것이다.

당장 필요하지 않은 부분은 디스크의 Swap area라는 공간에 일시적으로 내려놓는다.

 