안녕하십니까 저는 이번에 핀테크 서버에 지원하게 된 26살 윤원철입니다. 저를 한마디로 소개드려보자면, 저는 현재진행형 인간이라고 소개드리고 싶습니다. 아직 엄청 오랜 기간은 아니지만, 서버 개발자가 되고 싶단 생각을 한 뒤부터 꾸준히 끊임없이 부족한 부분을 찾고 또 그걸 채워 나가고, 그러면서 동시에 재미도 찾아가면서 즐겁게 공부하고 있습니다.





**주력 언어가 뭔가요?**

저는 현재 자바를 주력 언어로 삼고 공부하고 있습니다.



**자바의 특징이 뭔가요?**

우선 자바의 가장 큰 특징이라면 자바 프로그램은 자바 버추얼 머신이라는 프로그램 위에서 실행이 되기 때문에 플랫폼 독립적이라는 특징이 있습니다.



**JVM 동작 방식이 어떻게 되나여?**

자바 프로그램의 실행 과정을 통틀어서 말씀 드리자면, 먼저 자바 파일을 자바 컴파일러가 자바 바이트코드로 바꿔줍니다. 이게 .class 파일이구요. 그럼 JVM 의 클래스 로더가 다른 자바 라이브러리들과 함께 자바 바이트코드를 갖고 와서 이를 JVM의 메모리 영역인 런타임 데이터 영역에 로딩을 합니다. 로딩된 클래스 파일들은 execution 엔진에 의해서 실행됩니다. 기존의 자바 바이트 코드를 JVM 내부에서 기계가 실행할 수 있는 형태로 변경을 합니다. 이 때 방식이 두갠데, 인터프리터 방식과 JIT 컴파일러 방식이 있습니다. 

먼저 인터프리터 방식은 자바 바이트 코드를 명령어 단위로 한줄씩 실행합니다. 요 방식은 다른 인터프리터 언어처럼 한 줄씩 수행하기 때문에 느립니다.

두번째로 JIT 컴파일러방식은 이런 인터프리터 방식의 단점을 보완하기 위해 생겨났습니다. 여기서 JIT는 저스트 인 타임의 줄임말인데, 이 방식은 인터프리터 방식으로 실행이 되다가  적절한 시점에 바이트 코드 전체를 컴파일해서 네이티브 코드로 변경하는 방식입니다. 여기서 네이티브 코드는 운영체제가 직접 실행할 수 있는 코드입니다. 핫스팟 jvm의 경우에는 말 그대로 핫 스팟, 그러니까 자주 수행되는 부분을 아예 네이티브 코드로 만들어서 그 부분을 수행할 때마다 인터프리팅하지 않고 바로 실행할 수 있게 하는 걸로 알고 있습니다.



**그럼 JVM의 메모리 공간에 대해서 설명해주세요**

넵. 런타임 데이터 영역에 메소드 영역, 스택 영역, 힙 영역, 그리고 PC 레지스터값들이 들어 있는 영역이랑 네이티브 메소드 스택이란 영역이 있습니다.

먼저 PC 레지스터는 다음에 수행해야할 위치를 갖고 있습니다. 그렇기 때문에 쓰레드 하나당 한개를 갖고 있어야 하기 때문에 쓰레드가 생성될때마다 하나씩 생성되는 공간입니다.

그리고 네이티브 메소드 스택에는 네이티브 코드가 들어갑니다. 자바가 아니라 다른 언어로 작성된 코드를 위한 공간입니다. 자바 네이티브 인터페이스를 통해서 바이트 코드로 변환해서 저장이 되고, 여기서 C 코드를 실행시켜서 커널로 접근할 수 잇씁니다.

메소드 영역은 클래스 정보를 처음 메모리 공간에 올릴때 초기화되는 대상을 위한 공간입니다. static으로 선언된 변수나 메소드가 올라갑니다. 자바 프로그램의 실행은 메인 메소드를 제일 먼저 찾아서 거기서부터 실행 흐름이 이어지기 때문에 메인 메소드가 또 static으로 선언되어 있다고 생각합니다. 

다음으로 스택 영역은 프로그램 실행 중에 임시로 할당되는 부분이라고 할 수 있습니다. 실행중에 메소드가 호출이 되면 이 영역에 스택 프레임이라는 각각의 메소드를 위한 메모리 공간이 주어지고, 여기에 멤버 변수 같은 정보가 저장이 됩니다. 이 메소드 수행이 다 끝나면 스택 프레임별로 삭제가 됩니다.

마지막으로 힙영역은 new 키워드를 통해서 생성된 객체가 할당이 되는 공간으로, GC의 대상이 되는 공간입니다.



**GC에 대해서 설명해보세요**





**자바 8의 특징이 뭐가 있나요?**

자바 8의 큰 변경점은 먼저 람다식과 stream api, 그리고 인터페이스에서 스태틱 메소드랑 디폴트 메소드를 구현할 수 있다는 점이 있습니다. 그리고 자바 8부터 Perm 영역이 없어지고 metaspace 영역이 생겨났습니다.



**그럼 람다식의 장점은 뭔가요?**

우선 코드가 짧아져서 가독성이 좋고, 무엇보다 싱글 메소드 인터페이스에 대해 그 구현체를 굉장히 간단히 작성할 수가 있습니다. 





**제네릭이 뭔가요?**

클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 것입니다. 다양한 타입의 객체를 다루는 메소드나 컬렉션 클래스에 컴파일 타임에 타입을 넘겨주는 기능이라고 알고 있습니다.



**hashCode() 가 뭔가요?**

일반적으로 각 객체의 주소값을 변환해서 만든 한 객체의 고유한 정수값입니다.

근데 String에서는 이게 재정의되어있는데 찾아 보니 문자 하나하나 가져와서 정수값으로 바꾸는 걸로 구현되어 있었습니다. 그래서 new 키워드로 만든 서로 다른 String 객체라도 그 값이 같으면 같은 hashCode() 값을 가집니다.



**프로세스와 쓰레드에 대해서 설명해보세요**

먼저 프로세스는 메모리에 적재되어서 실행중인 프로그램입니다. 여기서 말하는 프로그램은 파일 시스템에 실행가능한 형태로 있는 파일입니다. 그리고 쓰레드는 이 프로세스 안에서 실질적으로 작업 수행하는 실행의 단위입니다. 







**뮤텍스 특징 말해보세요**

뮤텍스는 크리티컬 섹션 문제를 해결하기 위한 조건 중에서 상호 배제에 해당하는 역할을 합니다. 쓰레드가 락을 획득한 상태에서만 크리티컬 섹션으로 들어갈 수 있고, 크리티컬 섹션에서 빠져 나올 때는 반드시 락을 반납합니다. 그렇게 해서 동시에 크리티컬 섹션에 두 개 이상의 쓰레드가 들어가지 못하도록 보장합니다. 

뮤텍스의 단점으로는 크리티컬섹션에 들어가기 전에 계속해서 반복문을 돌면서 락을 획득했는지를 체크하기 때문에 busy waiting이 있습니다. 따라서 CPU가 낭비된다는 단점이 있씁니다.



**세마포어는?**

세마포어는 뮤텍스와 달리 종류가 두 개가 있는데, 하나는 카운팅 세마포어입니다. 카운팅 세마포어는 뮤텍스처럼 1과 0 이런 정보가 아닌 정수 값을 가집니다. n개의 세마포어가 있다고 하면 크리티컬 섹션에 동시에 총 n개까지의 프로세스가 들어갈 수 있습니다. 또 다른 하나는 바이너리 세마포어인데, 이는 뮤텍스와 진배없다고 보면 됩니다.

이 방식도 busy waiting이 있어 비효율적입니다. 이에 대한 해결책으로는 block & wake up 방식의 구현이 있습니다.



block & wakeup 방식은 공유 데이터를 얻기를 기다리는 프로세스 자체를 아예 blocked 시켜버리는 방법입니다. 

프로세스가 세마포어를 얻고 크리티컬 섹션에 들어가려고 하는데 얻을 수 없다 하면은 커널이 이 프로세스를 blocked 상태로 만들고, 세마포어에 대한 wait queue에 이 프로세스의 pcb를 넣습니다.

세마포어가 반납이 돼서 wake up 하는 과정은 이 프로세스의 pcb를 ready queue로 옮기는 과정임니다.

다만, 크리티컬 섹션의 길이가 매우 짧으면, busy waiting 오버헤드보다 block 하고 wakeup하는 오버헤드가 더 커질 수 있습니다.





** 자바에서는 어떻게 thread-safe 함을 보장하는가?

자바에서 아직 멀티 쓰레드 환경을 구현해보진 못했는데.. synchronized 키워드를 통해서 thread-safe 하게 할 수 있는 걸로 안다...  이렇게 되면은 쓰레드 하나가 공유 데이터에 접근하면 알아서 다른 쓰레드들은 블락되는 걸로 알고이땅...ㅜ

** 자바에서는 쓰레드 어떻게 만드나?

Runnable 인터페이스를 구현하는 방법과 Thread 클래스를 상속받는 방법이 있다. 전자는 이를 다시 Thread 클래스로 바꿔야 한다.

** 그럼 Runnable은 왜 있는가 ? 

자바에서 다중 상속이 안되기 때문에 다른 클래스를 상속받아야하는 경우 Runnable 인터페이스를 구현하면 된다. 





**페이지 교체 알고리즘 말해보세요**











**MVC 모델 1이랑 모델 2의 차이가 뭔가요?**

가장 큰 차이점은 JSP 코드가 어디까지 역할을 하고 있나라고 말씀드릴 수 있습니다. 먼저 모델 1은 비즈니스 로직과 화면에 보이는 프레젠테이션 로직을 한꺼번에 담당하면 모



**가장 좋아하는 자료구조가 뭔가요?**

저는 맵을 좋아합니다. 왜냐하면 키-밸류를 한 쌍으로 갖고 있어서, 위치를 나타내는 인덱스가 아니라 특수한 키를 갖고 그에 매핑되는 값을 바로 갖고 올 수 있어서 좋습니다.

**써본 예를 들어주세요**

넹. 얼마전에 삼성 청년 소프트웨어 아카데미에서 웹 애플리케이션을 구현할 때 사용했는데, 사용자가 요청하는 액션에 따라 그에 맞는 비즈니스 로직을 처리하는 Controller를 바로 갖고 오도록 해시맵에 넣어서 구현했습니다. Controller 인터페이스를 만들고 그걸 구현받아서 여러 비즈니스 로직을 처리하는 Controller들을 구현해 놓고, 키에 그 액션, 스트링을 넣고, 밸류에 그 액션에 해당하는 Controller를 넣어놨습니다.





**마지막 하고 싶은 말 - 포부**

이곳 라인 플러스가 얼마나 뛰어난 개발자들이 많이 지원하고 또 계시는 곳인지 잘 알고 있다. 그에 반해 솔직히 지금 보여드린 저의 역량은 그에는 못 미칠 수 있다. 하지만 저는 1년 전까지만 해도 백엔드랑 프론트엔드도 뭔지 잘 몰랐다. 근데 지금은 이 프로그래밍 분야가 너무 재밌고 진정으로 하고 싶단 생각을 많이 하고 있기 때문에 일년 동안 많이 성장했다. 만약 입사해서 도메인이 좀 더 구체적으로 좁혀진다면 또 한번의 가파른 러닝 커브를 보여드릴 것을 약속할 수 있다. 이게 말만 번지르르한건지, 진짜로 한다면 하는 놈인지 보여드릴 기회를 한번 주시면 감사하겠습니다.



![image-20201001211822663](C:\Users\1Fe\AppData\Roaming\Typora\typora-user-images\image-20201001211822663.png)



#### 핀테크에 지원한 이유?

> 우선 제가 개발하고 싶은 서비스는 많은 사용자들에게 편의를 제공해주는 서비스입니다. 금융관련 서비스는 직업, 나이, 성별, 국적에 상관없이 매우 많은 사용자들이 이용하는 분야입니다. 그리고 라인은 작년 MAU가 1억 6
>
> 저 개인적으로 IT 기술의 발달로 인해 전과 비교해서 가장 편리함을 체감하는 분야가 금융 분야입니다. 불과 몇년전까지만 해도 은행 업무는 영업점에 직접 가서 보는 것이 당연했고, 오프라인에서 결제하는 것도 당연히 카드나 현금을 사용해야 했기 때문에 지갑을 들고 다니는게 너무도 당연한 삶이었지 않습니까? 근데 이제는 온라인에서 웬만한 은행 업무도 보고, 또 결제도 손쉽게 가능하다는 점에서 핀테크에 대한 매력과 앞으로의 비전을 확신했습니다. 
>
> 
>
> 돈을 다루는 분야이기 때문에 하나의 트랜잭션에서 데이터의 정합성까지~~ 난이도가 높은 비즈니스라고 생각합니다. 



## 자소서 정리 - 관련 질문

### 2번 - 남들과 차별화된 경험: 연극 팀장

"많은 동아리 중에서 연극 동아리를 하게 된 이유는?" - "아주 흔한 동아리는 아닌데 왜 연극 동아리를 하게 되었는지에 대해서 물어볼수 있을것 같습니다 ."

> 저는 어렸을 때부터 무대에 서는 것을 좋아했습니다. 어렸을 때부터 끼가 많아서 수학여행가서 무대에 올라서 노래도 부르고 춤도 추고 많이 했습니다. 그중에서도 노래 부르는 것을 많이 좋아해서 밴드부에 들어갈까도 생각했었는데 우연찮게 연극 동아리 모집 홍보 포스터를 접했습니다. 그때 든 생각이 뭔가 이번에 연극 동아리에 들어서 연극을 하지 않으면 평생 연기 해볼 일이 없지 않을까란 생각이 들었습니다. 그래서 재밌을 것 같다는 생각이 들어 연극 동아리에 가입하게 되었습니다.



"팀 활동을 할 때 주로 리더를 많이 하는가?" - "사람들을 이끄는 리더형 타입인지 뒤에서 백업하는 타입이 본인에게 맞는지를 물어볼수 있을것 같습니다."

> 넵 비교적 많이 하는 편입니다. 대신에 리더, 팀장을 맡은 후에 의견을 내면 대개 팀장의 의견을 그대로 수용하기 마련이었던 적이 꽤 많습니다. 그래서 팀장을 맡은 후에는 다른 의견을 최대한 많이 들어본 후에 그 의견들에 대한 제 의견이나 아니면 제 다른 생각을 슬쩍 내비치고 그거에 대해서 같이 얘기하려고 항상 노력합니다. 



"만약 팀간 혹은 협업 단계에서 갈등이 발생한다면 어떻게 개선할 수 있을까요?" - "아무래도 서버 네트워크 업무 특성상 여러 팀들과 같이 협업하는 경우가 많습니다. 그렇기 때문에 경청하는 역량과 커뮤니케이션 역량을 생각해보시면 좋을 것 같습니다"

> 아직 실무를 경험해본 적은 없지만, 나중에 업무를 할때 발생하는 의견 충돌들은 이미 개개인의 기술적인 역량은 어느정도 보장이 되어 있다고 생각하기 때문에, 자기소개서에서 말씀드렸듯이 서로의 의견을 서로가 충분히 이해하도록 도와줌으로써 개선하겠습니다.





### 3번 - CS 지식 중 직무와 연관된 내용: OS-쓰레드, 라운드 로빈, 자료구조/알고리즘-JCF

"효율성과 관련하여 최근 차세대 기술력과 같은 부분과 관련하여 아는 것이 있으면 간단하게 답변부탁드립니다." - "효율성 측면에서 최근 네트워크와 관련하여 혹은 서버와 관련하여 아시는게 있으면 정리해두시면 좋을 것 같습니다"

> 로드 밸런싱을 통해서 효율성을 확보할 수 있다고 생각합니다...
>
> 그리고.. 리버스 프록시 서버/?? 두는것도... 캐싱 기능이 있기 때문에 효율성을 확보할 수 있다고..생각합니ㅏㄷ...



- scale up - 서버의 사양을 늘리는 것. 메모리 증가 등등..
- scale out - 여러 대의 서버로 나누어 일을 하는 것.

#### * 리버스 프록시에 로드 밸런싱 기능도 있다!!

로드 밸런싱이 뭐냐 ?? 

> 로드 밸런서란 여러 대의 서버가 트래픽을 분산 처리할 수 있도록 요청을 나누어주는 서비스이다.
>
> L4 - Transport 계층. IP, Port 레벨에서 로드 밸런싱. e.g) 포트 번호로 나눠줌
>
> L7 - Application 계층. User Request 레벨에서 로드 밸런싱. e.g) /category 와 /search 를 담당 서버들로 나눠줌



로드 밸런싱 알고리즘

라운드 로빈 - 서버에 들어온 요청을 순서대로 돌아가면서 배정하는 방식. 서버의 스펙과 관계없이 트래픽을 나누어 주기 때문에 여러 서버가 동일한 스펙을 갖고 있고, 서버와의 연결이 오래 지속되지 않는 경우에 활용하기 적합하다.

가중 라운드 로빈 - 각 서버마다 가중치를 매기고, 가중치가 높은 서버에 클라이언트 요청을 우선적으로 배분한다. 주로 서버의 트래픽 처리 능력이 다른 경우 사용된다. 

IP 해시 방식 - 클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식. 사용자의 IP를 해싱해서 거기에 맞는 서버로 트래픽을 보내기 때문에 사용자는 항상 동일한 서버로 연결되는 것이 보장된다.

최소 연결 방식 - 요청이 들어온 시점에서 가장 적은 연결 상태를 보이는 서버에 우선적으로 트래픽을 배분하는 방식. 자주 세션이 길어지거나, 서버에 분배된 트래픽들이 일정하지 않은 경우 적합하다.

최소 리스폰 타임 - 서버의 현재 연결 상태와 응답 시간을 모두 고려하여 배분하는 방식. 가장 적은 연결 상태와 가장 짧은 응답 시간을 보이는 서버에 우선적으로 배분한다.

![img](https://post-phinf.pstatic.net/MjAxOTEyMTBfNCAg/MDAxNTc1OTU1MzY3OTM2.nG91HOEOh6Sc1AuUgbN3O4pcnEI-rh24UKSrrrjkrcsg.VcG18MidW4az7Oh0RQfRPLDBHNRyGayE1BsQxDImL3Ig.JPEG/L4-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1.jpg?type=w1200)



![img](https://post-phinf.pstatic.net/MjAxOTEyMTBfMjA1/MDAxNTc1OTU1MzgxODY5.odnG4CRES0e5bH7sOKyWRP1c8uO_XC4VX9A3HPeI1JQg.lNL2eJYbMz6NX1e5YFzfHDMQHn4YrdOJR2VYHmq5e1Ig.JPEG/L7-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1.jpg?type=w1200)





프록시가 뭐냐??

> 우선, 프록시 서버는 클라이언트와 서버 사이에서 통신을 대신 수행해주는 서버입니다. 캐시/보안/트래픽 분산 등의 여러 장점이 있습니다.
>
> 먼저 포워드 프록시는 클라이언트와 인터넷 사이에 위치하고 있다. 특징으로는 첫째 캐싱이 있다. 클라이언트가 요청한 내용을 캐시로 갖고 있는다. 두번째 특징으로는 익명성이 있다. 클라이언트가 보낸 요청을 감출 수 있는 것이다. 서버가 응답 받은 요청을 누가 보냈는지 알지 못하게 한다. 즉, 서버가 받은 요청 IP = Proxy IP.
>
> 리버스 프록시는 인터넷과 서버 사이에 위치하고 있다. 마찬가지로 클라이언트가 요청한 내용을 캐싱한다. 두번째 특징으로는 서버 정보를 클라이언트로부터 숨길 수 있기 때문에 보안성 측면이 있다. 클라이언트는 리버스 프록시를 실제 서버라고 생각하여 요청한다. 따라서 실제 서버의 IP가 노출되지 않는다. 







### 4번 - SW 개발 활동: Enjoy the Challnges-고웹, Go Brave, No Fear, No Regrets-인도 인턴

**"왜라는 질문을 여쭤보는것은 본질적으로 이프로젝트를 왜했고 구체적으로 어떠한 부분에서 본인이 개선하고 싶었으며 어떻게 문제를 해결했는지에 대한 전체적인 대답을 듣고싶은 질문이겠습니다. 따라서 기술적인 스택이 없더라도 본인이 한 프로젝트를 가지고 왜하였으며 어떠한 문제점을 해결하고 싶었고 결과가 어땟는지 논리적으로만 답변하면 충분히 좋아 보일 것 같습니다."**



고급 웹프로그래밍 과목에서 한 프로젝트에선 어떤 어려움이 있었나 ??

> 지금 생각해보면 기술적으로 엄청 어려운 부분은 아니었긴 한데.. 서블릿에서 페이지간 이동 방법에 대한 이해가 완벽하지 못해서 조금 어려움이 있었다. forward 방식과 redirect 방식의 차이점을 명확히 이해하지 못했어서 데이터 삽입이나 수정, 삭제가 일어난 후에 redirect 방식이 아닌 forward 방식을 사용해서 거기서 새로고침을 할 때마다 같은 데이터가 계속해서 들어가는 오류가 있었다.



MySQL과 Oracle의 차이는 무엇이 있나??

>오라클은 비싸다.
>
>MySQL은 가볍다.
>
>데이터에 있어서 오라클은 대소문자를 구분한다.





MVC 1 패턴과 2 패턴의 차이점은??

> 먼저 MVC 패턴은 디자인 패턴 중 하나로, 하나의 프로젝트를 구성하는 구성 요소를 Model, View, Controller 이렇게 세가지 역할로 구분한 디자인 패턴이다.
>
> 사용자로부터 요청이 들어오면 컨트롤러에서 이 요청을 받아서 모델에서 데이터를 갖고와서 요청에 맞는 처리를 하고, 뷰 단에서는 결과값을 화면에 출력하는 역할을 한다.
>
> 가장 큰 차이는 JSP가 클라이언트의 요청에 대한 로직 처리와 응답 페이지에 대한 처리를 한번에 하느냐 아니면 view 단만 처리하는지이다.
>
> 







"텐서플로우 코드를 WebOS에 올리지 못하여 문제를 해결하지 못했다고 하셨는데, 현재는 방법을 찾았나요?" - "지속적으로 문제점을 해결하기 위해서 현재도 노력하는지에 대한 여부를 볼 수 있겠습니다. 만약 현재까지도 이러한 문제를 해결하기 위해서 노력하고 있는 점을 어필하시면 좋은 점수를 받을 수 있을 것 같습니다!"

> 그 당시에는 자소서에서 말씀드렸다시피 이론에만 국한된 지식을 갖고 있었습니다. 지금 만약에 돌아가서 프로젝트를 진행한다면 AWS 같은 클라우드 시스템을 통해서 서버를 구축해서 웹 애플리케이션에서 사용자로부터 데이터를 받아서 그걸 서버로 보내서 필요한 결과값을 다시 애플리케이션으로 보내는 식으로 프로젝트를 진행하겠습니다.











\1. Class와 Object의 차이점이 뭐죠? 

\2. Override와 Overload의 차이점이 뭘까요? 

\3. 퀵소트/버블소트 알고리즘을 설명할 수 있나요?

\4. (C) 포인터에 대해 설명해줄 수 있나요? 

\5. (자료구조) 스택, 트리, 큐, 힙 개념에 대해 설명할 수 있나요? 

\7. (DB) 인덱스에 대해 설명해주세요.

\8. (네트워크) OSI 7 Layer에 대해 설명해주세요. 





\1. 서버 개발을 할 때 TCP와 UDP 중 무엇을 쓸 건가요? 그리고 그 이유를 알려주세요.

\2. TCP의 특징을 말해주세요.

\3. 프로세스와 스레드에 대해서 설명해주세요. 

\4. MVC 구조/MSA에 대해서 설명해주세요.

\5. 송신지와 수신지에 대해서 설명해주세요.

\6. 데이터베이스 트랜잭션의 성질 4가지가 설명해줄 수 있나요?

\7. Singleton / Decorator / Proxy / Strategy 디자인 패턴에 대해 아시나요? 

\8. Java 접근 제어자에 대해 설명해주세요. 

\9. List, LinkedList, ArrayList에 대해서 설명해주세요.

\10. 비동기 방식과 동기 방식을 설명해주세요. 

프로세스 쓰레드



객체 지향







어노테이션