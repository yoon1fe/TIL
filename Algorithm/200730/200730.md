### 부분 집합

집합에 포함된 원소들을 선택하는 것.

다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것이다. e.g) knapsack Problem

부분 집합의 수

- 집합의 원소가 n개일 때, 공집합을 포함한 부분 집합의 수는 2^n개이다.
- 이는 각 원소를 부분 집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다



#### 반복문을 이용한 power set 구하기

```
for i1 in 0 -> 1
	bit[0] <- i1			//0번째 원소
	for i2 in 0 -> 1
		bit[1] <- i2		//1번째 원소
		for i3 in 0 -> 1
			bit[2] <- i3	//2번째 원소
			print_array()
```



subset(): **원소**`(변경요인)` 부분 집합 구현에 처리(포함/미포함)

더이상 처리할 원소 없으면 return

해당 원소 부분 집합 포함 (O)

-> 다음 원소 부분 집합 처리(재귀)

해당 원소 부분 집합 미포함 (X)

-> 다음 원소 부분  집합 처리(재귀)





### 스택(Stack)

물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조이다.

스택에 저장된 자료는 선형 구조를 갖는다.

- 선형 구조: 자료 간의 관계가 1대1의 관계를 갖는다
- 비선형 구조: 자료 간의 관계가 1대N의 관계를 갖는다. e.g) 트리

스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.

후입선출 구조(LIFO, Last-In First-Out)

- 마지막에 삽입한 자료를 가장 먼저 꺼낸다.

#### 연산

- 삽입: 저장소에 자료를 저장한다. 보통 `push`라고 한다.
- 삭제: 저장소에서 자료를 꺼낸다. 꺼낸 자료는 삽입한 자료의 역순으로 꺼낸다. 보통 `pop`이라고 한다.
- 스택이 공백인지 아닌지 확인하는 연산: `isEmpty`
- 스택의 top에 있는 item(원소)를 반환하는 연산: `peek`

![image-20200730104703484](C:\Users\1Fe\AppData\Roaming\Typora\typora-user-images\image-20200730104703484.png)



*`Ctrl + Shift + o` - import 정리



### 큐(Queue)

스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조. 선입선출(FIFO: First-In First-Out) 구조이다.

#### 연산

- 삽입: enQueue: 큐의 뒤쪽(rear 다음)에 원소를 삽입하는 연산
- 삭제: deQueue: 큐의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산
- isEmpty()
- isFull()
- Qpeek(): 큐의 앞쪽(front)에서 원소를 삭제없이 반환하는 연산



#### Queue API

`java.util.Queue`

- 큐에 필요한 연산을 선언해놓은 인터페이스
- LinkedList 클래스를 구현체로 많이 사용한다.

주요 메소드

- offer()
- poll()
- isEmpty()
- size()

|     Interface     |            Class             |
| :---------------: | :--------------------------: |
| spec(명세) - What | implementation(구현체) - How |



*다형성

e.g) `Queue<E> q = new LinkedList<>();` LinkedList로 Queue를 구현. Queue가 상위 타입.

-> Queue에 선언된 메소드만 사용 가능하다.

