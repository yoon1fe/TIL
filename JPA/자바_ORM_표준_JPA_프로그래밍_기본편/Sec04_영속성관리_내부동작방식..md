## 영속성 컨텍스트

**JPA에서 가장 중요한 2가지**

- 객체와 RDB 매핑하기 (Object Relational Mapping)
- **영속성 컨텍스트**



**영속성 컨텍스트**

- JPA를 이해하는데 가장 중요한 용어
- "엔티티를 영구 저장하는 환경"
- EntityManager.persist(entity); -> 단순히 DB에 저장하는 것이 아닌, 엔티티를 영속화하는 것(영속성 컨텍스트에 저장)!
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근한다.



**엔티티의 생명주기**

- 비영속(new/transient)
  - 영속성 컨텍스트와 관계없는 **새로운** 상태
  - 엔티티 객체를 생성만 해놓은 상태
  - JPA와 아무 관련 없다.
- 영속(managed)
  - 영속성 컨텍스트에서 **관리**되는 상태
  - em.persist(entity);
  - 바로 DB에 쿼리가 날아가지 않는다.
- 준영속(detached)
  - 영속성 컨텍스트에 저장되었다가 **분리**된 상태
- 삭제(removed)
  - **삭제**된 상태



**영속성 컨텍스트의 장점**

- 1차 캐시(한 트랜잭션 내에서)
- 동일성(identity) 보장
  - 1차 캐시로 인해 REPEATABLE READ 트랜잭션 격리 수준을 애플리케이션 차원에서 제공.
- 트랜잭션을 지원하는 쓰기 지연(transactional write-bebind)
  - transaction.commit() 하는 순간 실질적으로 DB 쿼리를 실행.
- 변경 감지(Dirty Checking)
  1. flush() 되면 엔티티와 스냅샷을 비교
  2. UPDATE SQL 생성
  3. DB로 flush 후 커밋

- 지연 로딩(Lazy Loading)



## 플러시(flush)

- 영속석 컨텍스트의 변경 내용을 DB에 반영하는 것



**플러시가 발생하면 생기는 일**

- 변경 감지하고
- 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송



**영속성 컨텍스트를 플러시하는 법**

- em.flush() - 직접 호출
- 트랜잭션 커밋 - 자동 호출
- JPQL 쿼리 실행 - 자동 호출
  - 자동 호출되는 이유 ?
    - JPQL 쿼리 실행 전에 persist() 하고 쿼리 실행하면 아무 것도 안나올까봐.. 쿼리 실행 직전에 플러시해줌.



**플러시 모드 옵션**

`em.setFlushMode(FlushModeType.COMMIT)`

- FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시(default)
- FlushModeType.COMMIT: 커밋할 때만 플러시



**플러시는!(결론)**

- 영속성 컨텍스트를 비우는 액션이 아님!
- 영속성 컨텍스트의 변경 내용을 DB에 동기화
- 트랜잭션이라는 작업 단위가 중요!  -> 커밋 직전에만 동기화하면 된다~



## 준영속 상태

**영속 상태가 되는 경우**

- persist()
- find() 해서 1차 캐시에 저장



**준영속 상태**

- 영속 -> 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
- 영속성 컨텍스트가 제공하는 기능을 사용 못함.



**준영속 상태로 만드는 방법**

- em.detach(entity): 특정 엔티티만 준영속 상태로 전환
- em.clear(): 영속성 컨텍스트를 완전히 초기화
- em.close(): 영속성 컨텍스트를 종료
