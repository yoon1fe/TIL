### RDB와 자바

PostgreSQL 사용해보자.

JDBC - (관계형) 데이터베이스와 자바의 연결 고리. 중간 다리 역할

데이터베이스를 사용하는 이유: 애플리케이션의 데이터를 영속화`persistence`하기 위함



JDBC 코드는 상당히 더럽다.

``` java
        try(Connection connection = DriverManager.getConnection(url, username, password)) {
            System.out.println("Connection created: " + connection);
            String sql = "INSERT INTO ACCOUNT VALUES(1, 'keesun', 'pass');";
            try(PreparedStatement statement = connection.prepareStatement(sql)) {
                statement.execute();
            }
        }
```



### ORM 개요

Object-Relation Mapping



``` java
Account account = new Account(“keesun”, “pass”);
accountRepository.save(account);
```





JDBC 대신 도메인 모델을 사용하는 이유

- 객체 지향 프로그래밍의 장점 활용을 위해
- 각종 디자인 패턴 사용 가능
- 코드 재사용성 향상
- 비즈니스 로직 구현 및 테스트하기 용이 -> 유지보수성 향상



ORM은 애플리케이션의 클래스와 SQL 데이터베이스의 테이블 사이의 **맵핑 정보를 기술한 메타데이터**를 사용하여, 자바 애플리케이션의 객체를 SQL 데이터베이스의 테이블에 **자동으로 (또 깨끗하게) 영속화** 해주는 기술



ORM 툴을 사용했을 때 장/단점



장점

- 생산성
- 유지보수성 - 코드 수가 확 적어진다
- 성능 - 우리가 직접 만든 쿼리보다 하이버네이트가 만들어준 쿼리가 더 느릴 수도 있다. 하지만, 하이버네이트가 성능 최적화해주는 것이 많다. **객체와 데이터베이스 사이에 캐시**가 존재하기 때문에 한 트랜잭션 안에서 불필요한 쿼리를 날리지 않는다. 캐시에서 객체의 변화를 감지하고 변경사항을 DB에 반영해야 하는 시점에만 쿼리를 날린다.
- 벤더 독립성 - 하이버네이트에 dialect만 설정해주면 그 dialect에 맞는 쿼리를 생성해준다.

단점

- 학습비용...!!!!



### ORM 패러다임 불일치

객체를 릴레이션에 매핑하려 할 때 발생하는 문제들과 해결책



#### 밀도(Granularity) 문제

| 객체                                                         | 릴레이션                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 다양한 크기의 객체를 만들 수 있음<br />커스텀한 타입을 만들기 쉬움 | 크기는 항상 테이블<br />기본 데이터 타입 사용(User Defined Type이 있지만 잘 안쓴다) |



#### 서브타입(Subtype) 문제

| 객체                              | 릴레이션                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| 상속 구조 만들기 쉬움<br />다형성 | 테이블 상속이란 개념 없음<br />다형적인 관계를 표현할 방법이 없음 |

ORM 에서 다형성을 지원해준다. 매핑 자체가 쉽진 않지만..



#### 식별성(Identity) 문제

| 객체                                                         | 릴레이션                                                |
| ------------------------------------------------------------ | ------------------------------------------------------- |
| 레퍼런스 동일성 (==)<br />인스턴스 동일성 (`equals()` 메서드) | 주키 (primary key)가 같은지에 따라 같은 레코드인지 식별 |



#### 관계(Association) 문제

| 객체                                                         | 릴레이션                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 객체 레퍼런스로 관계 표현<br />근본적으로 '방향'이 존재한다<br />다:다 관계 가능 | 외래키(foreign key)로 관계 표현<br />'방향'이란 의미가 없고 join 으로 아무거나 묶을 수 있다<br />조인 테이블이나 링크 테이블을 사용해 두 개의 1:다 관계로 다:다를 표현해야 한다 |

`@ManyToMany` 어노테이션 사용으로 해결 가능



#### 데이터 네비게이션(Navigation) 문제

| 객체                                                         | 릴레이션                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 레퍼런스를 이용해서 다른 객체로 이동 가능<br />컬렉션을 순회할 수도 있다 | 이 방식은 릴레이션에서 데이터를 조회하는데 매우 비효율적이다<br />DB에 요청을 적게 할수록 성능이 좋기 때문에 Join 사용 <br />하지만 너무 많은 Join도 비효율적이다.<br />그렇다고 lazy loading을 하자니 그것도 문제다(n+1 select).. |



### JPA 프로그래밍 1. 프로젝트 세팅

docker 에 postgreSQL 설치

``` bash
docker run -p 5432:5432 -e POSTGRES_PASSWORD=pass -e POSTGRES_USER=yoon1fe -e POSTGRES_DB=springdata --name postgres_boot -d postgres

docker exec -i -t postgres_boot bash

su - postgres

psql --username yoon1fe --dbname springdata

# DB 조회
\list

# 테이블 조회
\dt
```



``` sql
Create table account(id int, username varcher(255), password varcher(255));
```



우리는 대부분의 상황에서 Spring Data JPA 를 사용하지, JPA나 Hibernate API를 직접 사용하진 않는다.



`application.properties` 에 JDBC Datasource  설정 추가

``` properties
spring.datasource.url=jdbc:postgresql://localhost:5432/springdata
spring.datasource.username=yoon1fe
spring.datasource.password=pass

# hibernate 관련 설정

spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
# 애플리케이션이 구동될 때마다 새로운 스키마 생성
spring.jpa.hibernate.ddl-auto=create
# create 는 개발 용도로만 사용, 아니면 validate
```



도메인 클래스 Account 생성

```java
package me.yoon1fe.springdata;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity	// DB의 account 테이블에 매핑되는 클래스임을 명시
@Getter
@Setter
public class Account {
  
  @Id							// primary key
  @GeneratedValue	// 자동 생성
  private Long id;
  
  private String username;
  private String password;
}
```



필드 변수명과 컬럼명이 동일하다면 `@Column` 어노테이션 생략 가능



```java
package me.yoon1fe.springdata;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
@Transactional
public class JpaRunner implements ApplicationRunner {

  @PersistenceContext
  EntityManager entityManager;

  @Override
  public void run(ApplicationArguments args) throws Exception {
    Account account = Account.builder()
        .username("yoon1fe")
        .password("password")
        .build();

    entityManager.persist(account);

  }
}
```



``` bash
springdata=# select * from account;
 id | password | username 
----+----------+----------
  1 | password | yoon1fe
(1 row)
```





`EntityManager` - JPA의 핵심. entityManager 를 통해 영속화 가능하다.



Hibernate API도 직접 사용할 수 있다. `Session`사용한다.

```java
Session session = entityManager.unwrap(Session.class);
session.save(account);
```



`spring.jpa.hibernate.ddl-auto=update`

해놓고, 엔티티 클래스에 필드 변수를 추가하면 테이블에도 컬럼 추가한다. 편하긴한데, 좋은 건 아니다..;; 다시 지워도 컬럼이 사라지지 않는다. 따라서 비추



도메인 모델을 기반으로 스키마를 생성하는 기능 자체는 매우 편리하지만, 조심해서 사용해야 한다.



### JPA 프로그래밍 2. 엔티티 타입 매핑

도메인 모델을 만들고 릴레이션, 테이블에 어떻게 매핑시킬지에 대한 정보를 하이버네이트에 줘야 한다.

- 어노테이션 방식
- xml 방식 - 최근에는 안쓴다.



`@Entity`

- **객체 세상**에서 부르는 이름
- 보통 클래스와 같은 이름을 사용한다. 
  - `@Entity(name = "myAccount")` : 하이버네이트에서 엔티티 이름을 myAccount로 간주
- 엔티티의 이름은 **JQL**에서 사용된다.



`@Table`

- **릴레이션 세상**에서 부르는 이름
- `@Entity` 이름이 기본값이므로 생략 가능하다.
- 테이블의 이름은 **SQL**에서 사용된다.



`@Id`

- 엔티티의 primary key 를 매핑할 때 사용
- 자바의 모든 primitive 타입과 그 Wrapper 타입을 사용할 수 있다.



`@GeneratedValue`

- primary key의 생성 방법을 매핑
- 생성 전략과 생성기를 설정할 수 있다.
  - 기본 전략은 AUTO: 사용하는 DB에 따라 적절한 전략 선택
    - TABLE
    - SEQUENCE
    - IDENTITY
  - 명시적으로 설정
    - `@GeneratedValue(strategy = GenerationType.AUTO)`



`@Column`

- 생략 가능
- 옵션
  - `unique`
  - `nullable` - 디폴트 true
  - `length`
  - `columnDefinition`
  - ...



`@Temporal`

- 날짜 데이터 관련
  - TemporalType.DATE
  - TemporalType.TIME
  - TemporalType.TIMESTAMP
- JPA 2.1까지는 Date와 Calendar만 지원한다



`@Transient`

- 컬럼으로 매핑하고 싶지 않은 멤버 변수에 사용



### JPA 프로그래밍 3. Value 타입 매핑



Entity 타입과 Value 타입의 구분

- 식별자가 있어야 하는가?
- 독립적으로 존재해야 하는가?



Value 타입 종류

- 기본 타입 (String, Date, Boolean, ...)
- Composite Value 타입
  - ex) Address 클래스
- Collection Value 타입



Composite Value 타입 매핑

- `@Embadable`
- `@Embadded`
- `@AttributeOverrides`
- `@AttributeOverride`



``` java
package me.yoon1fe.springdata;

import javax.persistence.Embeddable;

@Embeddable
public class Address {

  private String street;
  private String city;
  private String state;
  private String zipCode;
}
```



```java
// Account.java
@Embedded
@AttributeOverrides({
    @AttributeOverride(name = "street", column = @Column(name = "home_street"))
})
private Address address;
```



``` sql
Hibernate: 
    
    create table account (
       id int8 not null,
        city varchar(255),
        state varchar(255),
        home_street varchar(255),
        zip_code varchar(255),
        password varchar(255),
        username varchar(255) not null,
        primary key (id)
    )
```



### JPA 프로그래밍 4. 관계 매핑



### JPA 프로그래밍 5. 엔티티 상태와 Cascade



### JPA 프로그래밍 6. Fetch





### JPA 프로그래밍 7. 쿼리



### 스프링 데이터 JPA 원리



