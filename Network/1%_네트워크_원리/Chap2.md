## Chapter 2. TCP/IP 의 데이터를 전기 신호로 만들어 보낸다

_프로토콜 스택과 LAN 어댑터의 탐험



OS에 내장된 네트워크 제어용 소프트웨어를 **프로토콜 스택**이라고 한다. 이 소프트웨어는 브라우저에서 받은 메시지를 패킷 속에 저장하고, 수신처 주소 등의 제어 정보를 덧붙인다. 또한, 통신 오류가 발생했을 때 패킷을 고쳐서 보내거나 데이터 통신의 기본을 조절하고, 이 패킷을 LAN 어댑터에 넘기는 등의 다양한 역할을 한다.



애플리케이션에서 의뢰를 받은 프로토콜 스택이 TCP 프로토콜을 이용하여 메시지를 송신하는 동작은 4단계로 나눌 수 있다.

1. 소켓 작성
2. 서버에 접속
3. 데이터 송수신
4. 서버에서 연결을 끊어 소켓 말소



### 1. 소켓을 작성한다

우선 프로토콜 스택의 내부는 크게 TCP, UDP 그리고 IP 계층으로 이루어져 있다. TCP나 UDP 프로토콜을 사용하여 데이터의 송수신을 담당하고, 이 둘이 애플리케이션에서 보낸 의뢰를 받아 송수신 동작을 실행한다. 둘의 차이를 대강 적어보자면 다음과 같다.

- TCP - 브라우저나 메일 등의 일반적인 애플리케이션이 데이터 송수신할 때
- UDP - DNS 서버에 대한 조회 등 짧은 제어용 데이터를 송수신할 때



그 아래에서는 IP 프로토콜을 사용해서 패킷 송수신 동작을 제어한다. 패킷을 통신 상대까지 운반하는 것이 IP의 주 역할이다.



프로토콜 스택의 내부에는 제어 정보를 담는 메모리 영역이 있다. 통신 상대의 IP 주소, 포트 번호 등등이 담겨 있는데, 이 제어 정보가 소켓의 실체라고 할 수 있다. 프로토콜 스택은 이 제어 정보를 참조하면서 동작한다. 



### 2. 서버에 접속한다

클라이언트 측의 소켓을 서버 측의 소켓에 접속하는 단계이다. 



소켓을 만들면 애플리케이션은 connect를 호출한다. 그러면 프로토콜 스택은 자신 쪽의 소켓을 서버측 소켓에 접속한다. 여기서 말하는 접속을 좀 더 풀어보자면, 송신 측에서 소켓을 만드는 동작`socket` 만으로는 프로토콜 스택에는 아무것도 전달되지 않는다. 따라서 수신받을 서버의 IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데, 이것이 접속 동작 중 하나이다.



서버 측에서도 socket을 만들었다고 들어올 연결 정보를 알지 못한다. 그래서 클라이언츠 측에서 IP 주소는 뭐고, 포트 번호는 뭐라는 정보를 알려서 통신하려 하는 것을 서버 측에 전달한다. 이와 같이 클라이언트 측에서 서버 측에 통신 동작의 개시를 전달하는 것도 접속 동작의 일부이다. 이렇게 되면 서버-클라이언트 간에 데이터를 송수신할 수 있는 상태가 된다.

![img](https://media.geeksforgeeks.org/wp-content/uploads/TCP-connection-1.png)

TCP 에서 연결을 맺는 것은 3-way handshake로 진행된다. 단순히 표현해보자면 다음과 같다.



1. 클라이언트가 서버에게 SYN(SYNchronization) 플래그를 보낸다. (sequence: x)
2. **P: Q야 통신하자(SYN)**
3. 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK(ACKnowledgement) 와 SYN 플래그를 보낸다. (sequence: y, ACK: x + 1)
4. **Q: 잘 받았어(ACK) 통신하자(SYN)**
5. 클라이언트는 서버의 응답으로 ACK(x + 1)와 SYN(y) 플래그를 받고, ACK(y+1)를 서버로 보낸다.
6. **P: 잘 받아써**



### 3. 데이터를 송수신한다

소켓이 연결된 후 메시지를 송신하는 단계이다. 여기서 프로토콜 스택은 애플리케이션에서 의뢰받은 메시지를 작은 조각으로 나누어서 서버로 송신한다. 



connect 명령어 작업에서 애플리케이션에 제어가 되돌아오면 데이터 송수신 동작에 들어간다. 이 동작은 애플리케이션이 write 를 호출하여 송신 데이터를 프로토콜 스택에 건네주는 곳부터 시작된다. 서버측에 전달할 송신 데이터를 받은 프로토콜 스택은 받은 데이터의 내용을 알지 못한다. 



프로토콜 스택은 받은 데이터를 곧바로 서버측에 보내지 않고, 송신용 버퍼 메모리에 저장하고 다음 데이터를 기다린다. 한 번의 송신 의뢰에서 전달되는 데이터의 길이는 애플리케이션에 의해 결정된다. 만약 송신 데이터의 길이가 짧은 상황에서 프로토콜 스택이 받은 데이터를 바로 전송한다면 작은 패킷을 많이 보내게 될 수도 있다. 그렇기 때문에 어느 정도 데이터를 저장하고 나서 송수신 동작을 수행한다.



그럼 언제 버퍼 메모리에 있는 데이터를 송신할까? 여러 판단 요소 중 하나는 한 패킷에 저장할 수 있는 데이터의 크기이다. 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이를 MTU라고 하는데, 이더넷에서는 보통 1500바이트이다. MTU에는 패킷의 맨 앞부분에 헤더가 포함되어 있어서 MTU에서 헤더를 제외한 것이 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이가 되고, 이를 MSS 라고 한다.



또 다른 판단 요소는 타이밍이다. 프로토콜 스택 내부에는 타이머가 있어서 이것으로 일정 시간 이상 경과하면 패킷을 송신하게 된다. MSS 와 타이밍은 서로 상반된 면이 있다. 따라서 양자를 절충해서 적당히 시간을 가늠하여 송신 동작을 실행해야 한다.



이제 패킷이 서버에 송신되는데, TCP 에서는 송신한 패킷이 상대에게 잘 도착했는지 확인하고, 도착하지 않았다면 다시 송신하는 기능이 있다. 데이터 조각은 각각 시퀀스 번호를 갖고 있는데, 추가로 수신측은 패킷이 잘 도착하면 데이터를 몇 번째 바이트까지 수신한 것인지 계산하여 그 값을 TCP 헤더의 ACK 번호에 기록하여 송신측에 알려준다. ACK 번호와 시퀀스 번호를 갖고 패킷 누락 여부를 확인하는 것이다. 참고로 시퀀스 번호는 1부터 시작하지 않고, 난수로 생성된다. 만약 시퀀스 번호가 항상 1부터 시작한다면 이를 악용해 공격이 들어올 수 있기 때문이다. 



브라우저(애플리케이션)의 의뢰를 받아 프로토콜 스택이 HTTP 리퀘스트 메시지를 보내는 동작은 끝이지만, 브라우저가 해야 할 일이 남아있다. HTTP 리퀘스트 메시지를 보내면 다음에는 웹 서버에서 응답 메시지를 기다린다. 브라우저가 프로토콜 스택에게 리퀘스트 메시지 송신을 의뢰한 뒤 응답 메시지를 받기 위해 read 프로그램을 호출한다. 그럼 프로토콜 스택에게 제어가 넘어가고 송신 때와 마찬가지로 수신 버퍼를 사용해서 응답 메시지를 수신하게 된다.



### 4. 서버에서 연결을 끊어 소켓을 말소한다

메시지의 송수신이 모두 끝나면 서버에서 연결을 끊고 소켓을 말소하는 단계이다.



데이터 송수신을 종료하는 것은 애플리케이션이 송신해야 하는 데이터를 모두 받았다고 판단했을 때이다. 이때 송수신 동작이 끝나는 쪽이 어딘지는 애플리케이션에 따라 다르다.



서버 측에서 연결 끊기 단계에 들어가는 경우에는 서버측 애플리케이션이 먼저 Socket 라이브러리의 close 를 호출한다. 그럼 서버측의 프로토콜 스택이 TCP 헤더를 만들고, 여기에 연결 끊기를 나타내는 정보를 담는다. 구체적으로는 컨트롤 비트의 FIN 비트를 1로 설정하는 것이다.



연결을 끊는 동작은 TCP에서는 4-way handshake로 진행된다. 



![img](https://media.geeksforgeeks.org/wp-content/uploads/CN.png)



1. 클라이언트는 서버에게 연결을 종료한다는 FIN(FINish) 플래그를 보낸다.
2. **P: 그만하자(FIN)**
3. 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. 이 때 모든 데이터를 보내기 위해 TIME OUT 상태가 된다.
4. **Q: 알겠어(ACK) 잠깐만 있어봐 (TIME OUT)**
5. 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.
6. **Q: 마저 다 보냈어. 그만하자(FIN)**
7. 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다.
8. **P: 알게써(ACK) 잠만 있어바(TIME OUT)**
9. 서버는 ACK를 받은 이후 소켓을 닫는다. (closed)
10. TIME_WAIT 시간이 끝나면 클라이언트도 소켓을 닫는다. (closed)