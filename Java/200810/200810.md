### 상속

대표적인 `OOP` 특징이다.

어떤 클래스 B가 다른 클래스 A의 멤버 변수과 메소드를 그대로 받으면 B가 A를 상속받는다고 한다.

이 때, A와 B의 관계를 부모-자식 또는 상위-하위 라고 부른다.



하나의 부모는 여러 자식을 가질 수 있고, 부모는 또 다른 부모의 자식이 될 수도 있다.

어떤 클래스가 아무런 상속을 받지 않는 경우, 자동으로 `java.lang.Object` 클래스가 그 클래스의 부모 클래스가 된다.



상속을 할 땐 `extends `키워드를 사용한다. **자바는 단일 상속만 가능**하다.

상속받은 클래스는 부모 클래스의 멤버 변수와 메소드를 상속받고, 자신만의 멤버 변수와 메소드 또한 가질 수 있다.



#### `this`, `super`

`this`: 자기 자신

`super`: 부모 객체

부모클래스에 있는 것을 다이렉트로 접근할 때 사용한다.

`super. ~~` : 부모 클래스의 메소드나 멤버 변수에 접근할 수 있다.

`super();` : 부모 클래스에 있는 생성자를 호출한다.

`this();` : 자기 자신의 생성자를 먼저 찾는다.

#### * 상속을 하면 상속받은 클래스들이 모두 같이 메모리에 올라간다.

생성자 내에서 자동 처리되는 일 - `compile` 시점에서

`this` 또는 `super` 생성자 호출 코드를 찾는다.

만약 호출하는 코드가 없다면, 자식 클래스의 생성자는 자동으로 **부모 클래스의 생성자를 호출**한다! 

그래서 생성자 자동 생성하면 `super();` 가 생기는구나



#### 접근 제한자 `(Access Modifier)`

|   구분    | Same Class | Same Package | Sub Class | Universe |
| :-------: | :--------: | :----------: | :-------: | :------: |
|  private  |     O      |      X       |     X     |    X     |
| (default) |     O      |      O       |     X     |    X     |
| protected |     O      |      O       |     O     |    X     |
|  public   |     O      |      O       |     O     |    O     |



* 상위 패키지(com.yoon1fe)에서 하위 패키지(com.yoon1fe.algorithm)에 접근 하는 것도 다른 패키지 접근이다.



### 다형성 `(Polymorphism)`

하나의 이름으로 여러 개의 형태를 구성할 수 있는 `OOP`의 특징.

#### `method`

- `overloading` - 이름이 같고, 파라미터가 다르면 별개의 메소드로 간주한다. 생성자도 동일함.
- `overriding` - 상속 관계에서 부모 클래스의 메소드를 자식 클래스에서 **재정의**할 수 있다.

#### `Type`

부모 타입으로 자식 타입의 객체를 `Reference`할 수 있다. 즉, 한 개의 타입으로 여러 하위 타입의 객체를 할당받을 수 있다.



#### @Override Annotaion

메소드를 재정의 할 때, 어노테이션을 권장한다. 컴파일러에게 오버라이딩을 한다고 명시해주는 것이다.



#### `Interface` - 추상화의 꽃

인터페이스에는 메소드를 기술할 때, 선언부만 기술하고 구현부는 기술하지 않는다.

`implements`를 통해 인터페이스를 구현할 때는 인터페이스 내부에 있는 추상 메소드들을 **반드시 구현**해야 한다.



+`default method`

`java 8` 버전부터 `default method`라는 `body` 를 가진 메소드를 인터페이스에 추가할 수 있게 되었다.



#### `추상 클래스`

추상 클래스는 추산 메소드를 가지고, 스스로 객체를 생성할 수 없다. `abstract keword`를 클래스 앞에 명시해서 표시한다.



#### `instanceof`

현재 `Reference`되고 있는 객체가 상속 관계에 있어서 어떤 객체인지 명시해주는 연산자.



#### `inner class - local`

클래스 내부에서 다시 정의되는 클래스. 바깥 클래스의 일부처럼 사용한다.

다른 클래스에서 사용하지 않고 바깥 클래스에서만 의미가 있을 경우 사용한다. 별도의 객체가 만들어 진다.



#### `inner class - anonymous`

클래스 내부에서 이름없이 만들어지는 `inner class`이다.

이름이 없기 때문에 재사용되지 않고 한 번만 사용된다. 즉, 객체를 생성하는 코드에 바로 클래스의 내용을 전달한다. 주로 `Event Handling`처럼 인터페이스에 정의된 메소드의 구현부를 개체 생성 시점에 전달한다.



#### `inner class - static`

클래스 내부에서 다시 정의되는 클래스이다. 다른 클래스에서 사용하지 않고 바깥 클래스에서만 의미가 있을 경우 많이 사용된다. 별도의 객체가 만들어지지 않는다.