이번 장에서는 메서드를 설계할 때 주의할 점들을 공부해봅시다. 아마 그나마 제일 내용이 와닿는 장이 되지 않을까 싶습니다. 제발 그러면 좋겠네요. 매개변수와 반환값을 어떻게 처리해야 하는지, 메서드 시그니처는 어떻게 설계해야 하는지, 문서화는 어떻게 해야 하는지 등등을 정리해보겠습니다. 이번에 공부하는 내용 중 상당수가 메서드뿐만 아니라 생성자에도 적용된다고 하니 꼼꼼히 공부해야겠습니다. 시작~~~



## 아이템 49. 매개변수가 유효한지 검사하라

메서드 몸체가 실행되기 전에 매개변수를 확인하면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있습니다. 매개변수 검사를 제대로 하지 않는다면 여러 문제가 생길 수 있습니다. 첫 번째로, 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있습니다. 더 나쁜 상황은 메서드가 잘 수행되지만 잘못된 결과를 반환할 때고요, 더 더 나쁜 상황은 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 나중에 이 메서드와 상관없는 오류를 발생시키는 경우입니다. 즉, 매개변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳을 수 있습니다.



`public`과 `protected` 메서드는 매개변수 값이 잘못되었을 때 던지는 예외를 문서화해야 합니다(`@throws` 자바독 태그써서.. 다음 장에서 공부합쉬다). 매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 합니다. 이런 간단한 방법으로 API 사용자가 제약을 지킬 가능성을 크게 높힐 수 있습니다. 다음은 `BigInteger` 클래스의 `mod()` 메서드입니다.



``` java
    /**
     * Returns a BigInteger whose value is {@code (this mod m}).  This method
     * differs from {@code remainder} in that it always returns a
     * <i>non-negative</i> BigInteger.
     *
     * @param  m the modulus.
     * @return {@code this mod m}
     * @throws ArithmeticException {@code m} &le; 0
     * @see    #remainder
     */
    public BigInteger mod(BigInteger m) {
        if (m.signum <= 0)
            throw new ArithmeticException("BigInteger: modulus not positive");

        BigInteger result = this.remainder(m);
        return (result.signum >= 0 ? result : result.add(m));
    }
```



제 노트북에 설치된건 adoptopenjdk 1.8 인데 책이랑 쪼끔 다르네요. 암츤 이 메서드에서는 만약 `m` 이 `null` 이라면 `m.signum` 이 부분에서 `NullPointerException` 을 던집니다. 근데 "m이 null일 때 `NPE` 를 던진다"라는 명시가 메서드 설명에 없습니다. 왜냐면 이 설명을 메서드에서가 아닌 `BigInteger` 클래스 수준에서 기술했기 때문입니다. 클래수 수준 주석은 그 클래스의 모든 `public`  메서드에 적용됩니다. 이 부분일까요 잘 모르겠습니다 사실 ㅎ;;

```java
 * <p>All methods and constructors in this class throw
 * {@code NullPointerException} when passed
 * a null object reference for any input parameter.
```

참고로 자바 7에 추가된 `java.util.Objects.requireNonNull` 메서드를 사용하면 더 이상 `null` 검사를 수동으로 하지 않아도 됩니다. 얘는 이렇게 선언되어 있습니다.

``` java
    public static <T> T requireNonNull(T obj, String message) {
        if (obj == null)
            throw new NullPointerException(message);
        return obj;
    }
```



입력을 그대로 반환하기 때문에 값을 사용하는 동시에 `null` 검사도 수행할 수 있는 것이죠. 이렇게 쓰면 됩니다.

``` java
this.strategy = Objects.requireNonNull(strategy, "전략");
```

반환값은 무시하고 그냥 오로지 `null` 검사 목적으로 써도 상관없습니다.



공개되지 않은 메서드라면 패키지 제작자인 우리가 직접 메서드가 호출되는 상황을 통제할 수 있습니다. 따라서 유효한 값만이 메서드에 넘겨지는 것을 보장해야 합니다. `public` 이 아닌 메서드라면, 단언문(`assert`) 을 사용해서 매개변수 유효성을 검증할 수 있습니다. 단언문은 자바 4부터 지원하는 예약어 입니다. 다음 예를 봅시다



``` java
private static void sort(long a[], int offset, int length) {
  assert a != null;
  assert offset >= 0 && offset <= a.length;
  assert length >= 0 && length <= a.length - offset;
}
```

단언문은 몇 가지 측면에서 일반적인 유효성 검사와 다릅니다. 먼저, 실패하면 `AssertionError` 를 던집니다. 두 번째로, 런타임에 아무런 효과도, 아무런 성능 저하도 없습니다. 자세한건 따로 정리해보겠습니다.



메서드가 직접 사용하진 않지만 나중에 쓰기 위해 저장해놓는 매개변수는 특히 더 신경써서 체크해야 합니다. 그렇지 않다면 그 매개변수를 써먹을 때가 되어서야 `NPE` 같은게 튀어나오니깐 얘가 어디서 온건지, 어디서 잘못된건지 추적하기 어려워져 디버깅이 상당히 골치아파 질 수 있습니다. 생성자가 이러한 원칙의 특수한 사례가 될 수 있습니다. 생성자 매개변수의 유효성 검사는 당장 그 매개변수를 사용하진 않지만, 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 필수입니다.

