드디어 대망의 마지막 장입니다. 객체 직렬화에 대해 배워봅시다. 객체 직렬화는 자바가 객체를 바이트 스트림으로 인코딩(직렬화)하고 그 바이트 스트림으로부터 다시 객체를 재구성(역직렬화)하는 매커니즘입니다. 직렬화의 위험성과 그 위험을 최소화하는 방법에 대해 알아보겠습니다.



## 아이템 85. 자바 직렬화의 대안을 찾으라

시작하자마자 대안을 찾으랩니다. 도입 초기에 논의된 취약점들 때문에 몇년 전에는 랜섬웨어 공격을 받는 사건도 있었댑니다; 이번 장 정리 끝내고 싶네용.

직렬화의 근본적인 문제는 공격 범위가 너무 넓고 점점 더 넓어져 방어하기 어렵다는 점입니다. 직렬화된 파일을 읽어들이는 `ObjectInputStream` 의 `readObject` 메서드를 호출하면서 객체 그래프가 역직렬화되기 때문입니다. `readObject` 메서드는 `Serializable` 인터페이스를 구현했다면 classpath 안의 거의 모든 타입의 객체를 만들어 줍니다. 바이트 스트림을 역직렬화하는 과정에서 이 메서드는 그 타입들 안의 모든 코드를 수행할 수 있는데, 그 타입들의 코드 전체가 공격 범위에 들어간단 의미가 됩니다.

자바 라이브러리와 많이 쓰이는 써드파티 라이브러리에서 직렬화 가능 타입들 중에서 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드를 가젯(gadget) 이라고 합니다. 그래서 아주 신중하게 제작한 바이트 스트림만 역직렬화해야 합니다.

역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있습니다. 이런 스트림을 역직렬화 폭탄(deserialization bomb) 이라고 합니다.

요런 문제들에 대처하는 방법은 간단합니다. 애초에 신뢰할 수 없는 바이트 스트림을 역직렬화하는 것 자체가 스스로를 공격에 노출하는 행위이기 때문에 **직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것입니다.** 우리가 작성하는 새로운 시스템에 자바 직렬화를 써야 할 이유가 전혀 없습니다. 객체와 바이트 시퀀스를 변환해주는 다른 매커니즘이 많기 때문이죠. 이러한 매커니즘의 공통점은 자바 직렬화보다 훨씬 간단하다는 것입니다. 임의의 객체 그래프를 자동으로 직렬화/역직렬화 하지 않고 속성-값 쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체를 사용합니다. 대표적인 예로는 JSON이 있겠네요!! 그리고 책에서는 프로토콜 버퍼(Protocol Buffers, protobuf)도 소개하고 있습니다. 둘 다 언어 중립적이라고는 하지만, 사실 JSON은 자바크스립트, 프로토콜 버퍼는 C++ 용으로 만들어졌습니다.

둘의 차이에 대해서 간단히 적어보자면, JSON은 텍스트 기반이라 사람이 읽을 수 있고, 프로토콜 버퍼는 이진 표현이라 효율이 훨씬 높습니다. 또한 JSON은 데이터를 표현하는 데만 쓰이지만, 프로토콜 버퍼는 문서를 위한 스키마를 제공하고 올바로 쓰도록 강제합니다.

레거시 시스템 때문에 자바 직렬화를 완전히 배제할 수 없는 경우, 차선책으로 **신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것** 입니다. 만약 직렬화를 피할 수도 없고 역직렬화한 데이터가 안전한지 확신도 할 수 없는 상황이라면 객체 역직렬화 필터링(`java.io.ObjectInputFilter`) 을 사용합시다. 이건 데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능입니다. 클래스 단위로 특정 클래스를 받아들이거나 거부할 수 있습니다. '기본 수용' 모드에서는 블랙리스트에 기록된 클래스들을 거부하고, '기본 거부' 모드에서는 화이트리스트에 기록된 클래스들만 수용합니다. **블랙리스트 방식보다는 화이트리스트 방식을 추천**하 합니다. 블랙리스트 방식은 이미 알려진 위험으로부터만 보호할 수 있기 때문이죠.



## 아이템 86. Serializable을 구현할지는 신중히 결정하라

어떤 클래스의 인스턴스를 직렬화할 수 있게 하려면 `Serializable` 인터페이스를 구현하면 됩니다. 정말 단순하죠? 하지만 직렬화를 지원하는 것은 짧게 보면 쉬워 보이지만, 길게 보면 아주 값비싼 일입니다.

**`Serializable` 을 구현하면 릴리스한 뒤에는 수정하기 어렵습니다**. 클래스가 `Serializable` 을 구현하면 직렬화된 바이트 스트림 인코딩(직렬화 형태)도 하나의 공개 API가 됩니다. 따라서 이 클래스가 널리 퍼진다면 그 직렬화 형태도 영원히 지원해주어야 하는 것입니다. 만약 뒤늦게 클래스 내부 구현을 고친다면 원래의 직렬화 형태도 달라 질 것입니다. 그럼 어느 한 쪽에서는 옛날 버전 인스턴스를 직렬화하고.. 다른 쪽에서는 새로운 클래스로 역직렬화하고...난리 납니다. `ObjectOutputStream.putFields` 와 `ObjectInputStream.readFields` 를 사용하면 원래의 직렬화 형태를 유지하면서 내부 표현을 바꿀 수 있지만, 어렵기도 할 뿐더러 소스코드에 지저분한 혹을 남기게 됩니다. 그러니 직렬화 가능 클래스를 만들고자 한다면, 길게 보고 감당할 수 있을 만큼 고품질의 직렬화 형태도 주의해서 함께 설계해야 합니다.



`Serializable` 구현의 두 번째 문제는 버그와 보안 구멍이 생길 위험이 높아진다는 점입니다. 객체는 생성자를 사용해 만드는 것이 기본이죠. 즉, 직렬화는 언어의 기본 메커니즘을 우회하는 객체 생성 기법인 것입니다. 고로 역직렬화는 '숨은 생성자' 입니다. 이 생성자는 전면에 드러나지 않으므로 기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다는 의미가 됩니다.

세 번째 문제는 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다는 점입니다. 직렬화 가능한 클래스가 수정되면 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화할 수 있는지, 그리고 그 반대도 가능한지 검사해야 합니다.



## 아이템 87. 커스텀 직렬화 형태를 고려해보라

괜찮다고 판단될 때만 기본 직렬화 형태를 사용합시다. 기본 직렬화 형태는 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해야 합니다. 자바의 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만 사용하고, 그렇지 않으면 객체를 적절히 설명하는 커스텀 직렬화 형태를 고려해봅시다.

우선 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태를 사용해도 괜찮습니다. 아래 코드처럼 성명을 간단히 표현한 클래스는 기본 직렬화 형태를 써도 괜찮을 겁니다.

```java
public class Name implements Serializable {
    /**
     * 성. null이 아니어야 한다.
     * @serial
     */
    private final Stirng lastName;

    /**
     * 이름. null이 아니어야 한다.
     * @serial
     */
    private final String firstName;

    /**
     * 중간이름. 중간이름이 없다면 null
     * @serial
     */
    private final String middleName;

    ... // 나머지 코드는 생략
}
```



**기본 직렬화 형태가 적합하다고 결정했더라도 불변식 보장과 보안을 위해 `readObject` 메서드를 제공해야 할 때가 많습니다.** 앞의 `Name` 클래스는 `readObject` 메서드가 `lastName` 과 `firstName` 필드가 `null` 이 아님을 보장해야 합니다. 자세한 얘기는 다음 아이템에서..



그럼 이제 기본 직렬화 형태가 적합하지 않은 예를 봅시다. 문자열 리스트를 표현하는 클래스입니다.

``` java
public final class StringList implements Serializable {
    private int size = 0;
    private Entry head = null;

    private static class Entry implements Serializable {
        String data;
        Entry next;
        Entry previous;
    }
    // ... 생략
}
```

논리적으로 이 클래스는 일련의 문자열을 표현합니다. 그리고 물리적으로는 문자열들을 이중 연결 리스트로 연결했구요. 이 클래스에 기본 직렬화 형태를 사용한다면 각 노도의 양방향 연결 정보를 포함해 모든 엔트리(`Entry`) 를 기록합니다.



객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 크게 네 가지 측면에서 문제가 생깁니다.

1. 공개 API 가 현재의 내부 표현 방식에 영구히 묶입니다.
2. 너무 많은 공간을 차지할 수도 있습니다.
3. 시간이 너무 많이 걸릴 수 있습니다.
4. 스택 오버플로우를 일으킬 수 있습니다.



그럼 `StringList` 에 가장 적합한 직렬화 형태는 무엇일까요? 단순히 리스트가 포함한 문자열의 개수를 적고, 그 뒤로 문자열들을 나열하는 수준이면 될 것 같습니다. 다음은 `StringList` 를 이러한 방식으로 구현한 모습입니다. `writeObject` 와 `readObject` 가 직렬화 형태를 처리합니다. 

``` java
public final class StringList implements Serializable {
    private transient int size = 0;
    private transient Entry head = null;

    // 이번에는 직렬화 하지 않는다.
    private static class Entry {
        String data;
        Entry next;
        Entry previous;
    }

    // 문자열을 리스트에 추가한다.
    public final void add(String s) { ... }

    /**
     * StringList 인스턴스를 직렬화한다.
     */
    private void writeObject(ObjectOutputStream stream)
            throws IOException {
        stream.defaultWriteObject();
        stream.writeInt(size);

        // 모든 원소를 순서대로 기록한다.
        for (Entry e = head; e != null; e = e.next) {
            s.writeObject(e.data);
        }
    }

    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        int numElements = stream.readInt();

        for (int i = 0; i < numElements; i++) {
            add((String) stream.readObject());
        }
    }
    // ... 생략
}
```



~~transient 부분 추가!~~



 직렬화 형태도 공개 메서드를 설계할 때에 준하는 공을 들여서 설계해야 합니다. 한 번 공개된 메서드는 향후 릴리스에서 제거할 수 없듯이, 직렬화 형태에 포함된 필드도 마음대로 제거할 수 없기 때문입니다. 잘못된 직렬화 형태를 선택하면 해당 클래스의 복잡성과 성능에 영구히 부정적인 영향을 남기게 됩니다.



## 아이템 88. readObject 메서드는 방어적으로 작성하라

**readObject 메서드를 작성할 때는 항상 `public` 생성자를 작성하는 것처럼 작성해야 합니다.** 보통의 생성자처럼 인수가 유효한지 검사해야 하고, 필요하다면 매개변수를 방어적으로 복사해야 합니다. `readObject` 가 이 작업을 제대로 수행하지 않았을 경우, 공격자는 아주 손쉽게 해당 클래스의 불변식을 깨뜨릴 수 있기 때문입니다.

즉,  `readObject` 메서드는 매개변수로 바이트 스트림을 받는 생성자라고 할 수 있는데, 어떤 바이트 스트림이 넘어오더라도 유효한 인스턴스를 만들어내야 합니다. 그렇지 않다면 보안 상 여러 큰 문제가 발생할 수 있습니다. 객체를 역직렬화 할 때는 클라이언트가 소유해서는 안되는 객체 참조를 갖는 필드를 반드시 모두 방어적으로 복사해야 합니다.

다음은 안전한 `readObject` 메서드를 작성하는 팁 입니다.

- `private` 이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사합시다.
- 모든 불변식을 검사해서 어긋나는 게 발견되면 `InvalidObjectException` 을 던집시다. 방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 합니다.
- 역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 `ObjectInputValidation` 인터페이스를 사용합시다.
- 직/간접적으로 재정의할 수 있는 메서드는 호출하지 맙시다.



## 아이템 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라

이번 장 내내 `Serializable` 을 구현하기로 한 순간 정상적인 생성자 이외의 방법으로 인스턴스를 생성할 수 있게 된 것이라고 얘기했습니다. 버그와 보안 문제가 일어날 가능성이 커진다는 의미인데, 이러한 위험을 줄여줄 기법이 있습니다. 바로 직렬화 프록시 패턴(serialization proxy pattern) 입니다.

직렬화 프록시 패턴은 우선 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 설계해 `private static` 으로 선언합니다. 이 중첩 클래스가 바로 바깥 클래스의 직렬화 프록시입니다. 중첩 클래스의 생성자는 단 하나여야 하며, 바깥 클래스를 매개변수로 받아야 합니다. 이 생성자는 단순히 인수로 넘어온 인스턴스의 데이터를 복사합니다. 설계상으로 직렬화 프록시의 기본 직렬화 형태는 바깥 클래스의 직렬화 형태로 쓰기 이상적입니다. 그리고 바깥 클래스와 직렬화 프록시 모두 `Serializable` 을 구현한다고 선언해야 합니다.

직렬화 프록시 패턴에는 한계가 두 가지 있습니다. 첫 번째로, 클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없습니다. 두 번째로는 객체 그래프에 순환이 있는 클래스에도 적용할 수 없습니다.







##### 정리하지 않은 아이템

아이템 89. 인스턴스 수를 통제해야 한다면 readResolve 보다는 열거 타입을 사용하라



