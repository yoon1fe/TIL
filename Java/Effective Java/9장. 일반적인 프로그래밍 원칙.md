9장에서는 자바 언어 자체의 핵심 요소에 대해 공부합니다. 지역변수, 제어 구조, 라이브러리, 테이터 타입, 그리고 리플렉션, 네이티브 메서드, 최적화와 명명 규치까지 공부해봅시다. 아이템이 정말 많네요 ^^;; 올림픽 봐야되는데 휴

이번 장은 아이템이 많긴 하지만 아이템들이 대개 호흡이 짧아서 한 글에 담겠습니다~!~!



## 아이템 57. 지역변수의 범위를 최소화하라

"클래스와 멤버의 접근 권한을 최소화하라"는 아이템 15와 일맥상통합니다. 지역변수의 유효 범위를 최소화하면 코드 가독성과 유지보수성이 좋아지고 오류 가능성이 낮아집니다. 

지역변수의 범위를 줄이는 가장 강력한 방법은 **가장 처음 승리 때 선언하기** 입니다. 미리 선언부터 해놓으면 코드가 어수선해져 가독성이 나빠집니다. 변수를 실제로 사용하는 시점에서 데이터 타입이나 초깃값이 뭔기 헷갈리기도 쉽습니다.

거의 모든 지역변수는 선언과 동시에 초기화해야 합니다. 초기화에 필요한 정보가 충분치 않다면 충분해질 때까지 선언을 미루는 것이 좋습니다. 단, `try-catch` 문은 이 규칙에서 예외입니다. 변수를 초기화하는 표현식에서 검사 예외를 던질 가능성이 있다면 `try` 블록 안에서 초기화해야 합니다. 그렇지 않으면 예외가 블록을 넘어서 메서드에까지 전파됩니다. 변수 값을 `try` 블록 바깥에서도 사용해야 한다면, 정확히 초기화하진 못하더라도 `try` 블록 앞에서 선언해야 합니다. 이런 식으로요.

``` java
	Class<? extends Set<String>> cl = null;
	try {
        cl = (Class<? extends Set<String>>) 
            Class.forName(args[0]);
    }
```



반복문은 독특한 방식으로 변수 범위를 최소화해줍니다. 예전의 `for` 형태든 새로운 `for-each` 형태든, 반복문에서는 반복 변수의 범위가 반복문의 몸체, 그리고 `for` 키워드와 몸체 사이의 괄호 안으로 제한됩니다. 따라서, 반복 변수의 값을 반복문이 종료된 뒤에도 써야하는 상황이 아니면 `while` 문보다는 `for` 문을 쓰는 것이 낫습니다.



단순히 컬렉션을 순회할 때는 `for-each` 문(`enhanced for` 문)을 권장합니다. 

``` java
for (Element e : c) {
    // e로 무언가를 한다.
}
```

여기서 `e`는 조회만 가능하고, 값을 변경하는 것은 불가능합니다.



반복자를 사용해야 하는 상황이라면 `for-each` 문 대신 전통적인 `for` 문을 쓰는 것이 낫습니다.

``` java
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    ... // e와 i로 무언가를 한다.
}
```



다음 두 `while` 문을 보면 앞의 `for` 문이 더 나은 이유를 알 수 있습니다. 다음 코드에는 버그도 하나 숨어 있습니다.

``` java
Iterator<Element> i = c.iterator();
while (i.hasNext()) {
  doSomething(i.next());
}
...

Iterator<Element> i2 = c2.iterator();
while (i.hasNext()) {				// 버그
  doSomething(i2.next());
}

```

비슷한 코드라 복붙했는데, 새로운 반복 변수 `i2` 를 초기화했지만 실수로 이전 `while` 문에서 쓴 `i` 를 다시 쓴 것입니다. 불행히도 `i` 의 유효 범위가 아직 끝나지 않았기 때문에 이 코드는 컴파일도 되고 실행 시 예외도 던지지 않게 됩니다. 이렇게 프로그램 오류가 겉으로 드러나지 않게 되니 오랜 기간 발견되지 않을 수도 있습니다.

`for` 문을 사용하면 이런 오류를 컴파일 타임에 잡아줍니다. 반복 변수의 유효범위가 반복문 종료와 함께 끝나기 때문입니다. 추가로, 반복 변수 (주로 `i`) 를 계속해서 써도 되는 장점도 있지요. 



지역변수 범위를 최소화하는 마지막 방법은 **메서드를 작게 유지하고 한 가지 기능에 집중하는 것**입니다. 한 메서드에서 여러 기능을 처리한다면 그 중 한 기능하고만 관련된 지역변수라도 다른 기능을 수행하는 코드에서 접근할 수 있을 것입니다. 해결책은 단순히 메서드를 기능별로 쪼개면 됩니다~!



## 아이템 58. 전통적인 for문보다는 for-each 문을 사용하라

전통적인 `for` 문에서의 반복자와 인덱스 변수는 사실 우리가 진짜로 필요한 친구들은 아닙니다. 우리한테 진짜 필요한건 원소들이죠. 그리고 순회하려는 애가 컬렉션이냐 배열이냐에 따라 코드 형태도 달라집니다.

이러한 문제는 `for-each` 문을 사용하면 모두 해결됩니다. 참고로 전 아이템에서 언급했듯이 얘의 정식 이름은 향상된 `for` 문(enhanced for statement) 입니다. `for-each` 문은 반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일도 없습니다. 컬렉션이든 배열이든 같은 형태로 사용하면 됩니다.

``` java
for (Element e : elments) {
  doSomething(e);
}
```



하지만 `for-each` 문을 사용할 수 없는 세가지 상황이 존재합니다.

첫 번째로, **파괴적인 필터링(dstructive filtering)**이 있습니다. 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 `remove()` 메서드를 호출해야 합니다. 자바 8부터는 `Collection` 의 `removeIf` 메서드를 이용해서 컬렉션을 명시적으로 순회하는 일을 피할 수 있습니다.

두 번째, **변형(transforming)** 입니다. 리스트나 배열을 순회하면서 그 원소의 값을 변경해야 한다면 반복자나 인덱스를 사용해야 합니다. 위에서 말했듯, `e` 는 read-only 랍니다.

마지막으로, **병렬 반복(parallel iteration)** 입니다. 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 합니다. 



## 아이템 59. 라이브러리를 익히고 사용하라

이건 뭐.. 당연한 얘깁니다 ^^; 우리보다 훨씬 더 똑똑하고 멋진 아저씨들이 우리보다 훨씬 오랫동안 고민하고 또 고민해서 만들어 놓은 라이브러리를 잘 활용합시다~! 표준 라이브러리를 사용하면 많은 이점이 있습니다. 먼저, 그 코드를 작성한 전문가의 지식과 경험을 우리가 활용할 수 있습니다. 

두 번째 이점은 핵심적인 일(비즈니스 로직)과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다는 점입니다. 근데 라이브러리를 익히는데 필요한 시간은 어떡하죠??? ㅜ

세 번째 이점은 따로 노력하지 않아도 성능이 지속해서 개선된다는 점입니다. 이건 확실히 좋은 것 같네요. 계속해서 더 나은 방법을 꾸준히 개발하겠지요. 화이팅!!

네 번째 이점은 기능이 점점 많아진다는 점입니다. 당장 라이브러리에 부족한 부분이나 기능이 있다면 개발자 커뮤니티에서 이야기가 나올테고, 그럼 다음 릴리즈때 해당 기능이 추가될 수도 있겠져.

마지막 이점은 우리가 작성한 코드가 많은 사람에게 낯익은 코드가 된다는 것입니다. 자연스럽게 다른 개발자가 읽기 더 좋고, 유지보수하기 좋고, 재활용하기 쉬운 코드가 될 겁니다.



이점이 이렇게나 많지만.. 아마 라이브러리에 그런 기능이 있는지 모르고 우리가 직접 짜는 경우도 많을겁니다. 라이브러리가 너무 방대해서 사실상 모든 API 문서를 공부하기엔 벅차겠지만, 자바 프로그래머라면 적어도 `java.lang`, `java.util`, `java.io` 패키지 정도는 익숙해질 필요가 있댑니다. 공부해야겠네요. 호호



## 아이템 60. 정확한 답이 필요하다면 float와 double은 피하라

`float` 와 `double` 은 과학/공학 계산용으로 설계되었다고 합니다. 이진 부동소수점 연산에 쓰이고, 넓은 범위의 수를 빠르게 정밀한 근사치로 계산하도록 세심하게 설계되었습니다. 따라서 정확한 결과가 필요한 때는 사용하면 안 됩니다. **`float`와 `double` 타입은 특히 금융 관련 계산과는 맞지 않습니다.** 0.1 혹은 10의 음의 거듭 제곱 수를 표현할 수 없기 때문입니다.

그럼 뭘 써야 할까요? `BigDecimal`, `int`, 혹은 `long` 을 사용하면 됩니다. 하지만 `BigDecimal` 에는 단점이 두 가지 있습니다. 기본 타입보다 쓰기가 훨씬 불편하고, 느립니다. 단발성 계산이라면 느린 문제는 무시할 수 있겠네요. `BigDecimal` 의 대안으로 `int`나 `long` 을 쓸 수도 있습니다. 이 경우에는 소수점을 직접 관리해줘야 합니다.



## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

자바의 데이터 타입은 크게 두 가지로 나뉘죠. 기본 타입(primitive type)과 참조 타입(reference type) 입니다. 그리고 각각의 기본 타입에는 대응하는 참조 타입이 하나씩 있고, 이를 박싱된 기본 타입(boxed primitive type), 또는 wrapper class 라고 합니다. `int`-`Integer`, `boolean`-`Boolean` 이런 식으로 있죠. 오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수 있지만, 둘 사이에는 분명한 차이가 있으니 어떤 타입을 사용하는지가 상당히 중요합니다. 

기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세 가지입니다. 첫 번째, 기본 타입은 값만 가지고 있지만, 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있습니다. 두 번째, 기본 타입의 값은 언제나 유효하지만, 박싱된 기본 타입은 유효하지 않은 값, 즉 `null` 을 가질 수 있습니다. 세 번째, 기본 타입이 박싱된 기본 타입보다 시간, 메모리 사용면에서 더 효율적입니다. 다음은 `Integer` 값을 오름차순으로 정렬하는 비교자입니다. 아주 단단히 잘못된 코드랍니다.

```java
Comparator<Integer> naturalOrder = 
  (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

겉보기에는 너무 맞는 코드같습니다. 하지만... `naturalOrder.compare(new Integer(42), new Integer(42));` 의 값을 출력해보면 0을 출력해야 하지만, 실제로는 1을 출력합니다.

그 이유는 `i == j` 에 있습니다. 위에서 말했듯 새로운 인스턴스로 만들었기 때문에 두 인스턴스가 다르다고 식별되기 때문입니다. 이처럼 같은 객체를 비교하는 것이 아니라면 **박싱된 기본 타입에 == 연산자를 사용하면 오류가 발생합니다.** 이러한 문제는 기본 타입으로 비교함으로써 해결할 수 있습니다.

``` java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
  int i = iBoxed, j = jBoxed;
  (i < j) ? -1 : (i == j ? 0 : 1);
};
```



 두 번째 문제는, 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면(`Integer` 와 숫자를 바로 비교하면) 언박싱이 이루어지고, **언박싱 과정에서 `null` 참조를 언박싱하면`NullPointerException` 을 던집니다.** 



그럼 박싱된 기본 타입은 언제 써야 할까요? 첫 번째, 컬렉션의 원소, 키, 값으로 씁니다. 컬렉션은 기본 타입을 담을 수 없기 때문이죠. 더 일반화해서 말하면, 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 합니다. 자바 언어 자체가 타입 매개변수로 기본 타입을 지원하지 않기 때문입니다. 마지막으로, 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 합니다.



## 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라

이번 아이템에서는 문자열을 쓰지 않아야 하는 사례를 알아봅시다. 

**문자열은 다른 값 타입을 대신하기에 적합하지 않습니다.** 파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 문자열을 많이 쓰는데, 입력받을 데이터가 진짜 문자열일 때만 그렇게 하는 것이 좋습니다. 받은 데이터가 수치형이라면 `int`, `float`, `BigInteger` 등 적당한 수치 타입으로 변환하는 것이 좋습니다. '예/아니오' 에 대한 답이라면 적당한 열거 타입이나 `boolean` 타입으로 변환해야 합니다. 



문자열을 잘못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성도 큽니다. 기본 타입, 열거 타입 등과 같은 경우 문자열 사용을 지양합시다!



## 아이템 63. 문자열 연결은 느리니 주의하자

문자열 연결 연산자(+)로 문자열 n개를 잇는 시간은 n^2에 비례한다고 합니다. 따라서 `String` 대신 `StringBuilder` 의 `append()` 메서드를 사용합시다.

근데 예전에 어디서 봤는데 언제부턴가 + 연산자가 컴파일될 때 `StringBuilder`로 변환된다고 들었는데.. 한 번 찾아봐야겠네요 ㅎㅎ;



## 아이템 64. 객체는 인터페이스를 사용해 참조하라

아이템 51에서 "매개변수 타입으로 클래스가 아니라 인터페이스를 사용하라"는 조언의 확장판입니다. **적합한 인터페이스가 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하는 것**이 좋습니다. 객체의 실제 클래스를 사용해야 하는 상황은 **오직!** 생성자로 생성하는 경우!!

``` java
// 굿
Set<Son> sonSet = new LinkedHashSet<>();

// 으
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```



**인터페이스를 타입으로 사용하는 습고나을 길러두면 프로그램이 훨씬 유연해질 수 있습니다.** 나중에 구현 클래스를 교체하려면 새 클래스의 생성자(혹은 다른 정적 팩토리)를 호출해주기만 하면 됩니다. 위의 코드에선 `Set<Son> sonSet = new HashSet<>();` 이렇게 쉽게 고칠 수 있겠죠. 

구현 타입을 바꾸는 이유는 무엇이 있을까요? 원래 것보다 더 좋은 성능을 내거나 신기능을 제공하기 때문일 수 있습니다. `HashMap` 을 참조하던 변수가 있다고 했을 때, 얘를 `EnumMap`으로 바꾸면 속도가 빨라지고 순회 순서도 키의 순서와 같아집니다. 키 타입과 상관없이 사용할 수 있는 `LinkedHashMap` 으로 바꾸면 성능은 비슷하게 유지하면서 순회 순서를 예측할 수도 있습니다.



적합한 인터페이스가 없다면 당연히 클래스로 참조해야 합니다. 먼저, `String` 과 `BigInteger` 와 같은 값 클래스가 그렇습니다. 두 번째로는 클래스 기반으로 작성된 프레임워크가 제공하는 객체들입니다. 이런 경우라도 특정 구현 클래스보다는 보통 추상 클래스인 기반 클래스를 사용해서 참조하는 것이 좋습니다. 예로는 `OutputStream` 등 `java.io` 패키지에 속한 클래스들이 있습니다. 마지막으로는 인터페이스에는 없는 특별한 메서드를 제공하는 클래스들입니다. `PriorityQueue` 클래스는 `Queue` 인터페이스에는 없는 `comparator` 메서드를 제공합니다. 

구현할 적당한 인터페이스가 없다면 클래스의 계층 구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용합시다!



## 아이템 65. 리플렉션보다는 인터페이스를 사용하라

리플렉션은 이미 로딩이 완료된 클래스에서 **또 다른 클래스를 동적으로 로딩(Dynamic Loading)**하여 생성자, 멤버 필드, 그리고 멤버 메서드 등을 사용할 수 있도록 하는 기능입니다. `Class` 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 `Constructor`, `Method`, `Field` 인스턴스를 가져올 수 있고, 이어서 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등과 같은 정보를 가져올 수 있습니다. 나아가 이 인스턴스들을 이용해 각각에 연결된 실제 생성자, 메서드, 필드를 조작할 수도 있습니다. 예를 들어 `Method.invoke` 는 어떤 클래스의 어떤 객체가 가진 어떠한 메서드라도 호출할 수 있게 해줍니다. 리플렉션을 이용하면 컴파일 시점에 존재하지 않던 클래스도 이용할 수 있는데, 단점이 있습니다.

첫 번째로, **컴파일 타임 타입 검사가 주는 이점을 하나도 누릴 수 없습니다.** 예외 검사도 마찬가지고요. 프로그램이 리플렉션 기능을 써서 존재하지 않거나 접근할 수 없는 메서드를 호출하려고 하면 런타임 오류가 발생합니다.

두 번째, **리플렉션을 이용하면 코드가 지저분하고 장황해집니다.** 

세 번째, **성능이 떨어집니다.** 리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느립니다.



요새 점점 리플렉션 사용이 줄어들고 있다고 합니다. 단점이 명백하기 때문입니다.

리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있습니다. 컴파일 타임에 이용할 수 없는 클래스를 사용해야 하는 프로그램은 비록 컴파일 타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있겠죠. 다행히 이런 경우라면 **리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용합시다.**



~~한 번 더 읽기!!!~~



## 아이템 66. 네이티브 메서드는 신중히 사용하라

자바 네이티브 인터페이스(Java Native Interface, JNI) 는 자바 프로그램이 네이티브 메서드를 호출하는 기술입니다. 네이티브 메서드란 C나 C++같은 네이티브 프로그래밍 언어로 작성된 메서드를 말하지요. JVM 구조를 공부할 때 봤던 기억이 있습니다. 이러한 네이티브 메서드의 주요 쓰임새는 다음 세가지 입니다. 첫 번째, 레지스트리 같은 플랫폼 특화 기능 사용, 두 번째, 네이티브 코드로 작성된 기존 라이브러리 사용, 세 번째, 성능 개선 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성.. 사실 한 번도 건드려 본 적도 없고.. 앞으로도 건드릴 일이 많을지 잘 모르겠습니다. 추가로, 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다고 합니다. 자바 3 이전까지는 모르겠지만, 최근 JVM은 굉장히 발전해서 지금의 자바는 다른 플랫폼에 견줄만한 성능을 보이고 있습니다.

그러니깐 네이티브 메서드를 사용하려거든 한 번 두 번 고민해보고 씁시다~^^



## 아이템 67. 최적화는 신중히 하라

똑똑한 아저씨들이 최적화 하지 말래요.

빠른 프로그램보다는 **좋은** 프로그램을 작성합시다!!



## 아이템 68. 일반적으로 통용되는 명명 규칙을 따르라

자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그 중 많은 것이 자바 언어 명세에 기술되어 있습니다. 자바의 명명 규칙은 크게 철자와 문범, 두 범주로 나뉩니다.

먼저 철자 규칙은 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름을 다룹니다. 이 규칙들은 특별한 이유가 없는 한 반드시 따릅시다. 사실 대부분 체득했을 것 같긴 한데 한 번 살펴보겠습니다.



패키지와 모듈 이름은 각 요소를 점(.)으로 구분하여 계층적으로 짓습니다. 모두 소문자 알파벳 혹은 드물게 숫자로 이뤄지구요. 조직의 인터넷 도메인 이름을 역순으로 사용합니다.

패키지 이름의 나머지는 해당 패키지를 설명하는 하나 이상의 요소로 이루어집니다. 각 요소는 일반적으로 8자 이하로 짧게 씁니다. `utilities` 보다 `util`, 여러 단어로 구성된 이름이라면 `awt` 처럼 앞 글자만 따도 됩니다.



클래스와 인터페이스의 이름은 하나 이상의 단어로 이루어지고, 각 단어는 대문자로 시작합니다. 여러 단어의 첫 글자만 딴 약자나 `max`, `min` 과 같이 널리 쓰이는 줄임말을 제외하고는 단어를 줄여 쓰지 않습니다. 약자의 경우, 첫 글자만 대문자로 할지 전체를 대문자로 할지는 약간 논쟁의 여지가 있습니다. 저는 개인적으로 학부때는 `memberDTO` 처럼 다 대문자로 썼었는데.. 요새 트렌드는 첫 글자만 대문자(`memberDto`)로 쓴다고 합니당. ㅜ 지금 보니 카멜 케이스라 더 이쁜 것 같기도 하네요. 오 책에 좋은 예시가 있습니다. `HttpUrl` vs `HTTPURL`!! 앞으로 얌전히 첫 글자만 대문자로 하겠습니다.



메서드와 필드의 이름은 첫 글자를 소문자로 쓴다는 것만 빼면 클래스 명명 규칙과 같습니다. 단, '상수 필드'는 예외입니다. 상수 필드를 구성하는 단어는 모두 대문자로 쓰며, 단어 사이는 밑줄로 구분합니다(`VALUES`, `NEGATIVE_INFINITY` ).

지역변수에도 다른 멥버와 비슷한 명명 규칙이 적용됩니다. 단, 약어를 써도 괜찮습니다. 그 변수가 사용되는 문맥 차원에서 의미를 쉽게 유추할 수 있기 때문입니다(`i`, `houseNum`).

타입 매개변수는 보통 한 문자로 표현합니다. 임의의 타입(Type) `T`, 컬렉션 원소(Element)의 타입 `E`, 맵의 키(Key)와 값(Value)에는 각각 `K`, `V`, 예외(eXception)에는 `X`, 메서드 반환(Return) 타입에는 `R` 을 사용합니다.



문법 규칙은 철자 규칙과 비교하면 더 유연하고 그렇기 때문에 논란도 많습니다. 객체를 생성할 수 있는 클래스(열거 타입 포함)의 이름은 보통 단수 명사나 명사구를 사용합니다(`Thread`, `PriorityQueue`). 객체를 생성할 수 없는 클래스는 보통 복수형 명사로 짓습니다(`Collectors`, `Collections`). 인터페이스 이름은 클래스와 똑같이 짓거나(`Collection`, `Comparator`), `able` 혹은 `ible` 로 끝나는 형용사로 짓습니다(`Runnable`, `Iterable`, `Accessible`).

어떤 동작을 수행하는 메서드의 이름은 동사나 목적어를 포함한 동사구로 짓습니다(`append`, `drawImage`). `boolean` 값을 반환하는 메서드는 보통 `is`나 `has` 로 시작하고 명사나 명사구, 혹은 형용사로 기능하는 아무 단어나 구로 끝나도록 짓습니다(`isDigit`, `isEmpty`, `hasSiblings`).

반환 타입이 `boolean` 이 아니거나 해당 인스턴스의 속성을 반환하는 메서드는 보통 명사, 명사구, 혹은 `get` 으로 시작하는 동사구로 짓습니다.(`size`, `hashCode`, `getTime`). 



알아둬야 할 특별한 메서드 이름이 몇 가지 있습니다. 객체의 타입을 바꿔서 다른 타입의 또 다른 객체를 반환하는 인스턴스 메서드의 이름은 보통 `toType` 형태를 가집니다(`toArray`, `toString`). 객체의 내용을 다른 뷰로 보여주는 메서드는 `asType` 형태로 짓습니다(`asList`). 객체의 값을 기본 타입 값으로 반환하는 메서드는 보통 `typeValue` 형태를 가집니다(`intValue`). 마지막으로, 정적 팩토리의 이름은 다양하지만 `from`, `of`, `valueOf`, `instance`, `getInstance`, `newInstance`, `getType`, `newType` 을 자주 씁니다.

