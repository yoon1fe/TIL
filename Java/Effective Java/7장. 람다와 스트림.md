자바 8부터는 함수형 인터페이스, 람다, 메서드 참조라는 개념이 추가되면서 함수 객체를 더 쉽게 만들 수 있게 되었습니다. 추가로 스트림 API까지 추가되면서 데이터 원소의 시퀀스 처리를 라이브러리가 지원해주게 되었죠. 이번 장에서는 람다와 스트림에 대해서 공부해봅시다!!!



## 아이템 42. 익명 클래스보다는 람다를 사용하라

예전에는 함수 타입을 표현할 때 추상 메서드를 하나만 담은 인터페이스를 사용했습니다. 이런 인터페이스의 인스턴스를 함수 객체(function object)라고 하고, 특정 함수나 동작을 나타내는 데 사용했습니다. 다음 예시를 보면 문자열을 길이순으로 정렬할 때 정렬을 위한 비교 함수로 익명 클래스를 사용합니다.

``` java
Collections.sort(words, new Comparator<String>() {
  public int compare(String s1, String s2) {
    return Integer.compare(s1.length(), s2.length());
  }
});
```

`Comparator` 인터페이스가 정렬을 담당하는 추상 전략을 의미하고, 문자열을 정렬하는 구체적인 전략을 익명 클래스로 구현한 것입니다. 하지만 익명 클래스 방식은 코드가 너무 길기 때문에, 자바는 함수형 프로그래밍에 적합하지 않습니다. 

추상 메서드를 하나만 갖고 있는 인터페이스를 함수형 인터페이스라고 한다고 3장에서 얘기했었죠. 자바 8부터는 이러한 **함수형 인터페이스의 인스턴스를 람다식**(lambda expression) 을 사용해서 만들 수 있게 되었답니다. 람다는 함수나 익명 클래스와 개념은 비슷하지만, 코드는 훨씬 간결합니다. 다음은 위의 코드를 람다식으로 바꾼 코드입니다. 

``` java
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

코드를 보면 람다(`Comparator<String>`), 파라미터(`s1`, `s2`, `String`), 그리고 리턴값(`int`) 의 데이터 타입이 따로 명시되어있지 않습니다. 컴파일러가 문맥을 살펴 타입을 추론해줍니다. 상황에 따라 컴파일러가 타입을 결정하지 못하는 경우도 있는데, 그럴 땐 프로그래머가 직접 명시해야 합니다. 타입 추론 규칙은 어마어마어마어마어마하게 복잡하댑니다. 이건 몰라도 되고, **타입을 명시해야만 코드가 더 명확한 경우를 제외하고는, 람다의 모든 매개변수 타입은 생략**하도록 합시다. 컴파일러가 "타입을 알 수 없다"는 오류를 낼 때만 해당 타입을 명시해주면 됩니다.



람다 자리에 비교자 생성 메서드를 사용하면 이 코드를 더욱 더 간결하게 만들 수 있습니다.

``` java
Collections.sort(words, comparingInt(String::length));
```

참고로 저기 있는 콜론 두 개(`::`)는 메서드 참조 표현식(method reference expression) 으로, 람다식에서 파라미터를 중복해서 쓰기 싫을 때 사용하는 연산자입니다. 



더더 나아가 자바 8 때 `List` 인터페이스에 추가된 `sort` 메서드를 이용하면 더욱 짧아집니다.

``` java
words.sort(comparingInt(String::length));
```



람다를 언어 차원에서 지원하면서 기존에는 적합하지 않았던 곳에서도 함수 객체를 실용적으로 사용할 수 있게 되었습니다. 아이템 34 의 `Operation` 열거 타입을 예로 들어봅시다. 

``` java
public enum Operation {
  PLUS("+") {public double apply(double x, double y) {return x + y;}},
  MINUS("-") {public double apply(double x, double y) {return x - y;}},
  TIMES("*") {public double apply(double x, double y) {return x * y;}},
  DIVIDE("/") {public double apply(double x, double y) {return x / y;}};
  
  private final String symbol;
  
  Operation(String symbol) { this.symbol = symbol; }
  @Override public String toString() { return symbol; }
  public abstract double apply(double x, double y);
}
```

단순히 각 열거 타입 상수의 동작을 람다로 구현해 생성자에 넘기고, 생성자는 이 람다를 인스턴스 필드로 저장해둡니다. 그런 다음 `apply` 메서드에서 필드에 저장된 람다를 호출하기만 하면 됩니다. 이렇게 구현하면 이전 버전보다 훨씬 깔끔해집니다.

``` java
public enum Operation {
  PLUS("+"(x, y) -> x + y),
  MINUS("-"(x, y) -> x - y),
  TIMES("*"(x, y) -> x * y),
  DIVIDE("/"(x, y) -> x / y);
  
  private final String symbol;
  private final DoubleBinaryOperator op;
  
  Operation(String symbol, DoubleBinaryOperator op) {
    this.symbol = symbol; this.op = op;
  }
  @Override public String toString() { return symbol; }
  public double apply(double x, double y) {
    return op.applyAsDouble(x, y);
  }
}
```



이때까지의 코드를 보니 상수별 클래스 몸체는 더 이상 사용할 이유가 없다고 느껴질 수도 있습니다. 하지만 **메서드나 클래스와는 달리 람다는 이름이 없고 문서화도 할 수 없습니다. 그렇기 때문에 코드 자체로 동작이 명확히 설명되지 않거나, 코드 줄 수가 많아지면 람다 사용을 지양**해야 합니다. 람다는 한 줄일 때 가장 좋고, 길어도 세 줄 안에 끝내도록 합시다. 세 줄이 넘어가면 가독성이 심하게 안좋아지니, 더 간단하게 줄이거나 람다를 쓰지 않는 쪽으로 리팩터링하는 것이 좋겠습니다.

그리고, 람다는 자기 자신을 참조할 수 없습니다. 람다에서의 `this` 키워드는 바깥 인스턴스를 가리킵니다. 반면에, 익명 클래스에서의 `this` 는 익명 클래스의 인스턴스 자신을 가리키기 때문에 함수 객체가 자신을 참조해야 하는 경우라면 반드시 익명 클래스를 써야 합니다.



## 아이템 43. 람다보다는 메서드 참조를 사용하라

이때까지 실컷 람다쓰라고 얘기하더니만 이번엔 또 메서드 참조를 사용하랩니다. 그래도 위에서 보니 많이 깔끔해지니 한 번 살펴봅시다..

자바에는 메서드 참조(method reference) 를 통해 함수 객체를 람다보다도 더 간결하게 만들 수 있습니다. 다음 코드는 임의의 키와 `Integer` 값의 매핑을 관리하는 프로그램의 일부분입니다. 이때 캆이 키의 인스턴스 개수로 해석된다면 이 프로그램은 멀티셋을 구현한 것이 되겠죵. 키가 맵 안에 없다면 키와 숫자 1을 매핑하고, 이미 있다면 기존 매핑 값을 증가시키는 코드입니다.

``` java
map.merge(key, 1, (count, incr) -> count + incr);
```



`Map` 인터페이스의 `merge` 메서드는 키, 값, 함수를 파라미터로 받고, 주어진 키가 맵 안에 없다면 {키, 값} 쌍을 그대로 저장하고, 키가 있다면 함수를 현재 값과 주어진 값에 적용한 다음, 그 결과로 현재 값을 덮어씌워줍니다. 

제가 봤을땐 충분히 깔끔해 보이는데 ㅎ 더 깔끔하게 만들 수 있습니다. 파라미터인 `count` 와 `incr` 은 크게 하는 일 없이 공간을 꽤 차지합니다. 사실 위의 람다는 두 인수의 합을 단순히 반환하는 것 말곤 하는게 없죠. 자바 8부터 `Integer` 클래스를 포함한 모든 기본 타입의 박싱 타입은 이 람다와 같은 기능을 하는 정적 메서드 `sum` 을 제공하기 시작했습니다. 따라서 람다 대신 이 메서드의 참조를 전달하면 똑같은 결과를 좀 더 깔끔하게 구할 수 있습니다.

``` java
map.merge(key, 1, Integer::sum);
```

쩌네요.

하지만 어떤 람다에서는 매개변수의 이름 자체가 좋은 정보가 될 수도 있으니 메서드 참조보다 읽기 쉽고 유지보수도 더 쉬울 수 있습니다.

IDE들은 람다를 메서드 참조로 대체하라고 권할 것입니다. 하지만 또 때로는 람다가 메서드 참조보다 간결한 경우가 있습니다. 주로 메서드와 람다가 같은 클래스에 있을 때가 그렇습니다. 예를 들어 다음 코드가 `GoshThisClassNameIsHumonogous` 클래스 안에 있다고 해봅시다.

``` java
service.execute(GoshThisClassNameIsHumonogous::action);
// 람다
service.execute(() -> action());
```

이런 식으루요.



메서드 참조 유형은 다섯 가지로, 가장 흔한 유형을 방금 본 것처럼 정적 메서드를 가리키는 메서드 참조입니다. 나머지 유형을 살펴 봅시다.



먼저 인스턴스 메서드를 참조하는 두 가지 유형이 있습니다. 그 중 하나는 수신 객체(receiving object; 참조 대상 인스턴스)를 특정하는 한정적 인스턴스 메서드 참조이고, 다른 하나는 수신 객체를 특정하지 않는 비한정적 인스턴스 메서드 참조 입니다. 뭔소린지 하나도 모르겠습니다.

``` java
// 한정적 참조
Instant then = Instant.now();
t -> then.isAfter(t)
// 메서드 참조
Instant.now():: isAfter

// 비한정적 참조
str -> str.toLowerCase()
// 메서드 참조
String::toLowerCase
```



마지막으로, 클래스 생성자를 가리키는 메서드 참조와, 배열 생성자를 가리키는 메서드 참조가 있습니다.

``` java
// 클래스 생성자
() -> new TreeMap<K, V>()
// 메서드 참조
TreeMap<K, V>::new

// 배열 생성자
len -> new int[len]
// 메서드 참조
int[]::new
```



## 아이템 44. 표준 함수형 인터페이스를 사용하라

먼저 표준 함수형 인터페이스가 뭔지 알아봅시다. 표준 함수형 인터페이스란 자바 8부터 제공되는 함수형 인터페이스를 말합니다. `java.util.function` 패키지에 포함되어 있고, 매개타입으로 사용되어 람다식을 매개값으로 대입할 수 있도록 해줍니다. `Consumer`, `Supplier`, `Function`, `Operation(UnaryOperator, BinaryOperator)`, `Predicate` 등 총 43개의 인터페이스가 해당 패키지에 있습니다. 방금 언급한 여섯개의 인터페이스가 기본 인터페이스입니다. 

| 인터페이스          | 함수 시그니처         | 예                    | 설명                                      |
| ------------------- | --------------------- | --------------------- | ----------------------------------------- |
| `UnaryOperator<T>`  | `T apply(T t)`        | `String::toLowerCase` | 입력을 연산하여 동일 타입의 출력으로 리턴 |
| `BinaryOperator<T>` | `T apply(T t1, T t2)` | `BigInteger::add`     | 입력을 연산하여 동일 타입의 출력으로 리턴 |
| `Predicate<T>`      | `boolean test(T t)`   | `Collection::isEmpty` | 입력을 판단                               |
| `Function<T, R>`    | `R apply(T t)`        | `Arrays::asList`      | 입력 -> 출력 함수 매핑                    |
| `Supplier<T>`       | `T get()`             | `Instant::now`        | 출력을 공급                               |
| `Consumer<T>`       | `void accept(T t)`    | `System.out::println` | 입력을 소비                               |

이렇게 다양한 용도의 표준 함수형 인터페이스가 구현되어 있기 때문에, **필요한 용도에 맞는 것이 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 활용**하도록 합시다. 그러면 API가 다루는 개념의 수가 줄어들어 익히기 더 쉬워지고, 이러한 표준 함수형 인터페이스들을 유용한 디폴트 메서드를 많이 제공하기 때문에 다른 코드와의 상호운용성도 크게 좋아질 것입니다. 그럼 위의 여섯개의 인터페이스들에 대해 알아봅시다.



`Operator` 인터페이스는 인수가 한 개인 `UnaryOperator` 와 두 개인 `BinaryOperator` 인터페이스로 나뉘고, 반환값과 인수의 타입이 같은 함수를 뜻합니다. `Predicate` 인터페이스는 인수 하나를 받아 `boolean` 을 반환하는 함수를 뜻하고, `Function` 인터페이스는 인수와 반환 타입이 다른 함수를 의미합니다. `Supplier` 인터페이스는 인수를 받지 않고 값을 반환(혹은 제공)하는 함수, `Consumer` 인터페이스는 인수를 하나 받고 반환값은 없는(= 인수를 소비하는) 함수를 의미합니다.





