이번 장은 클래스와 인터페이스에 대한 내용입니다.



## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

잘 설계된 컴포넌트는 클래스 내부의 데이터와 내부 구현 정보를 외부 컴포넌트로부터 잘 숨긴 컴포넌트를 말합니다. 모든 내부 구현을 완벽히 숨기면 구현과 API를 깔끔히 분리할 수 있습니다. 이렇게 되면 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식은 알지도 못하고, 신경도 안써도 되는 거죠. 이러한 개념이 바로바로 **정보 은닉, 또는 캡슐화**라고 하는 아주아주 중요한 개념이지요.

정보 은닉은 시스템을 구성하는 컴포넌트들을 서로 독립시켜서 개발부터 테스트, 수정 등을 개별적으로 할 수 있게 해줍니다. 그럼 정보 은닉의 장점을 쭈루룩 적어봅시다.



- 시스템 개발 속도를 높입니다. 여러 컴포넌트들을 병렬로 개발할 수 있기 때문이죠.
- 시스템 관리 비용을 낮춥니다. 각 컴포넌트를 더 빨리 파악해서 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문입니다.
- 소프트웨어 재사용성을 높입니다. 컴포넌트를 독립적으로 잘 만들면 영 다른 환경의 프로그램에서도 잘 쓰일 수 있겠죠.
- 큰 시스템을 제작하는 난이도를 낮춥니다. 시스템 전체가 완성되지 않았더라도 각 컴포넌트에 대한 동작을 검증할 수 있기 때문입니다.



자바는 정보 은닉을 위한 다양한 장치를 제공해줍니다. 그 중 접근 제어 매커니즘은 클래스, 인터페이스, 멤버의 접근성(접근 허용 범위)를 명시합니다. 각 요소는 선언된 위치와 접근 제한자(`access modifier`)로 정해지는데, 이 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심이 되겠습니다.

기본 원칙은 **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.** 입니다. 즉, 항상 가장 낮은 접근 수준을 부여해야 한다는 뜻입니다. 톱레벨 클래스와 인터페이스에 붙일 수 있는 접근 제한자는 `package-private(default)`과 `public` 두 개입니다. `public` 으로 선언하면 공개 API가 되고, `package-private` 를 붙이면 해당 패키지 안에서만 사용할 수 있죠. 고로 패키지 외부에서 쓸 일이 없으면 `package-private` 를 붙여줍시다. 그렇게 되면 얘들은 내부 구현이 되어 언제든 클라이언트에 아무 피해없이 수정할 수 있습니다. 

참고로 톱레벨 클래스는 가장 바깥쪽에 있는 클래스랍니다.

```java
public class Foo { // top level class
    private static class NestedBar { // nested class
    }
}
```



멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준은 네 가지입니다.

- `private`: 멤버를 선언한 톱레벨 클래스에서만 접근 가능
- `package-private(default)`: 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능, 접근 제한자를 명시하지 않았을 때 적용(인터페이스의 멤버는 기본적으로 `public` 적용!)
- `protected`: `package-private` 접근 범위 + 이 멤버를 선언한 클래스의 하위 클래스에서도 접근 가능
- `public`: 모든 곳에서 접근 가능



클래스의 공개 API를 잘 설계하고, 그 외의 모든 멤버는 `private` 으로 만드는 것이 좋습니다. 그러고 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한해서만 `package-private` 로 풀어줍시다. 근데 만약 권한을 풀어주는 일이 많아진다면, 컴포넌트를 더 분해해야하는 것은 아닌지 고민해 볼 필요가 있겠습니다.



오로지 코드를 테스트하기 위해서 접근 범위를 넓히려는 경우가 있는데요, `public` 클래스의 `private` 멤버를 `package-private` 까지 풀어주는 정돈 괜찮습니다. 다만 테스트만을 위해서 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안됩니다. 다행히 테스트 코드를 테스트 대상과 같은 패키지에 두면 `package-private` 요소에 접근할 수 있겠죠.



`public` 클래스의 인스턴스 필드는 되도록 `public`이 아니어야 합니다. 필드가 가변 객체를 참조하거나 `final` 이 아닌 인스턴스 필드를 `public` 으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 됩니다. 그 필드와 관련된 모든 것은 불변식을 보장할 수 없게 된단 의미입니다. 또한, 필드가 수정될 때 락 획득같은 다른 작업을 할 수 없게 되므로 `public` 가변 필드를 갖는 클래스는 일반적으로 thread-safe 하지 않습니다.

이러한 문제는 정적 필드에서도 마찬가지지만, 예외가 하나 있습니다. 해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소의 상수라면 `public static final` 필드로 공개해도 괜찮습니다. 관례상 이러한 상수의 이름은 스네이크 케이스로 대문자로 쓰입니다. ex) `public static final int SOCKET_TIME_OUT = 90000;` 이런 친구들은 반드시 기본 타입 값이나 불변 객체를 참조해야 합니다. 가변 객체를 참조하면 `final` 이 아닌 필드에 적용되는 모든 불이익이 고대로 적용됩니다. 

길이가 0이 아닌 배열은 모두 변경 가능하니 주의합시다. 따라서 클래스에서 `public static final` 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공하면 안됩니다. 





## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

소싯적에 알고리즘 문제를 풀 때 2차원 점을 표현하는 `Point` 클래스를 많이 만들었었습니다. 이런 식으루요.

``` java
class Point {
  public int y;
  public int x;
}
```

이렇게 간단하게 만들면 알고리즘 문제풀 때는 큰 문제가 없겠지만, 서비스에서는 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점을 살릴 수 없죠. 그래서 필드를 모두 `private` 로 바꾸고 필드들에 대한 `public` 접근자로 `getter` 를 추가하곤 합니다. 웬만한 IDE 에서도 다 제공해주는 기능이죠.

``` java
class Point {
  private int y;
  private int x;
  
  public Point(int y, int x) {
    this.y = y; this.x = x;
  }
  
  public int getY() { return y; }
  public int getX() { return x; }
}
```

이렇게 패키지 밖에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 가질 수 있습니다. `public` 클래스가 필드를 공개하면 이를 써먹는 클라이언트가 생길테니 내부 표현 방식을 맘대로 바꿀 수 없게 되겠죵.





## 아이템 17. 변경 가능성을 최소화하라

불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스입니다. [Immutable & Mutable](https://yoon1fe.tistory.com/140) 여기서 정리한 적이 있죠 헤헤. 불변 클래스는 가변 클래스보다 설계, 구현 및 사용하기가 쉽고, 오류가 생길 여지도 적기 때문에 훨씬 안전합니다.

클래스를 불변으로 만들려면 다음 다섯 가지 규칙을 잘 지키면 됩니다.

- 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
- 모든 필드를 `final`로 선언한다.
- 모든 필드를 `private`로 선언한다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.



다음은 책에 있는 예 - 불변 복소수 클래스입니다.

``` java
public final class Complex {
  private final double re;
  private final double im;

  public Complex(double re, double im) {
    this.re = re;
    this.im = im;
  }

  public double realPart() { return re; }
  public double imaginaryPart() { return im; }

  public Complex plus(Complex c) {
    return new Complex(re + c.re, im + c.im);
  }
  
  public Complex minus(Complex c) {
    return new Complex(re - c.re, im - c.im);
  }
  
  public Complex times(Complex c) {
    return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
  }
  
  ...
  
  @Override
  public boolean equals(Object o) {
    if(o == this) return true;
    if(!(o instanceof Complex)) return false;
    Complex c = (Complex) o;
    
    return Double.compare(c.re, re) == 0
        && Double.compare(c.im, im) == 0;
  }
  
  @Override
  public int hashCode() {
    return 31 * Double.hashCode(re) + Double.hashCode(im);
  }
  
  @Override
  public String toString() {
    return "(" + re + " + " + im + "i)";
  }
}
```

이 클래스를 잘 보면, `plus`나 `times` 같은 사칙연산 메서드들이 인스턴스 자기 자신을 수정하지 않고 새로운 `Complex` 인스턴스를 생성해서 반환합니다. 이처럼 피연산자에 함수를 적용해서 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 **함수형 프로그래밍**이라고 합니다. 또한, 메서드 명이 add 처럼 동사가 아니라 plus와 같은 전치사를 이용함으로써 해당 메서드가 객체의 값을 변경하지 않는다는것을 명시하는 것을 알 수 있습니다.



불변 객체는 근본적으로 thread-safe 하기 때문에 따로 동기화해줄 필요가 없습니다. 여러 스레드가 동시에 사용해도 절대 훼손되지 않기 때문에 불변 객체는 안심하고 여러 스레드끼리 공유할 수 있습니다. 따라서 불변 클래스라면 한 번 만든 인스턴스를 최대한 재활용하기를 권합니다. 인스턴스를 재활용하는 가장 쉬운 방법은 자주 쓰이는 값들을 상수(`public static final`)로 만들어놓고 제공해주는 것입니다. `Complex` 클래스에서는 이런 식으로요.

``` java
public static final Complex ZERO = new Complex(0, 0);
public static final Complex ONE = new Complex(1, 0);
public static final Complex I = new Complex(0, 1);
```



불변 클래스에도 단점이 물론 있습니다. 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것입니다. 그래서 `String` 클래스의 인스턴스들을 모아놓은 String Constant Pool 이란 공간도 있죠.



## 아이템 18. 상속보다는 컴포지션을 사용하라

클래스가 다른 클래스를 확장하는 상속은 이런 저런 문제를 많이 발생시킵니다. 기존 클래스를 확장(상속)하는 대신에 새로운 클래스를 만들고 `private` 필드로 기존 클래스의 인스턴스를 참조하게 하는 방법으로 상속과 같은 효과를 얻고 상속에 따른 문제를 발생시키지 않을 수 있습니다. 이러한 설계를 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 의미에서 **컴포지션(composition; 구성)** 이라고 합니다. 새 클래스의 인스턴스 메서드들은 (`private` 필드를 참조하는) 기존 클래스의 대응하는 메서드를 호출해서 그 결과를 반환합니다. 이 방식을 전달(forwarding) 이라고 하고, 새 클래스의 메서드들을 전달 메서드(forwarding method) 라고 합니다. 이렇게 되면 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나고, 심지어 기존 클래스에 새로운 메서드가 추가되어도 아무런 영향을 받지 않습니다. 

~~뒷부분 추가하기ㅜㅜ~~



## 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

자바 8부터 인터페이스에 디폴트 메서드를 선언할 수 있지요. 디폴트 메서드를 선언하면 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 됩니다. 그렇기 때문에 자바 7까지의 코드들과 완전히 매끄럽게 연동되리라는 보장이 없습니다.

디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있습니다. 따라서 기존 인터페이스에 디폴트 메서드로 새 매서드를 추가하려는 행동은 꼭 필요하지 않는 한 피해야 합니다. 

그러니깐, 디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다는 것이 이번 아이템의 핵심이 되겠습니다.;



## 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 **타입** 역할을 합니다. 즉, C란 클래스가 I 인터페이스를 구현했다는 것은 C 클래스의 인스턴스로 어떤 것을 할 수 있는지를 클라이언트에게 알려준다는 의미입니다. 

이러한 지침에 맞지 않는 예로 상수 인터페이스란 것이 있습니다. 상수 인터페이스란 메서드 없이 상수를 의미하는 `static final` 필드로만 이루어진 인터페이스를 말합니다. 이러한 상수들을 사용하려는 클래스에서는 정규화된 이름을 쓰는 것을 피하고자 그 인터페이스를 구현하곤 합댑니다.

``` java
public interface PhysicalConstants {
	// 아보가드로 수
	static final double AVOGADROS_NUMBER = 6.022_140_857e23;
	// 볼츠만 상수
	static final double BOLTZMANN_NUMBER = 1.380_648_52e-23;
  // 전자 질량
  static final double ELECTRON_MASS = 9.109_383_56e-31;
}
```

클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당합니다. 따라서 이렇게 상수 인터페이스로 구현해 놓은 것은 내부 구현을 클래스의 API로 외부에 노출하는 행위가 됩니다.



위의 사례처럼 상수를 공개할 목적이라면 다음과 같이 인스턴스화 할 수 없는 유틸리티 클래스에 담아 공개해놓을 수 있습니다.

``` java
public class PhysicalConstants {
  private PhysicalConstants() {} // 인스턴스화 방지
  
  // 아보가드로 수
	static final double AVOGADROS_NUMBER = 6.022_140_857e23;
	// 볼츠만 상수
	static final double BOLTZMANN_NUMBER = 1.380_648_52e-23;
  // 전자 질량
  static final double ELECTRON_MASS = 9.109_383_56e-31;
}
```

참고로 이렇게 유틸리티 클래스에 정의된 상수를 사용하려면 클래스 이름까지 명시해야 합니다. `PhysicalConstants.ELECTRON_MASS` 이런 식으로요. 클래스 이름까지 하나하나 명시하기 번거로우면 `static import` 로 클래스 이름을 생략할 수 있답니다.



## 아이템 24. 멤버 클래스는 되도록 static으로 만들라

중첩 클래스(nested class) 는 자신을 감싼 바깥쪽(톱레벨) 클래스에서만 쓰여야 하고, 그외의 쓰임새가 있다면 중첩 클래스가 아닌 톱레벨 클래스로 만들어야 합니다. 중첩 클래스의 종류는

- 정적 멤버 클래스
- (비정적) 멤버 클래스
- 익명 클래스
- 지역 클래스

이렇게 네 가지입니다. 이 중에서 첫번째 정적 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)에 해당합니다. 각각의 중첩 클래스들을 언제, 왜 사용해야 하는지 알아봅시다.



정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 `private` 멤버에도 접근할 수 있다는 점을 제외하고는 일반 클래스와 같습니다. 정적 멤버 클래스의 예로, `Calculator` 클래스에서 사용할 연산자(Operation) `enum` 타입이 있다고 치면, 이 열거 타입은 `Calculator` 클래스의 `public` 정적 멤버 클래스가 되어야 하겠죠. 그러면 클라이언트 입장에서는 `Calculator.Operation.PLUS` 이런 식으로 사용할 수 있겠죠.



비정적 멤버 클래스와 정적 멤버 클래스의 구문상 차이는 `static` 의 유무뿐이지만, 의미상 차이는 꽤 큽니다. 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결되기 때문에, 비정적 멤버 클래스의 인스턴스 메서드에서 정규화된 `this`(클래스명.this) 를 사용해서 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있습니다. 따라서, 개념상으로 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있냐에 따라 정적/비정적 으로 적절히 선언해야겠습니다.

비정 멤버 클래스는 어댑터를 정의할 때 자주 쓰인다고 합니다. 사실 어댑터가 뭔지 잘 모르니깐 다음에 마저 정리하겠습니다.



먼저 익명 클래스는 말 그대로 이름이 없는 객체를 말합니다. 익명 클래스를 사용하는 가장 큰 목적은 부모 클래스를 상속받는 서브 클래스를 생성하지 않고도, **단일 객체**를 만들어서 부모 클래스에 정의된 동작에서 행위를 추가할 수 있다는 것입니다.

익명 클래스는 바깥 클래스의 멤버가 아닙니다. 쓰이는 시점에 선언과 동시에 인스턴스가 만들어지죵. 그리고 `instanceof` 연산자로 검사나 클래스의 이름이 필요한 작업은 수행할 수 없기 때문에 써먹는데 제약이 많은 친굽니다. 또한, 여러 인터페이스를 구현할 수도 없고, 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수도 없습니다. 그럼 이런 애를 어디다 써먹나요?? 

자바가 람다를 지원하기 전까지는 즉석에서 작은 함수 객체나 처리 객체를 만들 때 익명 클래스를 주로 사용했다고 합니다. 또 다른 쓰임으로는 정적 팩터리 메서드를 구현할 때입니다.



마지막 지역 클래스는 네 가지 중첩 클래스 중에서 가장 덜 쓰입니다. 지역 클래스는 지역변수를 선언할 수 있는 곳 어디서든 선언할 수 있고, 스코프도 지역변수와 같습니다. 멤버 클래스처럼 이름이 있고 따라서 반복해서 사용할 수 있습니다.



## 아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라

사실 소스 파일(.java) 하나에 하나의 톱레벨 클래스를 선언하는건 우리에겐 너무도 당연합니다. 여러 개 선언해도 컴파일 오류가 나진 않지만, 이렇게 짜면 아무런 이득도 없을 뿐더러 심각한 위험이 생길 수 있습니다. 톱레벨 클래스가 여러 개라면 한 클래스를 여러 가지로 정의할 수 있게 되고, 그 중 어느 것을 사용할지는 **어느 소스 파일을 먼저 컴파일하느냐에 따라 달라지기 때문**입니다. 









##### 정리하지 않은 아이템

아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

아이템 20. 추상 클래스보다는 인터페이스를 우선하라

아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라

