## 전략 패턴

Java 인터페이스에는 구현된 코드가 없기 때문에 코드 재사용성이 낮다. 한 가지 행동을 바꿀 때마다 그 행동이 정의되어 있는 서로 다른 서브 클래스를 전부 탖아서 코드를 일일이 고쳐야 한다. 이러한 상황에서 어울리는 디자인 원칙??

> 애플리케이션에서 달라지는 부분을 찾고, 달라지지 않는 부분과 분리한다.
>
> 즉, 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 **캡슐화**한다. 이러면 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.



잘 동작하고 있는 클래스는 그대로 두고, 변화하는 부분을 새로운 클래스의 집합으로 분리. 여기 해당하는 행동들에 대한 클래스를 모아둔다. -> 변화하는 부분을 분리하려면 기존의 클래스에서 해당 행동을 끄집어 내서 새로운 클래스로 분리함.



변화하는 행동을 나타내는 클래스는 최대한 유연하게 작성해야 한다.

> 구현보다는 인터페이스에 맞춰서 프로그래밍한다!



이제 기존 클래스에서는 특정 행동에 대한 구체적인 구현을 가져갈 필요가 없어졌다. 추가로, 행동에 대한 인터페이스를 구현한 구현체들을 재사용할 수 있게 되었다. 이러한 행동들이 기존 클래스에 숨어있지 않기 때문.

 

가장 중요한 점은 특정 행동을 기존 클래스에서 정의한 메서드를 써서 구현하지 않고, 아예 다른 클래스에 **위임**한다는 것!



실행 중 기존 클래스의 행동을 변경하고 싶으면 `setter` 메서드를 통해 원하는 행동 클래스 구현체를 바꿔 끼워주면 된다.



이제 기존 클래스(A)에는 각각의 행동 클래스(B)가 있다고 말할 수 있다. 이런 식으로 두 클래스를 합치는 것을 **구성(composition)**이라고 한다.

> 상속보다는 구성을 활용하자!!



위에서 적용한 패턴이 바로 **전략 패턴**이다.

> 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군으 수정해서 쓸 수 있다. 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경 가능!