상태 패턴은 전략 패턴과 매우 비슷하다. 상태 패턴은 내부 상태를 바꿈으로써 객체가 행동을 바꿀 수 있도록 해준다. 

상태 패턴은 유한 상태 머신(finite-state machine)과 밀접한 연관이 있다.

행동을 실행하면 상태가 변경되는 개념..



EX) 뽑기 기계

상태값을 저장하는 인스턴스 변수를 두고, 메서드 내에서 조건문을 써서 다양한 상태를 처리하도록 구현할 수 있겠다.



여기에 기능이 하나 추가되면 기존 메서드 각각의 조건문에 모두 같은 코드가 들어가야 하는 등 비효율 적이다. OCP도 지켜지지 않음.

-> **바뀌는 부분을 캡슐화!**

상태별로 일어나는 일을 국지화. 상태별 행동을 별도의 클래스에 넣어 두고 모든 상태에서 각각 자기가 할 일을 구현.

- 기계와 관련된 모든 행동에 관한 메서드가 들어있는 `State` 인터페이스 정의
- 기계의 모든 상태를 대상으로 상태 클래스를 구현한다. 기계가 어떤 상태에 있다면, 그 상태에 해당하는 상태 클래스가 모든 작업을 책임진다.
- 조건문 코드를 모두 없애고 상태 클래스에 모든 작업을 위임



**`State.java`**

``` java
public interface State {
  void insertQuarter();
  void ejectQuarter();
  void turnCrank();
  void dispense();
}
```

위 인터페이스를 구현하는 `SoldState`, `SoldOutState`, `NoQuarterState`, `HasQuarterState` 등 구현.

기계 코드에서는 숫자로 상태를 나타내던 부분을 상태 객체로 나타내면 된다.



**뽑기 기계 구조**

- 각 상태의 행동을 별개의 클래스로 국지화
- 관리하기 힘든 많은 if문 제거
- 각 상태는 변경에는 닫혀 있고, 기계 클래스는 새로운 상태 클래스를 추가하는 **확장**에는 열려있음



## 상태 패턴

> 상태 패턴을 사용하면 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다. 마치 객체의 크래스가 바뀌는 것과 같은 결과를 얻을 수 있음



**상태 패턴과 전략 패턴의 용도의 차이**

- 상태 패턴: 상태 객체에 일련의 행동이 캡슐화 된다. 상황에 따라 Context 객체에서 어느 한 상태 객체에게 모든 행동을 맡긴다. 클라이언트는 상태 객체를 몰라도 됨.
- 전략 패턴: 일반적으로 클라이언트가 Context 객체에게 어떤 전략 객체를 사용할지를 지정한다. 런타임에 전략 객체를 변경할 수 있는 유연성을 제공하는 용도로 사용됨.