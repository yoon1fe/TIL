객체의 인스턴스를 만드는 작업이 항상 공개되어야 하는 것은 아니다. 오히려 모든 것을 공개했다가는 결합 문제가 생길 수도 있다.



`new` 연산자를 사용하면 인터페이스가 아닌 특정 구상 클래스의 인스턴스가 만들어진다. 구상 클래스를 바탕으로 코딩하면 유연성이 떨어진다. => 즉, **변경에 닫혀 있**게 된다.



## 팩토리 패턴

객체 생성을 처리하는 클래스를 **팩토리**라고 부른다. 이러한 팩토리를 사용하는 클라이언트가 여러 개 있을 수 있으므로, 팩토리 클래스로 캡슐화해놓으면 구현을 변경할 때 여러 부분을 고칠 필요 없이 팩토리 클래스 하나만 고치면 된다.



**간단한 팩토리(Simple Factory)**

팩토리에서 생산하는 구상 클래스는

1. 인스턴스를 구현해야 하고,
2. 구상 클래스여야 한다.



팩토리 메서드는 객체 생성을 서브 클래스에 캡슐화할 수 있다. 이렇게 하면 슈퍼 클래스에 있는 클라이언트 코드와 서브 클래스에 있는 객체 생성 코드를 분리할 수 있다.

- 팩토리 메서드를 추상 메서드로 선언해서 서브 클래스가 객체 생성을 책임지도록..



**팩토리 메서드 패턴**

- 객체를 생성할 때 필요한 인터페이스를 만든다. 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정. 

- 서브 클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡슐화 한다.

- 구상 생산자 클래스가 하나뿐이라도 팩토리 메서드 패턴은 충분히 유용하다. 생산하는 부분과 사용하는 부분을 분리할 수 있기 때문.
- 간단한 팩토리에 비해서 재사용이 가능한 프레임워크라고 볼 수 있다.



**의존성 뒤집기(Dependency Inversion)**

> **추상화**된 것에 의존하게 만들고, 구상 클래스에 의존하지 않게 만든다.

고수준 구성 요소가 저수준 구성 요소에 의존하면 안되고, 항상 추상화에 의존하도록 만들어야 한다.



의존성 뒤집기 원칙을 지키는 방법

- 변수에 구상 클래스의 레퍼런스를 저장하지 말 것
- 구상 클래스에서 유도된 클래스를 만들지 말 것
- 베이스 클래스에 이미 구현되어 있는 메서드를 오버라이드하지 말 것



**추상 팩토리 패턴**

> 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공한다. 구상 클래스는 서브 클래스에서 생성한다.



- 팩토리 메서드 패턴과 추상 팩토리 패턴 모두 객체를 만든다. 다만
  - 팩토리 메서드 패턴: 상속을 통해 객체를 만듦.
  - 추상 팩토리 패턴 객체 구성(composition)을 통해 객체를 만듦.
