## 예제 도메인
- 온라인 영화 예매 시스템
- 도메인
    - 영화, 상영, 할인 정책(정액/정률), 할인 조건(회차/상영범위), 예매 



### 절차적인 설계

Process와 Data가 나누어져 있고, 따로 생각한다. 객체지향은 둘을 함께 생각.



절차적인 설계라 함은..

1. ERD를 그리고, 테이블의 데이터를 가져올 객체를 만든다. 필드는 private로 선언하고 게터 세터를 만들고.. 값들을 어떻게 쓸지, 바뀔지 모르니깐 단순하게 게터 세터만 만듦. -> 절차지향적인 설계다. 우리가 만든게 객체라고 생각하지만, 단순한 **데이터**에 가깝다.

2. DB에서 값을 가져올 수 있도록 DAO를 만든다. 그 뒤 이 데이터를 어떻게 처리할지를 프로세스로 처리한다. 프로세스는 "기능"이지만 일단.. 클래스를 만들어놓는다..

3. 절차지향적인 예매 로직을 짠다. `reserveScreening()` 서비스단 안에 긴 코드를 짜게 된다.

   ``` java
   private DiscountCondition findDiscountCondition(Screening screening,
       List<DiscountCondition> conditions) {
       for(DiscountCondition condition : conditions) {
           if (condition.isPeriodCondition()) {
               if (screening.isDayOfWeek(condition.getDayOfWeek()) &&
                   screening.isDurationBetween(condition.getStartTime(),
                       condition.getEndTime())) {
                   return condition;
               }
           } else {
               if (condition.getSequence().equals(screening.getSequence())) {
                   return condition;
               }
           }
       }
       return null;
   }
   ```

   * 데이터: 바보 / 객체: 똑똑이. 타입 체크를 개발자가 한다? 그럼 얘는 데이터이다..
   * 절차적인 코드는 읽기 편하다.. 읽는 순서랑 실행 순서랑 동일함.
   * 프로세스쪽으로 제어가 몰림. 중앙 집중식 제어 스타일



### 객체지향 설계

프로세스 + 데이터 (상태 + 행위) => 객체지향! 절차지향에선 객체(데이터)의 쓰임새를 고려하지 않고 설계한다.

객체지향은 데이터가 있을 때 데이터의 쓰임새를 묶어서 설계. => **문맥을 고려**

설계할 때는 객체의 협력관계를 먼저 고려해야 한다.



**책임-주도 설계**

- 애플리케이션의 요구사항 파악
- 애플리케이션의 요구사항을 시스템의 책임으로 변환
- 시스템의 책임을 객체의 책임으로 변환 
- 책임을 담당할 수 있는 적절한 객체 선택 
- 객체의 책임 일부를 수행하기 위해 외부의 도움이 필요하다면 다른 객체에게 도움을 요청 
- 이 요청을 또 다른 객체의 책임으로 변환 
- 책임을 담당할 수 있는 적절한 객체 선택



**CRC Card** - 책임과 협력을 표현하기 위한 객체지향 설계 도구

- Candidate(Role or Object)
- Responsibility
- Collaborator



최종 결과물 예매 생성 책임 할당 ? 

- 예매 생성에 필요한 정보의 전문가에게 할당하자.
- 도메인 개념을 기반으로 **정보(행동)**의 전문가에게 할당! 
- 가격 계산 책임 - 상영(Screening), 영화(Movie) 객체
- 할인율 계산 책임 - +) 할인 정책(Discount Policy)
- 할인 여부 판단 책임 - +) 할인 조건(Discount Condition)



**좋은 설계란**

- **응집도**가 높은 객체
- **결합도**가 낮은 객체
- **캡슐화**가 잘 된 객체



설계란 ? **코드를 배치하는 방식**

좋은 설계란?? **변경하기 쉽게 코드를 배치하는 방식**. 모든 설계 원칙과 용어는 **변경**과 관련이 있다.





## 응집도, 결합도,  캡슐화 관점에서 두 설계 비교하기

### 응집도

- 모듈 (클래스) 내부 요소들이 함께 변경되는 정도
- 낮은 응집도: 모듈(클래스)이 다양한 이유로 변경됨. 
- 높은 응집도: 모듈(클래스) 전체가 동일한 이유로 변경됨.



절차적인 설계는 응집도가 낮다. 할인 정책, 할인 조건이 변경될 때 예매 로직이 변경된다. 서로 다른 이유로 변경됨.

**응집도 측면에서 객체지향이 변경하기 더 쉽다!**



### 결합도

- 한 모듈(클래스)이 다른 모듈(클래스)에 의존하는 정도
- 한 모듈(클래스)이 다른 모듈(클래스)에 대해 알고 있는 지식의 양
- 좋은 설계는 **결합도가 느슨한** 관계



변경 관점에서

- 모듈(클래스)을 변경할 때 다른 모듈(클래스)이 함께 변경되는 정도
- 느슨한 결합도: 구현이 변경될 때 함께 변경되지 않음



**구현과 추상화**

- 구현: 자주 변경되는 불안정한 부분
- 추상화: **자주 변경되지 않는 안정적인 부분**
- 느슨한 결합도: 안정적인 **추상화에 의존**하도록 설계

**결합도 측면에서도 객체지향이 변경하기 더 쉽다!**



### 캡슐화

- 상태(데이터)와 행동(메서드)를 하나의 단위로 묶음
- 데이터를 감추고 공용 메서드를 외부에 공개
- 공용 인터페이스 - 외부에 공개된 공용 메서드의 집합



변경 관점

- 변경 가능성이 높은 부분을 내부로 숨기는 추상화 기법
- 설꼐에서 변하는 것이 무엇인지 고민하고 변하는 개념을 캡슐화
- 변경될 수 있는 어떤 것이라도 감추는 것