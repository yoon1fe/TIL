4장의 제목은 실용주의 편집증입니다. 편집증은 심각한 걱정이나 두려움으로 자신이 주변으로부터 피해를 받을 것이라는 병리적인 의심을 고집하는 이상심리학적 상태..라고 위키에 나와있습니다 ㅎ. 완벽한 소프트웨어를 만드는 것은 현실적으로 불가능합니다. 암울한 현실이지만, 세상엔 불완전한 코드로 가득차 있습니다. 우리는 이 때문에 항상 방어적으로 프로그래밍을 합니다. 잘못된 데이터를 찾기 위해 단정문(assertion)을 사용하고, DB 칼럼에 제약(constraint)을 걸기도 하지요. 

하지만 실용주의 프로그래머들은 여기서 한 걸음 더 나아갑니다. 자기 자신도 믿지 않져. 때문에 실용주의 프로그래머는 항상 자신의 실수에 대비해서 방어적인 코드를 짭니다. 고로 이번 장에서는 이러한 방어법과, 데이터 등을 확인, 검증하는 방법, 예외 처리를 잘 하는 방법 등을 알아봅시다. 요새 방어가 철이던데~~



## 21. 계약에 의한 설계



우리의 프로그램에서 모든 함수나 메서드는 어떠한 무언가를 수행합니다. 이 때, 프로그램의 정확성을 보장하기 위해서 소프트웨어 모듈들의 권리와 책임을 문서화하는 것이 계약에 의한 설계입니다. 자신이 해야하는 역할과 임무를 문서화하고, 이를 검증하는 것이 계약에 의한 설계의 핵심입니다.

이러한 역할(루틴)을 검증하는데 세 가지 개념이 필요합니다.

- 선행조건 - 루틴이 호출되기 위해 참이어야 하는 것
- 후행조건 - 루틴이 자기가 할 것
- 클래스 불변식 - 호출자의 입장에서 볼 때 항상 참이라고 보장되어야 하는 것



이러한 계약에 의한 설계, 즉 DBC를 지원하는 언어도 있습니다. 자바 진영에서는 iContrast라는 전처리기가 있다고 하네요. 첨들어봅니다. 이렇게 단정문을 이용하는 것과 그냥 주석만 적어놓는 것은 큰 차이가 있습니다. 부모 클래스와 이를 상속받는 자식 클래스가 있을 때, 자식 클래스에서 같은 메서드 시그니처를 갖고, 메서드 명과 상관없는 엉뚱한 일을 처리하는 메서드를 만들 수도 있습니다. DBC를 사용하면 이러한 경우를 방지할 수 있습니다.



## 22. 죽은 프로그램은 거짓말을 하지 않는다

프로그램에 에러가 발생했을 때 가장 중요한 것은 **최대한 일찍 작동을 멈추게 하는 것**입니다. 일반적으로, 죽은 프로그램이 끼치는 피해는 에러를 껴안은 반쪽짜리 프로그램보다 훨씬 덜 하기 때문입니다. 자바에서도 이러한 철학을 포용했는데요, 런타임에 뭔가 예상치 못한 것이 발생하면 `RuntimeException` 을 던지게 되는거용.



## 23. 단정적 프로그래밍

코드를 작성할 때, "이런 일은 절대 일어날 리 없다"는 생각을 절대! 하지맙시다. 방어적으로 코드를 작성하기 위해서는 발생 불가능한 상황도 예방해야 합니다. 가장 간단한 방법은 단정문`assertion` 을 사용하는 것입니다. 단, 단정문을 에러처리 대신 사용하면 안됩니다. 



## 24. 언제 예외를 사용할까

예외 처리를 할 때 가장 관건은 이 예외를 언제 사용할지 아는 것이 아닐까 싶습니다. 예외는 말그대로 의외의 상황에서 사용되어야 합니다. 잡히지 않은 예외는 프로그램을 종료시킬 것이라고 가정하고 예외를 잡고, 처리합시다.

예를 들어, 어떤 파일을 열어서 읽어 들이는 코드에서, 그 파일이 존재하지 않는 경우 예외가 발생되어야 할까요? 이는 경우에 따라 다릅니다. 만약 열려는 파일이 당연히 존재하는 상황이라면, 예외가 발생해야 합니다. 마땅히 있어야 하는 파일이 없다면 예상치 못한 일이 벌어진 것이죠. 반면에 열려는 파일이 없을 수도 있다면 이는 크게 의외의 상황은 아닐겁니다. 따라서 에러를 반환하는 것이 더 적절할 수 있습니다.



## 25. 리소스 사용의 균형

리소스 관리는 굉장히 중요합니다. 메모리, 트랜잭션, 쓰레드, 파일 등등 모두 리소스이고, 이를 잘 관리해야만 합니다. 리소스 할당과 해제에 관해서는 아주 간단하고 확실한 팁이 있습니다. 바로 시작한 것은 끝내는 것입니다. 

한 번에 하나 이상의 리소스를 필요로 하는 프로그램에서는 아래와 같은 두 가지 팁이 있습니다.

1. 리소스를 할당한 순서의 반대로 해제할 것. 이러면 고아 리소스가 생기지 않습니다.
2. 코드의 여러 곳에서 동일한 리소스 집합을 할당하는 경우, 할당 순서를 항상 같게 할 것. 이러면 데드락 가능성이 줄어들 것입니다.



JVM에는 가비지 콜렉터라는 아주 똑똑한 친구가 있죠. 참조가 없는 객체들을 찾아서 알아서 할당 해제를 해주는 역할을 합니다. 어떠한 객체를 사용한 다음에 그 객체의 변수에 NULL을 넣어주면, 해당 객체는 가비지 콜렉션의 대상이 될 수 있습니다. 다 쓴 객체의 리소스를 바로 반납할 수 있는 효과를 기대해 볼 수 있겠습니다.
