2장에선 실용주의 접근법에 대해 알아봅니다.

이번 장에서는 소프트웨어 개발에 있어서 모든 차원에 적용 가능한 아이디어나 프로세스들을 공부해 봅시다. 중복을 최소화하라든지, 빠르게 변화하는 환경에서 프로젝트를 분리하는 기법 등과 같은 것들이요. 이런 아이디어들을 항상 유념하면서 개발하도록 합시다.



## 7. 중복의 해악

소프트웨어를 신뢰성 높게 개발하고, 개발을 이해하고 유지보수하기 쉽게 만드는 유일한 방법은 DRY(`Don't Repeat Yourself`) 원칙을 따르는 것 뿐입니다. 이 원칙은 실용주의 프로그래머 책에서 소개해주는 원칙 중 가장 중요하다고 강조합니다.



책에서는 다음과 같이 네 가지 범주의 중복을 제시합니다.

- 강요된 중복
- 부주의한 중복
- 참을성 없는 중복
- 개발자간의 중복



### 강요된 중복

어쩔 수 없다고 여겨지는 중복입니다. 가끔씩 환경이 중복을 요구하는 것처럼 보일 수 있습니다. 요구사항에서 그렇게 느껴질 수도 있고, 언어 자체가 그런 구조를 요구할 수도 있습니다. 하지만 많은 경우, 중복을 최소화하면서 DRY 원칙을 따를 수 있는 방법이 존재한답니다. 다음이 그러한 방법들입니다.

- 정보의 다양한 표현 양식
- 코드 내의 문서화
- 문서화와 코드



### 부주의한 중복

설계 단계에서의 실수로 인한 중복입니다. DB 설계할 때 정규화를 잘 합시다. 또한, 상호의존적인 데이터 요소들이 있는 경우, 계산되는 필드로 구현해 놓으면 좋습니다. 예로, 선을 표현한 클래스를 봅시다.

``` java
class Line {
  Point start;
  Point end;
  double length;
}
```



꽤 그럴싸해 보입니다. 하지만 길이(`length`)는 시작점(`start`)과 끝점(`end`) 으로 결정됩니다. 만약 시작점이나 끝점 중 하나라도 바뀐다면 길이도 바뀌게 되겠죠. 이럴 때 길이는 계산해서 나타내는 것이 좋습니다.

``` java
class Line {
  Point start;
  Point end;
  double length() {
    return start.distanceTo(end);
  }
}
```



### 참을성 없는 중복

'시간이 빠듯해서'와 같은 이유로 게으름때문에 생기는 중복입니다. 이럴 땐 '급할수록 돌아가라'는 속담을 명심합시다.



### 개발자간의 중복

한 프로젝트 안에서 서로 다른 개발자들 사이에서 발생할 수 있는 중복입니다. 이러한 중복은 쉽게 발견조차 되지 않을 수 있습니다. 고차원적인 해결 방법은 깔끔한 설계와 기술적인 프로젝트 리더, 그리고 그 설계 내에서 적절한 책임의 분배가 되겠습니다. 하지만 현실적인 최선책은 개발자간에 적극적이고 잦은 의사소통입니다.



## 8. 직교성

기하학에서, 그래프의 축과 같이 두 직선이 직각으로 반나는 경우를 두 직선이 **직교**한다고 말합니다. 이 때, 두 개의 선은 각자 **독립적**입니다. 한 선에서 왔다갔다 해도 다른 선 위로 투영된 위치는 변하지 않죠.

이러한 직교성은 컴퓨팅에서는 독립성이나, 결합도 줄이기 정도의 의미로 사용됩니다. 한 모듈이 바뀌어도 다른 모듈에 영향을 주지 않으면 이 두 모듈은 직교한다고 할 수 있는 것이져. 또한, 잘 설계된 시스템에서는 데이터베이스 코드와 사용자 인터페이스가 서로 직교할 것입니다. 직교적인 시스템의 두 가지 큰 장점으로는 **생산성 향상, 리스크 감소** 가 있습니다. 

직교적으로 잘 프로그래밍하면 컴포넌트간의 상호의존성을 낮출 수 있습니다. 따라서 이를 충실히 따른다면 더욱 더 유연하고, 이해하기 쉽고, 디버깅, 테스트 , 유지보수도 훨씬 더 쉬워질 겁니다. 직교적으로 삽시다!!



## 9. 가역성

가역성이란 물질이 어떤 상태로 변하였다가 다시 원래의 상태로 되돌아갈 수 있는 성질입니다. 요건 또 프로그래밍에서 어떤 개념으로 쓰이느냐.. 봅시다.

이번 장의 핵심은 **최종 결론이란 없다** 입니다. 항상 수정을 염두에 두고 프로젝트를 진행합시다. 또한, 코드뿐만 아니라 아키텍처 수준에서도 유연함을 유지하도록 노력합시다.



## 10. 예광탄

예광탄은 일반 탄환들 사이에 일정한 간격으로 끼어있는 발광제가 들어 있는 탄환입니다. 야간 사격을 할 때, 어둠 속에서 여러 조건 등을 계산해 목표물을 정확히 조준해서 쏘는 방법과 예광탄을 이용하는 방법입니다. 새로운 프로젝트에 있어서도 이러한 두 가지 방법으로 접근할 수 있습니다. 전혀 새로운 프로젝트를 구현하는데 익숙치 않은 수많은 알고리즘, 기술 스택, 언어, 라이브러리 등을 완벽히 숙지하고 진행하는 것과, **예광탄을 사용하는 것**입니다.

여기서 말하는 예광탄이란, 클라이언트가 눈으로 확인할 수 있을 정도의 서비스라고 할 수 있겠습니다. 참고로 예광탄은 다음 장에서 다룰 프로토타입과는 다릅니다. 예광탄 코드는 나중에 버리려고 만드는 것이 아닙니다. 단지 아직 완전한 기능이 구현되어 있지 않을 뿐입니다. 이러한 예광탄 코드 접근법에는 여러 장점이 있습니다.

- 사용자들은 뭔가 작동되는 것을 일찍부터 보게 됨.
- 개발자들은 들어가서 일할 수 있는 구조를 얻음.
- 통합 작업을 수행할 기반이 생김.
- 보여줄 것이 생김.
- 진전 상황에 대해 더 정확하게 감을 잡을 수 있음.



## 11. 프로토타입과 포스트잇

프로토타입은 실제 제품을 만드는 것보다 훨씬 저렴합니다. 소프트웨어 프로토타입을 통해서 위험 요소를 분석하고 노출시키고, 이를 매우 저렴한 비용으로 바로잡을 수 있습니다. 또한, 프로토타입을 프로젝트의 특정 부분에만 중점을 두어서 만들어 볼 수도 있습니다.

프로토타입은 예광탄 코드와는 다르게, 당장 중요하지 않은 세부사항을 무시할 수 있습니다. 예를 들어 GUI를 프로토타이핑한다면, 정확한 결과값은 딱히 필요 없겠죠. 만약 세부사항을 무시하기 어렵다면, 프로토타이핑보단 예광탄 코드를 작성하는게 옳은 일일 수 있습니다.



## 12. 도메인 언어

**문제 도메인에 가깝게 프로그래밍**합시다. 무슨 말인지 사실 잘 모르겠습니다.



## 13. 추정

우리는 프로젝트를 진행하는데 있어 여러 항목의 추정치를 산출하는 능력이 필요한데요. 이러한 능력은 경험을 통해 발전시켜야 합니다. 그럼 그 전에 누군가 추정에 대해 물을 때 답변으로 쓸 수 있는 올바른 답변을 알아봅시다.

얼마나 정확한 것이 충분히 정확한 것일까요? 질문자가 높은 정확도의 답을 요구하는지, 아니면 단순히 큰 그림에 대한 답을 요구하는지 알아채는게 중요합니다. 추정에서는 사용하는 단위가 결과의 해석에 차이를 가져옵니다. 무언가를 끝내는데 130일 정도의 근무일이 필요하다고 말한다면, 꽤 가까운 시일 내에 끝날 거라고 생각할 수 있습니다. 반면에, 6달 정도 걸릴거라고 말한다면 5~7달 정도의 텀으로 질문자에게 다가올 수도 있습니다. 책에서는 다음과 같은 단위로 기간을 추정하는 것을 추천하고 있습니다.

- 1~15일: 일
- 3~8주: 주
- 8~30주: 달
- 30주 이상: 다시 생각해보자..







