5장에서는 **되돌릴 수 있는** 의사 결정을 내릴 수 있는 방법에 대해서 알아봅니다. 이를 잘 활용하면 유연성을 확보할 수 있습니다. 결합도를 줄이는 방법, 메타데이터를 활용하여 세부사항을 코드 밖으로 분리하는 방법 등등을 알아봅시다~~



## 26. 결합도 줄이기와 디미터(데메테르) 법칙

모듈간의 의존 정도를 결합도`coupling` 이라고 합니다. 결합도가 낮을수록 각 모듈의 독립성이 높아지지요. 그럼 어떻게 결합도를 낮출 수 있을까요? 

코드를 모듈로 구성하고, 이들 간의 상호작용을 제한합시다. 그러면 한 모듈이 변경되거나 교체되어도 다른 모듈들은 변경없이 로직을 수행할 수 있을 것입니다.



불필요한 의존이 많은 시스템은 유지보수하기 어렵고, 시스템 자체가 매우 불안정한 경향이 있습니다. 때문에 의존도를 최소화하기 위해 **디미터 법칙**을 사용하여 메서드와 함수를 설계해야 합니다.



#### 디미터 법칙

디미터 법칙은 캡슐화와 낮은 결합도를 위한 법칙입니다. 디미터 법칙은 다음과 같은 간단한 규칙으로 구성됩니다.

- 메서드에서 생성한 객체의 메서드만 호출
- 파라미터로 받은 객체의 메서드만 호출
- 필드로 참조하는 객체의 메서드만 호출

다음 코드는 디미터 법칙을 위배한 간단한 예시 코드입니다.

``` java
public void processSome(Member member) {
    if (member.getDate().getTime() < ...) {	// 디미터 법칙 위배!
        ...
    }
}
```



디미터 법칙을 따르면 정말 유지보수하기 좋은 코드를 짤 수 있을까요? 

연구에 따르면 응답집합이 큰 클래스는 작은 클래스보다 에러를 발생시키기 쉽다고 합니다. 응답집합이란 클래스의 메서드가 직접 호출하는 함수의 개수를 의미합니다.

디미터 법칙을 따르면 함수를 호출하는 클래스의 응답집합 크기를 줄일 수 있기 때문에 좀 더 에러가 적은 클래스들을 만들 수 있습니다.

하지만 무조건적으로 디미터 법칙을 따르는 것은 능사가 아닙니다. 데이터베이스 스키마 설계 시 반정규화를 통해 성능을 개선하듯이, 디미터 법칙과 반대로 여러 모듈의 결합도를 높힘으로써 성능 향상을 노릴 수도 있습니다.



## 27. 메타프로그래밍

메타데이터를 이용하여 반환 매개 변수, 사용자 선호사항, 설치 디렉터리와 같은 애플리케이션 설정 옵션을 기술합시다. 

메타데이터란 쉽게 말해서 데이터에 관한 데이터입니다. 데이터베이스 스키마, 데이터 경로와 같은 것들이요. 하지만 여기서 말하는 메타데이터는 좀 더 넓은 의미로써 사용됩니다. 여기서 말하는 메타데이터는 애플리케이션을 기술하는 모든 데이터를 뜻합니다. 

책에서는 이러한 메타데이터를 최대한 많이 사용해서 애플리케이션을 설정하고 실행하는 것을 권장합니다. 어떻게가 아닌 **무엇을** 해야 하는지를 명시함으로써 선언적으로 생각하고, 이로써 더 동적이고 적응 가능한 프로그램을 만들기 위해서 입니다. 코드에는 추상화를, 메타데이터에는 세부 내용을요.

이렇게 접근한다면 다음과 같은 이점이 있습니다.

- 설계의 결합도를 줄여 좀 더 유연하고 적응성 있는 프로그램을 만들 수 있음
- 세부사항을 코드 밖으로 몰아냄으로써 보다 강하고 추상적인 디자인을 만들 수 있음
- 애플리케이션을 커스터마이징하기 위해 다시 컴파일할 필요가 없음
- 메타데이터는 범용 프로그래밍 언어보다 문제 도메인에 가까운 방식으로 표현될 수 있음
- 동일한 애플리케이션 엔진과 상이한 메타데이터를 이용해 여러 다른 프로젝트를 진행할 수 있음



## 28. 시간적 결합

시간적 결합`temporal coupling`이 뭘까요? 이름은 겁나 멋있습니다. 

우리는 개발을 할 때 시간이라는 측면`을 자주 무시합니다. 그나마 일정, 출시까지 남은 시간만 보통 고려하죠. 여기서 말하는 시간은 이런 종류의 시간이 아닙니다. 그 대신 소프트웨어 설계 요소 자체로서의 시간의 역할에 대해 얘기하는데요, **동시성**과 **순서**가 그것입니다.

우린 동시성을 허용할 필요가 있고, 시간이나 순서에 따른 의존성의 결합을 끊을 필요가 있습니다. 그렇게 함으로써 유연성도 얻을 수 있고, 작업 흐름 분석, 설계, 배포와 같은 여러 측면에서 시간과 관련된 모든 의존성을 줄일 수 있습니다.



## 29. 단지 뷰일 뿐이야

우린 계속해서 프로그램을 커다란 한 덩어리로 짜지 말고, 여러 모듈로 나누어 결합도를 낮추는 얘길 했었습니다. 이는 단일 책임 원칙과도 일맥상통하구요. 하지만 추가적으로, 역할(책임)으로 나누는 것 뿐만 아니라 뷰와 모델을 분리하는 것도 중요합니다. 



뷰와 모델을 분리하는 두 가지 방법을 알아봅시다.

첫 번째는 출판`Publish`/구독`Subscribe` 모델입니다. 이 모델에서 출판자는 이벤트를 발행하고, 구독자는 이벤트를 받아봅니다(구독). Apache Kafka가 이러한 모델을 채택하고 있죵. 이렇게 이벤트를 발행/구독하는 구조를 가진다면, 객체들 사이의 결합을 최소화할 수 있습니다. 출판자는 수신자에 대해 직접적인 지식을 가질 필요가 없기 때문입니다. 

하지만 모든 이벤트를 하나의 루틴에 몰아 넣는 것은 좋지 않습니다. 객체 캡슐화에 위배되기 때문입니다. 단 하나의 루틴이 여러 객체들 사이의 상호작용에 대한 지식을 갖고 있어야 하죵. 그리고 결합도도 증가됩니다. 이러한 문제점은 구독자들이 자신이 필요한 이벤트들만 구독해서 받아보는 Pub/Sub 모델로 해결 가능합니다.



두 번째 방법은 그 유명한 M`Model`V`View`C`Controller` 모델입니다. 모델을 표시하는 뷰, 그리고 뷰를 관리하는 컨트롤러에서 모델을 분리해 내는 것이 바로 MVC 모델의 핵심입니다. 이러한 모델을 구축한다면 동일한 데이터 모델에 여러 뷰를 둘 수도 있고, 여러 다른 데이터 모델을 보는 공통 뷰를 만들 수도 있습니다. 적은 비용으로 큰 유연성을 얻게 되는 것이죠.



참고로 MVC 모델은 보통 GUI 개발이라는 맥락에서 자주 쓰이지만, 충분히 일반적으로도 쓸 수 있는 개념입니다. 여기서 뷰는 모델을 해석하는 방식이란 개념으로 사용됩니다. 모델의 변화, 그리고 컨트롤러가 보내는 논리적 사건을 구독하는 셈이죵.



## 30. 칠판

형사들이 회의실에 커다란 칠판을 두고 여러 단서들을 수집하는 것처럼, 프로젝트에서도 작업 흐름이 분산된 데이터 수집 공간을 이러한 칠판과 같은 개념으로 생각해볼 수 있습니다. 

칠판 시스템을 이용하면, 데이터의 소비자와 생산자들이 익명으로, 그리고 비동기적으로 데이터를 주고받는 공간이 생깁니다. 그 덕분에 객체들 사이의 결합을 완전히 끊을 수 있습니다. 









##### Reference

개발자가 반드시 정복해야 할 객체지향과 디자인 패턴 - 최범균