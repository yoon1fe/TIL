지금까지 스프링의 3대 핵심 기술인 IoC/DI, 서비스 추상화, AOP에 대해 알아봤다. 스프링의 모든 기술은 객체지향적인 언어의 장점을 활용해서 코드를 작성하도록 도와주는 것이다. 7장에서는 세 기술을 활용해서 애플리케이션을 개발해보면서 스프링의 개발 철학과 추구하는 가치, 스프링 사용자에게 요구되는 것이 무엇인지 살펴본다.



### 7.1 SQL과 DAO의 분리

SQL 문을 DAO 에서 분리해보자. 앞선 작업들로 데이터 액세스 작업과 관련된 코드를 책임과 성격이 다른 부분끼리 분리하고, 독립적으로 확장하거나 변경할 수 있도록 인터페이스를 이용해 연결하고, DI로 다이나믹하게 관계를 설정할 수 있게 되었다. 하지만 데이터 액세스 로직이 바뀌지 않더라도, DB 테이블, 필드 이름과 SQL문은 변경될 수 있다. 따라서 DB 테이블과 필드 정보가 그대로 담겨 있는 SQL 문장을 분리하는 것이 좋겠다. SQL 분리 설정에는 XML 설정을 이용한 분리, SQL 제공 서비스를 활용한 분리가 있다.



먼저 SQL 분리 방법은 SQL을 XML 설정 파일로 빼내는 것이다. 스프링은 설정을 이용해 빈에 값을 주입해줄 수 있기 때문에, 설정 파일에 프로퍼티 값으로 정의해서 DAO에 주입해줄 수 있다.



XML 설정 파일 안에 SQL을 두고 이를 DI 해서 DAO가 사용하게 하면 쉽게 SQL을 코드에서 분리할 수 있지만, 몇 가지 문제점이 있다. 먼저 데이터 액세스 로직인 SQL과 애플리케이션 구성 설정 정보가 섞여 있으면 보기에도 지저분하고 관리하기에도 좋지 않다.



SQL 제공 기능을 본격적으로 분리해서 다양한 SQL 정보 소스를 사용할 수 있고, 운영 중에 동적으로 갱신도 가능한 유연하고 확장성이 뛰어난 SQL 서비스를 만들어보자.



```java
public interface SqlService {
    String getSql(String key);
}
```

```java
package springbook.user.sqlservice;

public class SimpleSqlService implements SqlService {
    
    private Map<String, String> sqlMap;
    
    
    @Override
    public String getSql(String key) throws SqlRetrieveFailureException {
        String sql = sqlMap.get(key);
        if (sql == null) {
            throw new SqlRetrieveFailureException(key + "에 대한 SQL을 찾을 수 없습니다.");
        }
        
        return sql;
    }
}
```



`SimpleSqlService` 클래스를 빈으로 등록하고, `UserDao` 가 DI 받아 사용하도록 설정해준다. SQL 정보는 이 빈의 프로퍼티에 `<map>` 을 이용해 등록한다.



### 7.2 인터페이스의 분리와 자기참조 빈

스프링의 XML 설정 파일에서 `<bean>` 태그 안에 SQL 정보를 넣어놓고 활용하는 것은 좋은 방법은 아니다. 그보다는 SQL을 저장해두는 전용 포맷을 가진 독립적인 파일을 이용하는 편이 바람직하다.



XML에 담긴 정보를 파일에서 읽어오는 방법은 여러 가지가 있는데, JAXB(Java Architecture for XML Binding)를 사용해본다. JAXB의 장점은 XML 문서 정보를 거의 동일한 구조의 오브젝트로 직접 매핑해준다는 것이다. JAXB는 XML 문서의 구조를 정의한 스키마를 이용해서 매핑할 오브젝트의 클래스까지 자동으로 만들어주는 컴파일러도 제공해준다.



SQL 정보는 키와 SQL의 목록으로 구성된 맵 구조로 만들어두면 편하다. 키와 SQL 정보를 담은 `<sql>` 태그를 가진 XML 문서를 사용하자.



``` xml
<sqlmap>
	<sql key="userAdd">insert into users(...) ...</sql>
	<sql key="userGet">select * from users ...</sql>
  ...
</sqlmap>
```



그리고 이 XML 문서의 구조를 정의하는 스키마를 만들고 JAXB 컴파일러로 컴파일하면 바인딩용 클래스가 자동으로 생성된다. JAXB에서 언마샬링`unmarshalling` 이란 XML 문서를 읽어서 자바 오브젝트로 변환하는 것을 말한다. 반대로 바인딩 오브젝트를 XML 문서로 변환하는 것은 마샬링이라고 한다.



`UserDaoJdbc` 에서 사용할 SQL이 담긴 XML 문서는 다음과 같다. SQL은 DAO 로직의 일부라고 볼 수 있기 때문에 DAO와 같은 패키지에 두는 것이 좋다.



``` xml
<?xml version="1.0" encoding="UTF-8"?>
<sqlmap xmlns="http://www.epri1.com/sqlmap" xmlns:xsi="http://www .w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.epril.com/sqlmap http://www.epril.com/sqlmap/sqlmap.xsd">
    <sql key="userAdd">insert into users(id, name, password, email, level,
        login, recommend) values(?,?,?,?,?,?,?)
    </sql>
    <sql key="userGet">select * from users where id = ?</sql>
    <sql key="userGetAll">select * from users order by id</sql>
    <sql key="userDeleteAll">delete from users</sql>
    <sql key="userGetCount">select count(*) from users</sql>
    <sql key="userUpdate">update users set name =?, password = ?, email = ?,
        level = ?, login = ?, recommend = ? where id = 7
    </sql>
</sqlmap>
```



이제 위 파일에 있는 SQL을 DAO 에 제공해주는 `SqlService` 인터페이스의 구현 클래스가 필요하다. 그런데 언제 JAXB를 사용해 XML 문서를 가져와야 할까? DAO가 SQL을 요청할 때마다 XML 파일을 읽어서 찾는 건 너무 비효율적이다. 특별한 이유가 없는 한 XML 파일은 한 번만 읽어서 어딘가에 저장해두고, DAO에서 요청이 올 때마다 사용해야 한다. 우선 간단히 생성자에서 SQL을 읽어와 내부에 저장해두는 방법이 있겠다. DAO의 요청에 따라 SQL을 찾아서 전달하는 방식으로 `XmlSqlService` 클래스를 구현해보자.



``` java
public class XmlSqlService implements SqlService {

    private Map<String, String> sqlMap = new HashMap<>();

    public XmlSqlService() {
        String contextPath = Sqlmap.class.getPackage().getName();

        try {
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            InputStream is = UserDao.class.getResourceAsStream("/sqlmap.xml");
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(is);

            for(SqlType sqlType : sqlmap.getSql()) {
                sqlMap.put(sqlType.getKey(), sqlType.getValue());
            }
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }
}
```



생성자에서 XML 파일을 읽어서 맵에 젖아하고, 앞에서 만들었던 `SimpleSqlService` 와 동일한 방법으로 SQL을 맵에서 찾아서 돌려주는 `getSql()` 을 구현하면 된다.



하지만 생성자에서 예외가 발생할 수 있는 복잡한 초기화 작업을 다루는 것은 좋지 않다. 오브젝트를 생성하는 중에 생성자에서 발생하는 예외는 다루기 힘들고, 상속하기 불편하며, 보안에도 문제가 생길 수 있다. 일단 초기 상태를가진 오브젝트를 만들고, 별도의 초기화 메서드를 사용하는 것이 좋다.



``` java
public class XmlSqlService implements SqlService {

    private Map<String, String> sqlMap = new HashMap<>();
    private String sqlmapFile;

    public void setSqlmapFile(String sqlmapFile) {
        this.sqlmapFile = sqlmapFile;
    }

    @PostConstruct
    public void loadSql() {
        String contextPath = Sqlmap.class.getPackage().getName();

        try {
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            InputStream is = UserDao.class.getResourceAsStream(sqlmapFile);
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(is);

            for(SqlType sqlType : sqlmap.getSql()) {
                sqlMap.put(sqlType.getKey(), sqlType.getValue());
            }
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }
 }
```



스프링은 빈 오브젝트를 생성하고 DI 작업을 수행해서 프로머티를 모두 주입해준 뒤에 미리 지정한 초기화 메소드를 호출해주는 기능을 갖고 있다. 스프링은 `@PostConstruct` 어노테이션을 빈 오브젝트의 초기화 메서드를 지정하는데 사용한다. 



현재 `XmlSqlService` 클래스는 크게 두 가지 책임이 있다. 하나는 SQL 정보를 읽어오는 것이고, 또 다른 하나는 읽어온 SQL을 필요한 곳에 제공해주는 것이다. 추가로 한 번 가져온 SQL을 필요에 따라 수정할 수 있게 하는 기능도 생각해 볼 수 있다.



![/Untitled.png](https://www.myanglog.com/static/c62d96b70cddef2128d844ef6c3b36ee/7d769/Untitled.png)



`SqlService` 의 구현 클래스가 변경 가능한 책임을 가진 `SqlReader`와 `SqlRegistry` 두 가지 타입의 오브젝트를 사용하도록 만듦으로써 분리해낸다. 



`SqlReader`가 읽어오는 SQL 정보는 다시 `SqlRegistry` 에 전달해서 등록되게 해야 한다. `SqlReader`에게 `SqlRegistry` 전략을 제공해주면서 이를 이용해 SQL 정보를 `SqlRegistry`에 저장하라고 요청하면 된다.



``` java
public interface SqlRegistry {
  void registerSql(String key, String sql);
  
  String findSql(String key) throws SqlNotFoundException;
}
```



``` java
public interface SqlReader {
  void read(SqlRegistry sqlRegistry);
}
```



`SqlRegistry`와 `SqlReader`를 이용하는 가장 간단한 `SqlService` 구현 클래스를 만들어 보자.



``` java
public class BaseSqlService implements SqlService {
    private SqlReader sqlReader;
    private SqlRegistry sqlRegistry;

    public void setSqlReader(SqlReader sqlReader) {
        this.sqlReader = sqlReader;
    }

    public void setSqlRegistry(SqlRegistry sqlRegistry) {
        this.sqlRegistry = sqlRegistry;
    }

    // implement SqlSerivce
    @Override
    public String getSql(String key) throws SqlRetrievalFailureException {
        try {
            return sqlRegistry.findSql(key);
        } catch (SqlNotFoundException e) {
            throw new SqlRetrievalFailureException(e);
        }
    }

    @PostConstruct
    public void loadSql() {
        sqlReader.read(this.sqlRegistry);
    }
}
```



다음은 `HashMap` 을 이용해 SQL을 저장해두고 찾아주는 기능을 담당하는 코드를 `SqlRegistry` 를 구현하는 독립 클래스로 분리한 클래스이다.



``` java
public class HashMapSqlRegistry implements SqlRegistry {
    private final Map<String, String> sqlMap = new HashMap<>();

    @Override
    public void registerSql(String key, String vale) {
        sqlMap.put(key, vale);
    }

    @Override
    public String findSql(String key) throws SqlNotFoundException {
        String sql = sqlMap.get(key);
        if (sql == null) {
            throw new SqlRetrievalFailureException(key + "를 이용해서 SQL을 찾을 수 없습니다");
        }
        return sql;
    }
}
```



다음은 JAXB를 이용해 XML 파일에서 SQL 정보를 읽어오는 코드를 `SqlReader` 인터페이스의 구현 클래스로 독립시킬 클래스이다.



``` java
public class JaxbXmlSqlReader implements SqlReader {
    private String sqlMapFile;

    public void setSqlMapFile(String sqlMapFile) {
        this.sqlMapFile = sqlMapFile;
    }

    @Override
    public void read(SqlRegistry sqlRegistry) {
        String contextPath = Sqlmap.class.getPackage().getName();
        try {
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(getXmlFile(this.sqlMapFile));

            for (SqlType sql : sqlmap.getSql()) {
                sqlRegistry.registerSql(sql.getKey(), sql.getValue());
            }
        } catch (JAXBException e) {
            throw new RuntimeException(e);
        }
    }

    private File getXmlFile(String fileName) {
        ClassLoader classLoader = getClass().getClassLoader();
        return new File(classLoader.getResource(fileName).getFile());
    }
}
```



특정 의존 오브젝트가 대부분의 환경에서 거의 디폴트라고 할 만큼 기본적으로 사용된다면, **디폴트 의존 관계**를 갖는 빈을 만드는 것도 좋다. 디폴트 의존 관계란 외부에서 DI받지 않는 경우 기본적으로 자동 적용되는 의존 관계를 말한다. 다음과 같이 생성자에서 디폴트 의존 오브젝트를 직접 만들어서 스스로 DI 해주면 된다. 이렇게 코드를 통해 의존 관계의 오브젝트를 직접 주입해주면 특별히 DI가 필요한 상황이 아닌 경우 편리하게 사용 가능하다.



``` java
public class DefaultSqlService extends BaseSqlService {
    private static final String DEFAULT_SQLMAP_FILE = "sqlMapper.xml";
    private String sqlmapFile = DEFAULT_SQLMAP_FILE;

    public DefaultSqlService() {
        super();
        JaxbXmlSqlReader sqlReader = new JaxbXmlSqlReader();
        sqlReader.setSqlMapFile(sqlmapFile);
        setSqlReader(sqlReader);
        setSqlRegistry(new HashMapSqlRegistry());
    }
}
```



디폴트 의존 오브젝트를 사용하는 방법에는 단점이 하나 있다. 설정을 통해 다른 구현 오브젝트를 사용하게 되어도 `DefaultSqlService` 는 생성자에서 일단 디폴트 의존 오브젝트를 만들어 버린다는 점이다. 즉, 사용되지 않는 오브젝트가 만들어지는 것이다. 하지만 다른 장점이 더 크기 때문에 이러한 부담은 무시할 수도 있다. 만약 디폴트로 생성되는 오브젝트가 많은 리소스를 차지한다면, `@PostContstruct` 초기화 메서드를 이용해 프로퍼티가 설정됐는지 확인 후에 디폴트 오브젝트를 만들거나 만들지 않으면 된다.



### 7.3 서비스 추상화 적용

`JaxbXmlSqlReader` 를 다음 두 가지 측면에서 개선해보자.

첫째로, 자바에는 JAXB 외에도 다양한 XML과 자바 오브젝트를 매핑하는 기술이 있다. 따라서 필요에 따라 다른 기술로 바꿔서 사용할 수 있도록 해보자. 두 번째로, XML 파일을 다양한 소스에서 가져올 수 있도록 만들어보자.



JAXB가 JavaSE와 JavaEE 표준에 포함되어 있긴 하지만, Castor XML, JiBX, XmlBeans 등 다양한 XML-자바 오브젝트 매핑 기술이 있다. 위 기술들은 사용 목적이 동일하기 때문에 유사한 기능과 API를 제공한다. 따라서 로우 레벨의 구체적인 기술과 API에 종속되지 않고, 추상화된 레이어와 API를 제공해서 구현 기술에 대해 독립적인 코드를 작성할 수 있게 서비스 추상화를 도입하면 좋을 것 같다.



스프링이 제공하는 OXM 추상화 서비스 인터페이스에는 자바 오브젝트를 XML로 변환하는 `Marshaller`와, XML을 자바 오브젝트로 변환하는 `Unmarshaller`가 있다. `SqlReader`는 이 중에서 `Unmarshaller`를 사용하면 된다.



``` java
package org.springframework.oxm;
...
import javax.xml.transform.Source;

public interface Unmarshaller {
  boolean supports(Class<?> clazz);
  
  Object unmarshal(Source source) throws IOException, XmlMappingException;
}
```



XML 파일에 대한 정보를 담은 `Source` 타입의 오브젝트를 주면 설정에서 지정한 OXM 기술을 이용해 자바 오브젝트 트리로 반환하고, 루트 오브젝트를 돌려준다.OXM 기술에 따라 `Unmarshaller` 인터페이스를 구현한 다섯 개의 클래스가 있고, 각 클래스는 해당 기술에서 필요로 하는 추가 정보를 빈 프로퍼티로 지정할 수 있게 되어 있다.



스프링은 자바에 존재하는 일관성 없는 리소스 접근 API를 추상화해서 `Resource`라는 추상화 인터페이스를 정의했다.



``` java
package org.springframework.core.io;
...
public interface Resource extends InputStreamSource {
    boolean exists();
    boolean isReadable();
    boolean isOpen();

    URL getURL() throws IOException;
    URI getURI() throws IOException;
    File getFile() throws IOException;
  
    long contentLength() throws IOException;
    long lastModified() throws IOException;

    Resource createRelative(String var1) throws IOException;

    String getFilename();
    String getDescription();
}

```



애플리케이션 컨텍스트가 사용할 설정 정보 파일을 지정하는 것부터, 스프링의 거의 모든 API는 외부의 리소스 정보가 필요할 때 이 인터페이스 추상화를 사용한다.

스프링에서 `Resource`는 빈이 아닌 **값**으로 취급된다. OXM이나 트랜잭션처럼 서비스를 제공해주는 것이 아니라 단순한 정보를 가진 값으로 지정된다. 그래서 추상화하는 방법이 문제다. 외부에서 지정할 수 있는 경로가 `<property>`의 `value` 애트리뷰트에 넣는 방법밖에 없다. 



그래서 스프링에는 접두어를 이용해 `Resource` 오브젝트를 선언하는 방법이 있다. 그리고 문자열로 정의된 리소스를 실제 `Resource` 타입의 오브젝트로 변환해주는 `ResourceLoader` 인터페이스를 제공한다. 



```java
package org.springframework.core.io;

public interface ResourceLoader {
    String CLASSPATH_URL_PREFIX = "classpath:";
    Resource getResource(String location);
    ClassLoader getClassLoader();
}
```



다음 표는 `ResourceLoader`가 인식하는 접두어와, 이를 이용해 리소스를 표현한 예이다.



| 접두어       | 예                           | 설명                                                         |
| ------------ | ---------------------------- | ------------------------------------------------------------ |
| `file:`      | `file:/C:/tmep/file.txt`     | 파일 시스템의 C:/temp 폴더에 있는 file.txt를 리소스로 만들어 준다. |
| `classpath:` | `classpath:file.txt`         | 클래스패스의 루트에 존재하는 file.txt 리소스에 접근하게 해준다. |
| 없음         | `WEB-INF/test.dat`           | 접두어가 없는 경우에는 `ResourceLoader` 구현에 따라 리소스의 위치가 달라진다. |
| `http:`      | `http://server.com/test.dat` | HTTP 프로토콜을 사용해 접근할 수 있는 웹 상의 리소스를 지정한다. |



`ResourceLoader`의 대표적인 예는 스프링의 애플리케이션 컨텍스트다. 애플리케이션 컨텍스트가 구현해야 하는 인터페이스인 `ApplicationContext`는 `ResourceLoader` 인터페이스를 상속하고 있다. 따라서 모든 애플리케이션 컨텍스트는 리소스 로더이기도 하다. 스프링 컨테이너는 리소스 로더를 다양한 목적으로 사용하고 있기 때문이다. 애플리케이션 컨텍스트가 사용할 스프링 설정 정보가 담긴 XML 파일도 리소스 로더를 이용해 `Resource` 형태로 읽어 온다.



### 7.4 인터페이스 상속을 통한 안전한 기능 확장



스프링에서 DI 개념은 매우 중요하다. 그리고 DI를 적용하는 것은 생각보다 어렵지 않다. 하지만 DI의 가치를 제대로 누리기 위해선 많은 고민과 훈련이 필요하다. 의존 관계를 갖는 두 개 이상의 오브젝트를 적절한 책임에 따라 나누어야 하고, 항상 확장을 염두에 두어야 한다.

확장은 항상 미래에 발생한다. DI는 확장을 위한 것이므로 결국 미래를 프로그래밍 하는 것이다.



DI를 적용할 때는 가능한 한 인터페이스를 사용해야 한다. 

첫 번째 이유는 **다형성을 얻기 위해서**다. 하나의 인터페이스를 통해 여러 개의 구현을 바꿔가면서 사용할 수 있도록 하는 것이 DI가 추구하는 목적이다.

두 번째 이유는 **인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확히 해줄 수 있기 때문**이다. A라는 클라이언트와 B1 인터페이스를 구현하는 B라는 의존 오브젝트가 있다고 쳤을 때, A에게 B는 B1이라는 관심사를 구현한 임의의 오브젝트에 불과하다. A는 B1이라는 창을 통해서만 B를 바라본다는 의미이다. 만약 B가 B2라는 인터페이스도 함께 구현하고 있다면, A 의 입장에서는 B라는 클래스에 직접 의존할 이유가 없다.



오브젝트가 그 자체로 충분히 응집도가 높은 작은 단위로 설계되었더라도, 목적과 관심이 다른 클라이언트가 있다면 인터페이스를 통해 이를 적절히 분리해줄 필요가 있다. 이를 **인터페이스 분리 원칙**이라고 한다. 만약 위의 경우에서 인터페이스를 사용하지 않고 클래스를 직접 참조하는 방식으로 DI를 했다면, 특정 클라이언트에 특화된 의존 관계를 만드는 것 자체가 불가능하다.



오브젝트의 기능이 발전하면 다른 종류의 클라이언트가 등장하기 마련이다. 이럴 때는 새로운 인터페이스를 만드는 것 대신 기존 인터페이스를 상속을 통해 확장하는 방법도 있다.



인터페이스 분리 원칙의 장점은 모든 클라이언트가 자신의 관심에 따른 접근 방식을 불필요한 간섭없이 유지할 수 있다는 점이다. 따라서 기존 클라이언트에 영향없이 오브젝트의 기능을 확장/수정할 수 있다.





### 7.5 DI를 이용해 다양한 구현 방법 적용하기 625~644





### 7.6 스프링 3.1의 DI 645~709

