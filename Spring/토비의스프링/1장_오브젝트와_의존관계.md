스프링은 스프링 컨테이너(애플리케이션 컨텍스트)라는 스프링 런타임 엔진을 제공한다. 스프링 컨테이너는 설정 정보를 참고해서 애플리케이션을 구성하는 오브젝트를 생성 및 관리.스프링 컨테이너는 독립적으로 동작할 수도 있지만, 보통 웹 모듈에서 동작하는 서비스나 서블릿으로 등록해서 사용한다.



애플리케이션 코드가 어떻게 작성되어야 하는지에 대한 틀을 프로그래밍 모델이라고 하는데, 스프링은 세 가지의 핵심 프로그래밍 모델을 지원한다.

1. IoC/DI - 오브젝트의 생명 주기와 의존 관계에 대한 프로그래밍 모델이다. IoC/DI 방식을 따라서 코드가 작성되어야 스프링이 제공하는 가치를 제대로 누릴 수 있다.
2. 서비스 추상화 - 구체적인 기술과 환경에 종속되지 않도록 유연한 추상 계층을 두는 방법이다.
3. AOP - 코드 상에 있는 부수적인 기능을 따로 떼어내서 독립적인 모듈화하는 방법이다.



스프링은 엄청난 양의 기술 API를 제공한다. UI 작성부터 웹 프레젠테이션 계층, 비즈니스 서비스 계층, 도메인 계층 등등.. 



스프링을 사용한다는 것은 위의 세 가지 요소를 적극 활용해서 애플리케이션을 개발한다는 의미이다. 클래스는 스프링 컨테이너 위에서 오브젝트로 만들어져 동작하고, 코드는 위의 프로그래밍 모델을 따라서 작성하고, 엔터프라이즈 기술을 사용할 때는 스프링이 제공하는 기술 API와 서비스를 활용하도록 해주면 된다.



## 1장 오브젝트와 의존관계

스프링의 기본 철학은 `객체지향 프로그래밍이 제공하는 혜택을 누릴 수 있도록 하자`이다. 그래서 스프링이 가장 관심을 많이 두는 대상은 **오브젝트**이다. 



### 1.1 초난감 DAO

사용자 정보를 저장하는 User DAO를 생성하고, 데이터베이스에 Users 테이블도 생성해보자. Setter Getter 는 작성하기 귀찮으니깐 Lombok을 사용하고, 데이터베이스는 H2를 사용한다.



**User 클래스**

```java
package springbook.user.domain;

import lombok.Data;

@Data
public class User {

  String id;
  String name;
  String password;
}

```



**users 테이블**

``` sql
create table users (
  id varchar(10) primary key,
  name varchar(20) not null,
  password varchar(10) not null
)
```



참고로 원래 자바빈이라고 하면, 비주얼 툴에서 조작 가능한 컴포넌트를 의미했는데, 이제는 다음 두 가지 관례를 따라서 만들어진 오브젝트를 의미한다.

- 디폴트 생성자 - 다른 툴이나 프레임워크에서 리플렉션을 이용해서 오브젝트를 생성하기 때문에 디폴트 생성자가 필요하다.
- 프로퍼티 - 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 Setter 와 Getter 를 이용해 수정/조회할 수 있다.



다음으로 사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스를 만들어보자. DAO는 Data Access Object 의 약자로 DB를 사용해서 데이터를 CRUD 기능을 하는 오브젝트를 말한다.



오랜만에 JDBC를 써본다.

Jdbc 드라이버는 pom.xml 에 추가했고, 도커에 mysql 이미지를 하나 만들어서 사용했다.



``` java
public void add(User user) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.cj.jdbc.Driver");
    Connection conn = DriverManager.getConnection("jdbc:mysql://0.0.0.0:9876/springbook", "spring", "book");

    PreparedStatement ps = conn.prepareStatement(
        "insert into users(id, name, password) values(?,?,?)");
    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());

    ps.executeUpdate();

    ps.close();
    conn.close();
  }


  public User get(String id) throws ClassNotFoundException, SQLException {
    Class.forName("org.h2.Driver");
    Connection conn = DriverManager.getConnection("jdbc:mysql://0.0.0.0:9876/springbook", "spring", "book");

    PreparedStatement ps = conn.prepareStatement("select * from users where id = ?");
    ps.setString(1, id);

    ResultSet rs = ps.executeQuery();
    rs.next();
    User user = User.builder()
        .id(rs.getString("id"))
        .name(rs.getString("name"))
        .password(rs.getString("password"))
        .build();

    rs.close();
    ps.close();
    conn.close();

    return user;
  }
```



이 DAO 가 제대로 동작하는지 테스트해보기 위해 테스트용 `main( )` 메서드를 만들어 테스트해보겠다.

``` java
public static void main(String[] args) throws SQLException, ClassNotFoundException {
    UserDao dao = new UserDao();

    User user = User.builder()
        .id("yoon1fe")
        .name("yoon1fe")
        .password("1234")
        .build();

    dao.add(user);

    System.out.println(user.getId() + " 등록 성공!");

    User user2 = dao.get(user.getId());
    System.out.println(user2.getName());
    System.out.println(user2.getPassword());

    System.out.println(user2.getId() + " 조회 성공!");

  }
```



![image-20220113231610658](/Users/nhn/Library/Application Support/typora-user-images/image-20220113231610658.png)



잘된다.



하지만 위에서 짠 코드는 그지같은 코드다. 이제부터 이 그지같은 초난감 DAO 클래스를 스프링 스타일로 바꿔보자.



### 1.2 DAO의 분리

분리와 확장을 고려한 설계가 중요하다.

모든 변경과 발전은 한 번에 한 가지의 관심사항에 집중해서 일어난다. 하지만 문제는 이러한 변경을 위한 작업이 한 곳에 집중되지 않는다는 점이다. 만약 DB 접속용 비밀번호를 변경한다면, 위에 있는 `get()`, `add()` 모두 변경해주어야 한다. 이를 막기 위해 같은 관심사를 갖는 것들끼리 모아야 한다. 프로그래밍의 기초 개념 중에 **관심사의 분리**라는 것이 있는데, 이의 기본 개념이라고 할 수 있겠다.



다시 `UserDao` 클래스로 돌아가보자면, `add()` 메서드 하나에서만 최소 세 가지의 관심사항이 있다.

- DB 연결을 위한 커넥션을 어떻게 가져올까
- 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 `Statement`를 만들고 실행하는 것
- 작업이 끝나면 사용한 리소스인 `Statement`와 `Connection` 오브젝트를 닫는 것



위에서 말했듯이 `get()`, `add()` 메서드에 DB 커넥션을 가져오는 코드가 중복되어 있다. DB에 CRUD 를 하는 메서드가 많아질수록 엉망진창 스파게티 코드가 될 것이다.



이렇게 중복된 코드는 `getConnection()` 이란 독립적인 메서드로 만들어준다.



``` java
private Connection getConnection() throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.cj.jdbc.Driver");
    return DriverManager.getConnection("jdbc:mysql://0.0.0.0:9876/springbook", "spring", "book");
  }
```



여러 방식으로 DB 커넥션을 가져오려고 한다면, `getConnection()` 메서드를 추상 메서드로 만들고, 이를 상속받아 각각 필요한대로 서브 클래스를 만들면 된다.

이런 식으로 슈퍼 클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메서드나 오버라이딩이 가능한 `protected` 메서드 등으로 만든 뒤, 서브 클래스에서 이런 메서드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 **템플릿 메서드 패턴**이라고 한다.



### 1.3 DAO의 확장

하지만 관심사 분리를 위해 상속이란 방법을 사용하는 것은 그리 좋지 못한 방법이다. 슈퍼 클래스와 서브 클래스가 높은 결합도를 갖기 때문이다. 그래서 아예 다른 클래스로 만들 수 있다.



``` java
package springbook.user.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class SimpleConnectionMaker {
  public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.cj.jdbc.Driver");
    return DriverManager.getConnection("jdbc:mysql://0.0.0.0:9876/springbook", "spring", "book");
  }

}
```



`SimpleConnectionMaker` 클래스는 상태를 관리하는 것이 아니기 때문에 한 번만 생성해서 인스턴스 변수에 저장해두고 메서드에서 사용하도록 한다.



``` java
public class UserDao {

  private SimpleConnectionMaker simpleConnectionMaker;

  public UserDao() {
    simpleConnectionMaker = new SimpleConnectionMaker();
  }
  
  ...
```



하지만 이런 경우 위에서 해결했던 다양한 DB 접속 방식을 제공해주지 못한다. 이를 인터페이스를 도입함으로써 해결할 수 있다.



``` java
package springbook.user.dao;

import java.sql.Connection;
import java.sql.SQLException;

public interface ConnectionMaker {
  
  public Connection makeConnection() throws ClassNotFoundException, SQLException;

}
```



`ConnectionMaker` 란 인터페이스를 만들고, 이를 구현하는 `AConnectionMaker` 란 클래스를 만들었다. 그러면 `UserDao` 클래스에선 다음과 같이 인스턴스를 만든다.



``` java
public class UserDao {

  private ConnectionMaker connectionMaker;

  public UserDao() {
    connectionMaker = new AConnectionMaker();
  }
  
  ...
```



`UserDao` 클래스에서 결국 구현체 클래스(`AConnectionMaker`)에 대한 정보가 포함되었다. 즉, 어떤 `ConnecitonMaker` 구현 클래스를 사용할지 결정하는 코드가 남아 있는 것이다. 그 이유는 `UserDao` 안에 여전히 다른 관심사항이 존재하고 있기 때문이다.



현재는 `UserDao` 와 `AConnectionMaker` 가 불필요한 의존 관계를 갖고 있다. `UserDao` 는 `ConnectionMaker` 하고만 의존 관계를 갖고 있으면 된다. `UserDao` 오브젝트가 `AConnectionMaker` 오브젝트를 사용하게끔 하려면, 두 클래스의 오브젝트 사이에 런타임 사용 관계 또는 링크, 또는 의존 관계라고 불리는 관계를 맺어주면 된다. 이러한 관계는 `UserDao` 를 사용하는 클라이언트 클래스가 맺어준다.



현재 코드 상에서는 `main()` 메서드가 클라이언트인데, `UserDaoTest` 클래스를 만들고 여기로 옮겨보자. 그리고 `UserDao` 의 생성자는 파라미터로 `ConnectionMaker` 의 오브젝트를 전달받을 수 있도록 수정한다. 클라이언트가 미리 만들어 놓은 `ConnectionMaker` 의 구현체를 전달할 것이다.



``` java
public class UserDao {

  private ConnectionMaker connectionMaker;

  public UserDao(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
  }
	
  ...
```



``` java
package springbook.user.dao;

import java.sql.SQLException;
import springbook.user.domain.User;

public class UserDaoTest {

  public static void main(String[] args) throws SQLException, ClassNotFoundException {
    ConnectionMaker connectionMaker = new AConnectionMaker(); // 클라이언트가 구현체를 결정하고 오브젝트를 만든다

    UserDao dao = new UserDao(connectionMaker);

    User user = User.builder()
        .id("yoon1fe")
        .name("yoon1fe")
        .password("1234")
        .build();

    dao.add(user);

    System.out.println(user.getId() + " 등록 성공!");

    User user2 = dao.get(user.getId());
    System.out.println(user2.getName());
    System.out.println(user2.getPassword());

    System.out.println(user2.getId() + " 조회 성공!");

  }
}
```



### 1.4 제어의 역전(IoC)

`UserDaoTest` 도 아직 다른 책임을 갖고 있다. `ConnectionMaker` 의 구현체를 결정하는 부분이다. 이것도 분리하자.



분리시킬 기능을 담당할 클래스를 만드는데, 이 클래스의 역할은 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것이다. 이런 일을 하는 오브젝트를 흔히 팩토리라고 부른다.



`UserDaoTest` 에 담겨 있던 `UserDao`, `ConnectionMaker`생성 작업을 `DaoFactory`로 옮긴다.

``` java
package springbook.user.dao;

public class DaoFactory {
  
  public UserDao userDao() {
    ConnectionMaker connectionMaker = new AConnectionMaker();
    return new UserDao(connectionMaker);
  }

}
```



``` java
public class UserDaoTest {

  public static void main(String[] args) throws SQLException, ClassNotFoundException {

    UserDao dao = new DaoFactory().userDao();

    ...
```



만약 다른  `DAO`가 추가된다면 `ConnectionMaker` 구현 클래스를 선정하고 생성하는 코드가 중복될 수 있다. 중복 문제를 해결하려면 분리해내는 것이 가장 좋다.



``` java
package springbook.user.dao;

public class DaoFactory {

  public UserDao userDao() {
    ConnectionMaker connectionMaker = new AConnectionMaker();
    return new UserDao(connectionMaker());
  }

  public AccountDao accountDao() {
    ConnectionMaker connectionMaker = new AConnectionMaker();
    return new AccountDao(connectionMaker());
  }

  public MessageDao messageDao() {
    ConnectionMaker connectionMaker = new AConnectionMaker();
    return new MessageDao(connectionMaker());
  }
  
  public ConnectionMaker connectionMaker() {
    return new AConnectionMaker();
  }

}
```



IoC(Inversion of Control, 제어의 역전)을 간단히 설명하자면, 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다. `UserDao` 를 테스트하는 흐름을 보면, `main()`메서드에서 `UserDao` 클래스의 오브젝트를 직접 생성하고, 만들어진 오브젝트의 메서드를 사용한다. `UserDao` 또한 자신이 사용할 `ConnectionMaker` 의 구현체를 결정하고, 생성해둔다. 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 만들지를 결정한다. 즉, 모든 종류의 작업을 **사용하는 쪽에서 제어**한다.



제어의 역전이란 이런 제어 흐름을 뒤집는 것이다. 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하거나 생성하지 않는다.



### 1.5. 스프링의 IoC





### 1.6 싱글톤 레지스트리와 오브젝트 스코프





### 1.7 의존관계 주입(DI)





### 1.8 XML을 이용한 설정





### 1.9 정리









