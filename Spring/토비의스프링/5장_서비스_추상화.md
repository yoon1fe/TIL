이번 장에서는 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 살펴본다.



### 5.1 사용자 레벨 관리 기능 추가

지금 `UserDao` 는 `User` 오브젝트에 대한 간단한 CRUD 기능만 제공했다. 여기에 간단한 비즈니스 로직을 추가해보자. 다수의 회원이 가입할 수 있는 인터넷서비스의 사용자 관리 모듈에 적용한다고 생각해본다. 사용자 관리 기능에는 정보를 넣고 검색히는 것 외에, 조건에 따라 사용자의 레벨을 변경하는 기능을 추가한다.



먼저 사용자의 등급을 나타내는 `Level` enum을 정의한다. 아래와 같이 만들어진 `Level` enum은 내부에는 DB에 저장할 `int` 타입의 값을 갖고 있지만, 겉으로는 `Level` 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다.



```java
package springbook.user.domain;

public enum Level {
  BASIC(1), SILVER(2), GOLD(3);

  private final int value;

  Level(int value) {
    this.value = value;
  }

  public int intValue() {
    return value;
  }

  public static Level valueOf(int value) {
    switch (value) {
      case 1: return BASIC;
      case 2: return SILVER;
      case 3: return GOLD;
      default: throw new AssertionError("Unknown value: " + value);
    }
  }
}
```



`User` 클래스와 테이블에도 필드를 추가한다.



```java
package springbook.user.domain;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class User {

  String id;
  String name;
  String password;

  Level level;
  int login;
  int recommend;

}
```





사용자 관리 비즈니스 로직에 따르면 사용자 정보는 여러 번 수정될 수 있다. 따라서 수정용 DAO 메서드를 여러 개 만들어 놓는 것이 좋다. 다음과 같이 테스트 코드를 작성하고 테스트 코드를 성공시킬 `update()` 메서드를 작성한다.

```java
@Test
public void update() {
  dao.deleteAll();

  dao.add(user1);

  user1.setName("wow");
  user1.setPassword("123456");
  user1.setLevel(Level.GOLD);
  user1.setLogin(1000);
  user1.setRecommend(999);
  dao.update(user1);

  User user1update = dao.get(user1.getId());
  checkSameUser(user1, user1update);
}
```



```java
@Override
public void update(User user) {
  this.jdbcTemplate.update(
      "update users set name = ?, password = ?, level = ?, login = ?, recommend = ? "
          + "where id = ? ",
      user.getName(), user.getPassword(), user.getLevel().intValue(), user.getLogin(), user.getRecommend(), user.getId());
}
```



`JdbcTemplate`의 `update()` 메서드는 UPDATE나 DELETE와 같이 테이블의 내용에 영향을 주는 SQL을 실행하면 영향받은 로우의 개수를 리턴한다. 이 값을 확인하여 수정되어야 할 로우가 제대로 수정되었는지 확인할 수 있다.



레벨 관리 기능은 `UserDao`의 `getAll()` 메서드로 사용자를 다 가져와서 사용자별로 레벨 업그레이드 작업을 진행하면서 `update()` 를 호출하면 된다. DAO는 말그대로 데이터를 어떻게 가져오고 조작할지를 다루는 클래스이므로 비즈니스 로직을 담을 서비스 클래스를 추가한다.



```java
public class UserService {

  UserDao userDao;

  public void upgradeLevels() {
    List<User> users = userDao.getAll();
    
    for (User user : users) {
      Boolean changed = null;
      
      if (user.getLevel() == Level.BASIC && user.getLogin() >= 50) {
        user.setLevel(Level.SILVER);
        changed = true;
      } else if (user.getLevel() == Level.SILVER && user.getRecommend() >= 30) {
        user.setLevel(Level.GOLD);
        changed = true;
      } else if (user.getLevel() == Level.GOLD) {
        changed = false;
      } else {
        changed = false;
      }
      
      if (changed) {
        userDao.update(user);
      }
    }
  }
}
```



테스트 방법을 생각해보자. 가능한 모든 조건을 하나씩은 확인해보아야 한다. 발생할 수 있는 다섯 경우를 등록해두고 업그레이드를 진행한 후에 원하는 결과가 나오는지 확인한다.



```java
@Test
public void upgradeLevels() {
  userService.userDao.deleteAll();
  for (User user : users) userService.userDao.add(user);

  userService.upgradeLevels();

  checkLevel(users.get(0), Level.BASIC);
  checkLevel(users.get(1), Level.SILVER);
  checkLevel(users.get(2), Level.SILVER);
  checkLevel(users.get(3), Level.GOLD);
  checkLevel(users.get(4), Level.GOLD);
}

private void checkLevel(User user, Level expectedLevel) {
  User userUpdate = userService.userDao.get(user.getId());
  assertThat(userUpdate.getLevel(), is(expectedLevel));
}
```



다음으로는 처음 가입하는 사용자는 디폴트로 `BASIC` 레벨을 갖는다는 부분을 구현한다. 이는 여러 방식으로 구현할 수 있다. `User` 클래스에서 아예 `level` 필드를 `Level.BASIC` 으로 초기화할 수도 있다. 하지만 처음 가입할 때를 제외하면 무의미한 정보이기 때문에 이 로직만을 위해 클래스에서 직접 초기화하는 것은 문제가 있을 수 있다. `UserService` 에도 `add()` 메서들를 두어 사용자가 등록될 때 적용할 만한 비즈니스 로직을 담으면 좋겠다.

테스트 케이스는 레벨이 미리 정해진 경우와 레벨이 비어 있는 두 가지 경우가 있겠다.

```java
@Test
public void add() {
  userDao.deleteAll();

  User userWithLevel = users.get(4);
  User userWithoutLevel = users.get(0);
  userWithoutLevel.setLevel(null);
  
  userService.add(userWithLevel);
  userService.add(userWithoutLevel);
  
  User userWithLevelRead = userDao.get(userWithLevel.getId());
  User userWithoutLevelRead = userDao.get(userWithoutLevel.getId());
  
  assertThat(userWithLevelRead.getLevel(), is(userWithLevel.getLevel()));
  assertThat(userWithoutLevelRead.getLevel(), is(userWithoutLevel.getLevel()));
}
```



지금 `upgradeLevels()` 메서드는 성격이 다른 여러 로직이 섞여 있어서 로직을 이해하기 쉽지 않다. 만약 레벨이 추가된다면, `if` 문도 추가되어야 한다. 이 메서드는 시간이 지날수록 점점 길어지고 복잡해질 것이다. 아직은 별로 복잡해 보이지 않고, 요구사항을 잘 처리하는 코드인 것 같지만, 따져보면 변화에 굉장히 취약하고 다루기 힘든 코드인 것이다. 따라서 얘를 리팩토링 해보자. 기본적인 작업 흐름을 만들어보자면 다음과 같다.

```java
  public void upgradeLevels() {
    List<User> users = userDao.getAll();
    
    for (User user : users) {
      if (canUpgradeLevel(user)) {
        upgradeLevel(user);
      }
    }
  }
```



그리고 `canUpgradeLevel()` 메서드에서는 주어진 `user` 에 대해 레벨 업그레이드 여부를 따져보면 된다.

```java
private boolean canUpgradeLevel(User user) {
  Level currentLevel = user.getLevel();
  
  switch (currentLevel) {
    case BASIC: return (user.getLogin() >= 50);
    case SILVER: return (user.getRecommend() >= 30);
    case GOLD: return false;
    default: throw new IllegalArgumentException("Unkown Level: " + currentLevel);
  }
}
```



다음으로 업그레이드 조건을 만족했을 때 무언가를 하는 `upgradeLevel()` 메서드를 만들어보자. 사용자의 레벨을 상위 레벨로 바꾸는 것과 변경 사항을 DB에 업데이트해주면 된다.

```jade
private void upgradeLevel(User user) {
  if (user.getLevel() == Level.BASIC) user.setLevel(Level.SILVER);
  else if (user.getLevel() == Level.SILVER) user.setLevel(Level.GOLD);
  
  userDao.update(user);
}
```



`upgradeLevel()` 메서드에는 다음 레벨이 무엇인지에 대한 정보가 들어가 있다. 이 정보를 `Level` 에 두는 것이 더 좋겠다.

```java
package springbook.user.domain;

public enum Level {
  GOLD(3, null), SILVER(2, GOLD), BASIC(3, SILVER);

  private final int value;
  private final Level next;

  ...
}
```



추가로, 사용자 정보가 바뀌는 부분은 `UserService` 의 메서드에서 `User` 로 옮긴다. `User` 의 내부 정보가 변경되는 것이기 때문에 `User` 가 스스로 다루는 것이 적절하기 때문이다.



```java
public void upgradeLevel() {
  Level nextLevel = this.level.nextLevel();
  
  if (nextLevel == null) {
    throw new IllegalArgumentException(this.level + "은 업그레이드가 불가능합니다.");
  }
  
  this.level = nextLevel;
}
```



이처럼 각 오브젝트와 메서드가 각각 자신의 책임에 충실한 기능을 갖고 있다면 코드를 이해하기도 쉽고, 변경이 필요할 때 어디를 수정해야 할지도 쉽게 알 수 있다. 잘못된 요청이나 작업을 시도했을 때 이를 확인하고 예외를 던져줄 준비도 되어 있다. 또한, 독립적으로 테스트를 만들면 테스트 코드도 단순해진다.

객체지향 프로그래밍에서는 오브젝트에게 데이터를 요구하지 말고 작업을 해달라고 요청하는 것이 가장 기본이 되는 원리이다. 따라서 `UserService` 의 `upgradeLevels()`메서드에서 직접 `User` 오브젝트의 값을 변경하는 것이 아니라 `User` 에게 "레벨 업그레이드 작업을 해달라"고 요청하고, 또 `User` 는 `Level` 에게 "다음 레벨이 무엇인지 알려달라"고 요청하는 방식으로 동작하게 하는 것이 바람직하다.



레벨 업그레이드 정책을 유연하게 변경할 수 있도록 개선이 필요하다면 이러한 사용자 업그레이드 정책을 `UserService`에서 분리하고, 정책을 담은 오브젝트를 DI를 통해 `UserService` 에 주입하는 것이 좋다. 다른 정책을 적용할 때마다 매번 사용자 관리에 대한 비즈니스 로직을 수정하는 것은 번거롭고 위험한 방법이다.



### 5.2 트랜잭션 서비스 추상화



### 5.3 서비스 추상화와 단일 책임 원칙



### 5.4 메일 서비스 추상화