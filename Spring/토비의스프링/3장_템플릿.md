개방 폐쇄 원칙`OCP` 은 확장에는 열려 있고, 변경에는 닫혀 있다는 객체지향 설계의 핵심 원칙이다. 어떤 코드는 변경을 통해 그 기능을 확장하려는 성질이 있고, 또 어떤 부분은 고정되어 있어 변하지 않으려는 성질이 있다. 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적에 의해 다른 시점에 독립적으로 변경될 수 있는 구조를 만들어 주는 것이 바로 개방 폐쇄 원칙의 핵심이다.

템플릿이란 일정한 패턴으로 유지되는 부분을, 자유롭게 변경되는 부분으로부터 독립시켜 효과적으로 활용할 수 있도록 하는 방법이다.



### 3.1 다시 보는 초난감 DAO

기존 `UserDao` 코드는 아직 불완전하다. 예외상황에 대한 처리가 없다는 문제점이 있다. DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 도중에 예외가 발생했을 경우에 리소스를 반환할 필요가 있다. 그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.



예외상황에서 리소스를 제대로 반환할 수 있도록 `try/catch/finally` 를 보통 많이 썼지만, Java 7부터 제공하는 `try-with-resources` 문법을 사용하면 더욱 간단히 리소스를 반환할 수 있다.

`try-with-resources` 문법을 사용해서 `deleteAll()` 메서드를 다음과 같이 수정할 수 있다.



```java
  public void deleteAll() throws SQLException {
    try (Connection conn = dataSource.getConnection();
        PreparedStatement ps = conn.prepareStatement("delete from users")
    ) {
      ps.executeUpdate();
    }
  }
```



참고로 `get()` 메서드와 같이 `PreparedStatement` 의 값을 세팅해줘야 하는 경우에는 다음과 같이 해주면 된다.



```java
public User get(String id) throws SQLException {
  try (
      Connection conn = dataSource.getConnection();
      PreparedStatement ps = conn.prepareStatement("select * from users where id = ?");
  ) {
    ps.setString(1, id);
    try (
        ResultSet rs = ps.executeQuery();
    ) {
      User user = null;
      if (rs.next()) {
        user = User.builder()
            .id(rs.getString("id"))
            .name(rs.getString("name"))
            .password(rs.getString("password"))
            .build();
      }

      if (user == null) {
        throw new EmptyResultDataAccessException(1);
      }

      return user;
    }
  }
}
```



### 3.2 변하는 것과 변하지 않는 것

이제 여기서 변하지 않지만 많은 곳에서 중복되는 코드와, 로직에 따라 확장되고 변경되는 코드를 분리해내는 작업을 해보자.

먼저 `deleteAll()` 메서드에서 변하지 않는 부분과 변하는 부분을 분리해보자면, 변하는 부분은 쿼리 부분이고 변하지 않는 부분은 쿼리 부분을 제외한 나머지라고 할 수 있겠다. `add()` 메서도 마찬가지로 `PreparedStatement` 를 세팅하는 부분이 변하는 부분이고, 나머지는 변하지 않는 부분이다. 그럼 이처럼 로직에 따라서 변하는 부분을 변하지 않는 나머지 코드에서 분리하는 것이 좋겠다.



**전략 패턴**이란, 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 패턴이다. 이는 개방 폐쇄 원칙을 잘 지키는 구조이면서 템플릿 메서드 패턴보다 유연하고 확장성이 뛰어나다.



![](https://media.vlpt.us/images/y_dragonrise/post/01b02920-5e7d-4a90-b5be-7cdfe0f6091d/image.png)





`Context` 의 `contextMethod()`에서 일정한 구조를 가지고 동작하다가, 특정 확장 기능은 `Strategy` 인터페이스를 통해 외부의 독립된 전략 클래스에 위임하는 것이 전략 패턴의 구조이다.

`UserDao` 클래스에서는 `deleteAll()` 메서드에서 변하지 않는 부분이라고 명시한 것이 `contextMethod()` 가 되고, `PreparedStatement` 를 만들어주는 외부 기능이 바로 전략 패턴에서 말하는 **전략**이 된다.

`PreparedStatement` 를 만드는 전략 인터페이스는 컨텍스트가 만들어둔 `Connection` 을 전달받아서, `PreparedStatement` 를 만들고, 만들어진 `PreparedStatement` 오브젝트를 반환한다.

```java
package springbook.user.dao;

...

public interface StatementStrategy {
  
  PreparedStatement makePreparedStatement(Connection c) throws SQLException;

}
```



그리고 위의 인터페이스를 상속해서 실제 전략, 즉 `PreparedStatement` 를 생성하는 구현체 클래스는 다음과 같다.



```java
package springbook.user.dao;

...

public class DeleteAllStatement implements StatementStrategy {

  @Override
  public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    return c.prepareStatement("delete from users");
  }
}
```



```java
public void deleteAll() throws SQLException {
  try (Connection conn = dataSource.getConnection()) {
    StatementStrategy strategy = new DeleteAllStatement();
    
    try (PreparedStatement ps = strategy.makePreparedStatement(conn)) {
      ps.executeUpdate();
    }
  }
}
```



하지만, 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지(폐쇄)되면서 전략을 바꿔(개방) 쓸 수 있다는 것인다, 이렇게 컨텍스트 안에서 이미 구체적인 전략 클래스`DeleteAllStatement` 가 명시되어 있다면 전략 패턴에도, OCP 에도 잘 맞다고 볼 수 없다.



전략 패턴에 따르면, `Context` 가 어떤 전략을 사용할지는 `Context` 를 사용하는 앞단의 클라이언트가 결정하는 것이 일반적이다. 이는 1장에서 `UserDao` 와 `ConnectionMaker` 를 분리할 때, `UserDao` 가 구체적인 `ConnectionMaker` 의 구현 클래스를 만들어 사용하는 것이 문제가 있다고 판단했을 때 적용했던 방법과 동일하다. 전략 오브젝트 새엇ㅇ과 컨텍스트로의 전달을 담당하는 책임을 분리시킨 것이 `ObjectFactory`이고, 이를 일반화한 것이 DI이다. 즉, DI란 이러한 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조라고 볼 수 있다.



컨텍스트를 메서드로 분리하면 다음과 같다.



```java
public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException {
  try (
      Connection conn = dataSource.getConnection();
      PreparedStatement ps = stmt.makePreparedStatement(conn);
  ) {
    ps.executeUpdate();
  }
}
```



이렇게 컨텍스트를 별도의 메서드로 분리했기 때문에 `deleteAll()`메서드가 이를 사용하는 클라이언트가 된다. 즉, `deleteAll()` 메서드는 전략 오브젝트를 만들고 컨텍스트를 호출하는 책임이 있다.







```java
public void deleteAll() throws SQLException {
  StatementStrategy strategy = new DeleteAllStatement();
  jdbcContextWithStatementStrategy(strategy);
}
```







### 3.3 JDBC 전략 패턴의 최적화

이제 `add()` 메서드에도 적용해보자. `DeleteAllStatement` 클래스와 마찬가지로 `AddStatement` 클래스에 `PreparedStatement` 를 옮겨 담는다.



```java
package springbook.user.dao;

...
  
public class AddStatement implements StatementStrategy {

  @Override
  public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
    
    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());
    
    return ps;
  }
}
```



그럼 여기서 `user` 는 어디서 가져와야 할까? 등록할 사용자에 대한 정보는 클라이언트에 해당하는 `add()` 메서드가 갖고 있다. 따라서 클라이언트로부터 `User` 타입의 오브젝트를 받을 수 있도록 `AddStatement` 에서 생성자를 통해 제공받는 코드를 추가한다.



```java
public class AddStatement implements StatementStrategy {
  
  User user;
  
  public AddStatement(User user) {
    this.user = user;
  }
  
  ...
  
}
```



```java
public class UserDao {

  ...
    
  public void add(User user) throws SQLException {
    StatementStrategy st = new AddStatement(user);
    jdbcContextWithStatementStrategy(st);
  }
  
  ...
    
}
```





구조가 많이 개선되었지만, 현대 만들어진 구조에 두 가지 불만이 있다. 

1. DAO 메서드마다 새로운 `StatementStrategy` 구현 클래스를 만들어야 한다는 점
2. DAO 메서드에서 `StatementStrategy` 에 전달할 (`add()` 에서의  `User` 와 같은) 부가 정보가 있을 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 만들어야 하는 번거로움



첫번째 문제점은 `StatementStrategy` 전략 클래스를 `UserDao` 클래스 안에 내부 클래스로 정의함으로써 해결할 수 있다. 특정 메서드에서만 사용되는 것이라면 메서드 내에 **로컬 클래스**로 만들 수도 있다. 로컬 변수를 선언하듯이 로컬 클래스를 메서드 안에서 선언하는 것이다. 로컬 클래스는 선언된 메서드 내에서만 사용할 수 있다. 또한, `add()` 의 `user`와 같은 메서드의 로컬 변수에 직접 접근할 수도 있다. 다만, 내부 클래스에서 외부의 변수를 사용할 때는 외부 변수는 반드시 `final` 로 선언해주어야 한다.



```java
public void add(User user) throws SQLException {
  class AddStatement implements StatementStrategy {

    @Override
    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
      PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");

      ps.setString(1, user.getId());
      ps.setString(2, user.getName());
      ps.setString(3, user.getPassword());

      return ps;
    }
  }
  
  StatementStrategy st = new AddStatement();
  jdbcContextWithStatementStrategy(st);
}
```



이렇게 `AddStatement` 클래스를 로컬 클래스로 둠으로써 클래스 파일을 하나 줄일 수 있다는 장점이 생긴다. 한 가지 더 욕심을 내보자면, `AddStatement` 클래스는 오로지 `add()` 메서드 내에서만 사용된다. 그렇다면 익명 내부 클래스로 선언해서 클래스 이름도 제거할 수 있다.



**익명 내부 클래스는 선언과 동시에 오브젝트를 생성한다.** 이름이 없기 때문에 클래스 자신의 타입을 가진 수 없고, 구현한 인터페이스 타입의 변수에만 저장할 수 있다.



```java
public void add(User user) throws SQLException {

  StatementStrategy st = new StatementStrategy() {
    
    @Override
    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
      PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");

      ps.setString(1, user.getId());
      ps.setString(2, user.getName());
      ps.setString(3, user.getPassword());

      return ps;      }
  };
  jdbcContextWithStatementStrategy(st);
}
```



이를 람다로 더욱 더 간결하게 표현할 수도 있다.



```java
public void add(User user) throws SQLException {

  StatementStrategy st = c -> {
    PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");

    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());

    return ps;      
  };
  
  jdbcContextWithStatementStrategy(st);
}
```



```java
public void deleteAll() throws SQLException {
  StatementStrategy strategy = c -> c.prepareStatement("delete from users");
  jdbcContextWithStatementStrategy(strategy);
}
```



### 3.4 컨텍스트와 DI

`Connection` 을 가져오고 `PreparedStatement` 를 실행하는 `jdbcContextWithStatementStrategy()`  메서드는 `UserDao` 뿐만 아니라 다른 DAO 에서도 사용할 수도 있다. 따라서 얘를 모든 DAO가 사용할 수 있도록 분리해본다.



분리해서 `JdbcContext` 클래스를 만든다. 여기서 주의해야 할 점은 `JdbcContext` 에서 `DataSource` 를 필요로 한다는 것이다. 즉, `JdbcContext`가 `DataSource`를 의존하고 있다는 의미이다. 그렇기 때문에 `DataSource`타입의 빈을 DI 받을 수 있도록 해주어야 한다.



```java
package springbook.user.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import javax.sql.DataSource;
import lombok.Data;

@Data
public class JdbcContext {

  private DataSource dataSource;

  public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
    try (
        Connection conn = dataSource.getConnection();
        PreparedStatement ps = stmt.makePreparedStatement(conn);
    ) {
      ps.executeUpdate();
    }
  }

}
```



마찬가지로 `UserDao` 에 `JdbcContext` 타입의 빈을 DI 받을 수 있도록 한다.



```java
package springbook.user.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;
import lombok.Data;
import org.springframework.dao.EmptyResultDataAccessException;
import springbook.user.domain.User;

@Data
public class UserDao {

  private DataSource dataSource;
  private JdbcContext jdbcContext;

  public void add(User user) throws SQLException {
  
    ...

    jdbcContext.workWithStatementStrategy(st);
  }

  public void deleteAll() throws SQLException {
    StatementStrategy strategy = c -> c.prepareStatement("delete from users");
    jdbcContext.workWithStatementStrategy(strategy);
  }

}
```



스프링의 빈 설정은 클래스 레벨이 아닌, **런타임 시에 만들어지는 오브젝트 레벨**의 의존관계에 따라 정의된다. 기존에는 `userDao` 빈이 `dataSource` 빈을 직접 의존했지만, 이제는 `jdbcContext` 빈이 그 사이에 끼게 되었다. `DaoFactory` 에 `JdbcContext` 빈을 생성하고, `UserDao` 에 설정해주도록 하자.



```Java
package springbook.user.dao;

import javax.sql.DataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.SimpleDriverDataSource;

@Configuration
public class DaoFactory {

  @Bean
  public UserDao userDao() {
    UserDao userDao = new UserDao();
    userDao.setDataSource(dataSource());
    userDao.setJdbcContext(jdbcContext());

    return userDao;
  }

  @Bean
  public JdbcContext jdbcContext() {
    JdbcContext jdbcContext = new JdbcContext();
    jdbcContext.setDataSource(dataSource());

    return jdbcContext;
  }
  
  ...

}
```



지금까지의 DI 에선 클래스 레벨에서 구체적인 의존관계가 만들어지지 않도록 인터페이스를 사용했다. 그런데  `JdbcContext` 는 인터페이스가 아닌 클래스이고, `UserDao` 에서는 인터페이스를 거치지 않고 `JdbcContext` 클래스를 바로 사용하고 있다.



이렇게 인터페이스를 사용하지 않고 DI를 적용하는 것도 문제는 없다. **스프링의 DI는 넓게 보자면 객체의 생성과 관계 설정에 대한 제어 권한을 오브젝트에서 제거하고, 외부로 위임했다는 IoC 개념을 포괄**한다. 그렇기 때문에 `JdbcContext` 역시 스프링을 이용해 `UserDao` 객체에서 사용하도록 주입했다는 건 DI의 기본을 따르고 있다고 볼 수 있다.



인터페이스를 사용해서 클래스를 다이나믹하게 주입하도록 하진 않았지만, `JdbcContext` 를 `UserDao` 와 DI 구조로 만들어야 하는 이유는 다음과 같다.



- `JdbcContext` 가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이기 때문이다. `JdbcContext` 는 변경되는 상태 정보를 갖고 있지 않다. 따라서 싱글톤으로 등록되어 여러 오브젝트가 공유해 사용되는 것이 이상적이다.
- `JdbcContext` 가 DI 를 통해 다른 빈에 의존하고 있기 때문이다. DI를 위해서는 주입되는/받는 오브젝트 모두 스프링 빈으로 등록되어 있어야 한다. 스프링이 생성하고 관리하는 IoC 대상이어야 DI에 참여할 수 있기 때문이다.



`JdbcContext` 를 빈으로 등록하지 않고 `UserDao` 내부에서 직접 DI를 적용하면 `JdbcContext` 를 싱글톤으로 사용할 수 없다. 두 번째 문제는 `JdbcContext` 내부의 `DataSource` 빈 주입이다. 이를 해결하는 방법으로는 `JdbcContext` 에 대한 제어권을 갖고 생성과 관리를 담당하는 `UserDao` 에게 DI까지 맡기는 것이 있다. 즉, `UserDao`가 임시로 DI 컨테이너 역할을 해주는 것이다.



`JdbcContext` 에 주입해줄 의존 오브젝트인 `DataSource` 를 `UserDao`가 대신 DI 받도록 해주면 된다. `UserDao` 는 주입받은 `DataSource` 빈을 `JdbcContext` 를 만들고 초기화하는 과정에만 사용하고 버리면 된다.



```java
public class UserDao {

  ...
  private JdbcContext jdbcContext;

  public void setDataSource(DataSource dataSource) {
    this.jdbcContext = new JdbcContext();
    this.jdbcContext.setDataSource(dataSource);
    
    ...
      
  }
}
```



`setDataSource()` 메서드는 DI 컨테이너가 `DataSource` 오브젝트를 주입해줄 때 호출된다. 이때 `JdbcContext`에 대한 수동 DI 작업을 수행하면 된다.



### 3.5 템플릿과 콜백





### 3.6 스프링의 JdbcTemplate





