개방 폐쇄 원칙`OCP` 은 확장에는 열려 있고, 변경에는 닫혀 있다는 객체지향 설계의 핵심 원칙이다. 어떤 코드는 변경을 통해 그 기능을 확장하려는 성질이 있고, 또 어떤 부분은 고정되어 있어 변하지 않으려는 성질이 있다. 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적에 의해 다른 시점에 독립적으로 변경될 수 있는 구조를 만들어 주는 것이 바로 개방 폐쇄 원칙의 핵심이다.

템플릿이란 일정한 패턴으로 유지되는 부분을, 자유롭게 변경되는 부분으로부터 독립시켜 효과적으로 활용할 수 있도록 하는 방법이다.



### 3.1 다시 보는 초난감 DAO

기존 `UserDao` 코드는 아직 불완전하다. 예외상황에 대한 처리가 없다는 문제점이 있다. DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 도중에 예외가 발생했을 경우에 리소스를 반환할 필요가 있다. 그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.



예외상황에서 리소스를 제대로 반환할 수 있도록 `try/catch/finally` 를 보통 많이 썼지만, Java 7부터 제공하는 `try-with-resources` 문법을 사용하면 더욱 간단히 리소스를 반환할 수 있다.

`try-with-resources` 문법을 사용해서 `deleteAll()` 메서드를 다음과 같이 수정할 수 있다.



```java
  public void deleteAll() throws SQLException {
    try (Connection conn = dataSource.getConnection();
        PreparedStatement ps = conn.prepareStatement("delete from users")
    ) {
      ps.executeUpdate();
    }
  }
```



참고로 `get()` 메서드와 같이 `PreparedStatement` 의 값을 세팅해줘야 하는 경우에는 다음과 같이 해주면 된다.



```java
public User get(String id) throws SQLException {
  try (
      Connection conn = dataSource.getConnection();
      PreparedStatement ps = conn.prepareStatement("select * from users where id = ?");
  ) {
    ps.setString(1, id);
    try (
        ResultSet rs = ps.executeQuery();
    ) {
      User user = null;
      if (rs.next()) {
        user = User.builder()
            .id(rs.getString("id"))
            .name(rs.getString("name"))
            .password(rs.getString("password"))
            .build();
      }

      if (user == null) {
        throw new EmptyResultDataAccessException(1);
      }

      return user;
    }
  }
}
```



### 3.2 변하는 것과 변하지 않는 것

이제 여기서 변하지 않지만 많은 곳에서 중복되는 코드와, 로직에 따라 확장되고 변경되는 코드를 분리해내는 작업을 해보자.

먼저 `deleteAll()` 메서드에서 변하지 않는 부분과 변하는 부분을 분리해보자면, 변하는 부분은 쿼리 부분이고 변하지 않는 부분은 쿼리 부분을 제외한 나머지라고 할 수 있겠다. `add()` 메서도 마찬가지로 `PreparedStatement` 를 세팅하는 부분이 변하는 부분이고, 나머지는 변하지 않는 부분이다. 그럼 이처럼 로직에 따라서 변하는 부분을 변하지 않는 나머지 코드에서 분리하는 것이 좋겠다.



**전략 패턴**이란, 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 패턴이다. 이는 개방 폐쇄 원칙을 잘 지키는 구조이면서 템플릿 메서드 패턴보다 유연하고 확장성이 뛰어나다.



![](https://media.vlpt.us/images/y_dragonrise/post/01b02920-5e7d-4a90-b5be-7cdfe0f6091d/image.png)





`Context` 의 `contextMethod()`에서 일정한 구조를 가지고 동작하다가, 특정 확장 기능은 `Strategy` 인터페이스를 통해 외부의 독립된 전략 클래스에 위임하는 것이 전략 패턴의 구조이다.

`UserDao` 클래스에서는 `deleteAll()` 메서드에서 변하지 않는 부분이라고 명시한 것이 `contextMethod()` 가 되고, `PreparedStatement` 를 만들어주는 외부 기능이 바로 전략 패턴에서 말하는 **전략**이 된다.

`PreparedStatement` 를 만드는 전략 인터페이스는 컨텍스트가 만들어둔 `Connection` 을 전달받아서, `PreparedStatement` 를 만들고, 만들어진 `PreparedStatement` 오브젝트를 반환한다.

```java
package springbook.user.dao;

...

public interface StatementStrategy {
  
  PreparedStatement makePreparedStatement(Connection c) throws SQLException;

}
```



그리고 위의 인터페이스를 상속해서 실제 전략, 즉 `PreparedStatement` 를 생성하는 구현체 클래스는 다음과 같다.



```java
package springbook.user.dao;

...

public class DeleteAllStatement implements StatementStrategy {

  @Override
  public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    return c.prepareStatement("delete from users");
  }
}
```



```java
public void deleteAll() throws SQLException {
  try (Connection conn = dataSource.getConnection()) {
    StatementStrategy strategy = new DeleteAllStatement();
    
    try (PreparedStatement ps = strategy.makePreparedStatement(conn)) {
      ps.executeUpdate();
    }
  }
}
```



하지만, 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지(폐쇄)되면서 전략을 바꿔(개방) 쓸 수 있다는 것인다, 이렇게 컨텍스트 안에서 이미 구체적인 전략 클래스`DeleteAllStatement` 가 명시되어 있다면 전략 패턴에도, OCP 에도 잘 맞다고 볼 수 없다.



전략 패턴에 따르면, `Context` 가 어떤 전략을 사용할지는 `Context` 를 사용하는 앞단의 클라이언트가 결정하는 것이 일반적이다. 이는 1장에서 `UserDao` 와 `ConnectionMaker` 를 분리할 때, `UserDao` 가 구체적인 `ConnectionMaker` 의 구현 클래스를 만들어 사용하는 것이 문제가 있다고 판단했을 때 적용했던 방법과 동일하다. 전략 오브젝트 새엇ㅇ과 컨텍스트로의 전달을 담당하는 책임을 분리시킨 것이 `ObjectFactory`이고, 이를 일반화한 것이 DI이다. 즉, DI란 이러한 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조라고 볼 수 있다.



컨텍스트를 메서드로 분리하면 다음과 같다.



```java
public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws SQLException {
  try (
      Connection conn = dataSource.getConnection();
      PreparedStatement ps = stmt.makePreparedStatement(conn);
  ) {
    ps.executeUpdate();
  }
}
```



이렇게 컨텍스트를 별도의 메서드로 분리했기 때문에 `deleteAll()`메서드가 이를 사용하는 클라이언트가 된다. 즉, `deleteAll()` 메서드는 전략 오브젝트를 만들고 컨텍스트를 호출하는 책임이 있다.







```java
public void deleteAll() throws SQLException {
  StatementStrategy strategy = new DeleteAllStatement();
  jdbcContextWithStatementStrategy(strategy);
}
```











### 3.3 JDBC 전략 패턴의 최적화





### 3.4 컨텍스트와 DI





### 3.5 템플릿과 콜백





### 3.6 스프링의 JdbcTemplate





