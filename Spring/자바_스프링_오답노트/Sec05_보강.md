## 헥사고날 아키텍처

### 레이어드 아키텍처

- 유사한 기능들을 같은 계층으로 묶어 관리하는 방식의 아키텍처
- Presentation(Controller) - Business(Service) - Persistence(Repository)

**장점**

- 이해하기 쉽다!

**단점** 

- 어느 방식으로 접근해도 결과물이 엉망이 된다..

- 상향식 접근법: JPA에 의존적인 애플리케이션
- 하향식 접근법: 스프링에 의존적인 애플리케이션
- 동시 작업성이 떨어진다. 레포지토리가 개발되어야 서비스가 개발되고, 서비스가 개발되어야 컨트롤러가 개발된다. 이는 절차지향적인 프로그래밍에서도 나타나는 문제.
- 도메인이 죽는다. 계층형 아키텍처는 업무 도메인에 대해 아무것도 알려주지 않는다. 모든 코드가 함수 위주로 돌아가게 됨.

중요한건 **도메인**!!



**심폐소생술..**

- 신과 같이 많은 역할을 하던 서비스에서 도메인 계층을 분리. 서비스는 레포지토리에서 도메인을 가져오고, 도메인에게 일을 시키는 정도의 일만 시킨다.
- 실제 비즈니스 업무 처리는 도메인 영역에서 한다. OOP 스러운 도메인들이 협력하는 곳.
- 낮은 Testability: 도메인 계층은 mocking 필요없다. 또한 POJO이기 때문에 인스턴스화 하기 쉬우므로 테스트가 쉽다.



### 헥사고날 아키텍처

**의존성 역전**

= 관심사를 분리하고 싶다

= 고립시키고 싶다

= 서로에게 영향을 받고 싶지 않다

= 의존성 역전은 경계다.

= 포트-어댑터 패턴

- 실행 객체 -> Port(interface) <- Adapter



![헥사고날 아키텍처(Hexagonal Architecture) : 유연하고 확장 가능한 소프트웨어 디자인 🌟 feat. Java  Example - 오픈소스컨설팅 테크블로그](https://tech.osci.kr/wp-content/uploads/2023/03/hexagonal-architecture.png)



**헥사고날 아키텍처의 장점**

- 외부에서 도메인으로 향하는 방향이 단방향으로 유지된다. 그로 인해 도메인이 순수해짐
- JPA나 스프링같은 외부세계에는 관심이 적어지고, 도메인(애플리케이션의 핵심)에 충실해질 수 있다.
- 도메인을 먼저 만들고, 비즈니스 서비스 파사드를 만드는 등 상향식으로 개발하면 된다.



### 클린 아키텍처

- 헥사고날 아키텍처와 매우 유사. 클린 아키텍처의 구현/실천 방식이 헥사고날 아키텍처이다.
- 험블: 본질만 남기고 테스트 하기 어려운 부분을 분리하자. 이때 분리된 **테스트하기 어려운 부분을 험블이라고 한다.** GUI, DB 등..
- 본질과 험블을 구분해야 한다.
  - DB나 라이브러리를 바꾼다고 계산 로직이 변경되면 안됨.
- 도메인을 설계하는 능력을 갖출것.



### 마무리

- 이러니 저러니 해도 트레이드 오프가 있어서 아키텍처 설계에는 정답이 없다..
- 아키텍처는 종착지가 아니라 여정에 더 가까우며, 고정된 산출물이 아니라 계속된 탐구 과정에 더 가까움을 이해해야 좋은 아키텍처가 만들어진다. - 케블린 헤니



## 엔티티와 코드 튜닝

### 엔티티

**엔티티에 대한 오해**

- 엔티티는 JPA랑 상관이 없다.

- 마냥 틀린 설명은 아니긴 함. 오라클 공식 가이드에서는 엔티티를 '영속성 도메인 객체'라고 설명함.



**도메인 엔티티**

- 소프트웨어에서 어떤 도메인이나 문제를 해결하기 위해 만들어진 모델. 비즈니스 로직을 들고 있고, 식별 가능하며, 일반적으로 생명 주기를 가진다.
- 개발 세계의 엔티티



**DB 엔티티**

- 데이터베이스에서 표현하려고 하는 유형, 무형의 객체로서, 서로 구별되는 것을 뜻한다.



**영속성 객체**

- ORM



### 코드 튜닝

**로그에 계산식 넣지 마라**

- Bracket을 넣자. `log.info("hello {}", user.getId());`
- 로그를 안 찍어도 될 때에는 덧셈 연산 발생하지 않게 할 수 있기 때문

- `new` 는 사실상 하드코딩이다. 반면에 의존성 주입을 하면 선택의 여지가 생기게 된다.