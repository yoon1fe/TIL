## 테스트를 해야 하는 이유와 테스트의 분류

### 필요성

- 레거시 코드란 단순히 테스트 루틴이 없는 코드다. 다만 이 정의는 다소 불완전하다. - 마이클 페더스
- 리그레션 테스트가 잘 갖추어져 있다면 새로운 기능을 배포할 때 걱정할 필요 X

- 개발자의 성장을 위해 - 관성으로 개발하고 있다는 생각이 들 때



### 테스트의 종류

**인수 테스트**

- 체크리스트를 관리하면서 테스트 항목을 사람이 검사하는 것.



**자동 테스트**

- 소프트웨어를 이용해서 자동으로 테스트.



**3분류**

- API 테스트 5%
- 통합 테스트 15% - 어디까지가 통합인지 모호하다..
- 단위 테스트 80%

- 구글 엔지니어는 이렇게 일한다 책에서는 소형 / 중형 / 대형 테스트라고 부름.



**소형 테스트(= 단위 테스트)**

- 단일 서버
- 단일 프로세스
- 단일 스레드
- 디스크 I/O 사용해선 안됨
- Blocking call 허용 안됨
- 테스트 결과가 항상 결정적(Deterministic) 하다
- 테스트 속도가 빠름



**중형 테스트**

- 단일 서버
- 멀티 프로세스
- 멀티 스레드
- 테스트용 DB 사용 가능
- 항상 같은 결과를 보장하지 않는다. H2와 같은 외부 모듈의 동작에 따라 달라질 수 있기 때문



**대형 테스트**

- 멀티 서버
- End to End 테스트



**우리가 집중해야 하는 것은 소형(Unit) 테스트**



### 안티 패턴

**아이스크림 패턴**

- 역삼각형 모양의 테스트 비율.
- API 테스트(E2E 테스트)만 늘어나는 경우..
- API 호출만 하고 호출 결과가 원했던 결과와 일치하는지 확인하면 끝난다고 생각..
- API 테스트는 불안정하기 때문에 예상치못한 이유로 많이 실패한다.



**모래시계 패턴**

- 중형 테스트를 신경쓰지 않은 형태



## 테스트에 필요한 개념

### 개념

**SUT(System Under Test)**

- 테스트하려는 대상



**TDD(Test Driven Development)**

- 테스트 주도 개발
- 순서
  1. 깨지는 테스트를 먼저 작성 <- RED 단계
     - 인터페이스에게 기대하는 모든 동작을 테스트로 만든다.
  2. 깨지는 테스트를 성공시킴 <- GREEN 단계
     - 모든 테스트를 통과시키는 것을 목표로
  3. 리팩토링 <- BLUE 단계
     - 코드 퀄리티를 고려하는 단계



**BDD(Behavior Driven Development) (given - when - then)**

- TDD + 행동에 집중
- 어디에 어떻게 테스트하지? 에 대한 해답
- 메서드 위주의 테스트 코드보다 **시나리오**에 기반한 테스트를 하는 방식



**불규칙한 테스트 (flaky)**

- 대상 코드에 아무런 변경이 없음에도 실패하는 테스트
- non-deterministic



**깨지기 쉬운 테스트 (brittle)**

- 실제로는 버그가 없음에도, 심지어 검증 대상 코드와 관련조차 없는 변경 때문에 실패하는 테스트
- 테스트에 필요한 가정들이 명시적으로 작성되어 있지 않은 경우 발생



**상호 작용 테스트(Interaction test)**

- 메서드가 실제로 호출이 됐는지 검증하는 테스트
- 일반적으로 그닥 좋은 테스트 방법이 아님.
- 내부 구현이 어떻게 되어 있는지를 감시하는 테스트 == 캡슐화에 위배
- 상호작용 테스트보다 상태를 테스트 하는 것이 좋다.



**테스트 더블**

- 테스트 대역



### 대역

**Dummy**

- 일을 시켜도 **아무런 일을 하지 않는 객체**
- 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체



**Fake**

- 테스트나 로컬에서 사용하기 위해 만들어진 가짜 객체. 자체 로직을 갖고 있음.



**Stub**

- 미리 준비된 값을 출력하는 객체
- 주로 외부 연동하는 컴포넌트들에 많이 사용한다.

- 보통 mockito 프레임워크를 이용

  ``` java
  // given
  given(userRepository.getByEmail("foo@bar.com"))
    .willReturn(User.builder()
                .email("foo@bar.com")
                .status("PENDING")
                .build());
  ```



**Mock**

- 메서드 호출을 확인하기 위한 객체. 자가 검증 능력을 갖춤
- 사실상 테트스 더블과 동일한 의미로 사용됨



**Spy**

- 모든 메서드 호출을 기록해뒀다가 나중에 확인하기 위한 객체
- 메서드가 몇 번 호출됐는지, 잘 호출됐는지 등을 검증



### 도구

**Mock 프레임워크**

- Mockito vs BDDMockito(Mockito + BDD)
- given 위치에서
  - Mockito.when()
  - BDDMockito.given()



## 테스트 기법

### 조언



**private 메서드를 테스트 해야 하나 ? -> NO**

- private 메서드를 테스트하고 싶다는 느낌이 든다면 역할을 올바르게 할당하지 못한 것일 수 있다.
  - private 메서드가 아니어야 한다는 의미일 수도
  - 다른 클래스로 분리하고, 책임을 위임해서 pulic 으로 만들러난 의미일 수도 있음
- 메서드 지향의 테스트를 하려 해서 생기는 문제. 행위에 집중해서 테스트해야 함



**final 메서드를 stub**

- 설계가 잘못된 것이다.
- final 메서드에 걸린 의존성을 약하게 하는 방법을 생각해보아야 한다.



**테스트할 때는 DRY 보다 DAMP**

- DRY: Don't Repeat Yourself (반복하지 않기)
- DAMP: Descriptive And Meaningful Phrase(서술적이고 의미있는 문구)
- 테스트 코드에 있어서는 중복을 허용하는 게 더 깔끔할 수 있다.



**테스트에 논리를 넣지 말자**

- for, if, 덧셈, 뺄셈 등을 넣지 말자.
- 테스트 코드는 직관적이고 이해 가능하게 짜는 것이 좋다.



### 기법

**의존성 추상화**

- 테스트하기 어려운 의존성이 있을 때 사용할 수 있는 기법



**이벤트 기록**

- 테스트를 위한 getter 생성이 남발된다 싶을 때 적용할 수 있는 기법
- 내부에 기록한 이벤트를 사용해서 변경 가능 객체의 변경을 확인한다.