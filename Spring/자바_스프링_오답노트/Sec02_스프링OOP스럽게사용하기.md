## 스프링에서 OOP와 안티 패턴 - OOP 스럽지 않은 사례

### Smart UI

**Smart UI 를 피할 것!**

- 핸들러(controller)에서 모든 처리를 다 하고 응답을 내려주는 코드.
- 백엔드에서 UI란 Controller
- Controller는 어떤 서비스를 실행할지 선택하는 정도의 역할만 한다.



**Relaxed Layerd system**

- Controller 에서 바로 Repository 를 호출(의존)하는 경우를 relaxed layer architecture 라고 한다. 이 방식이 smart ui를 유발함. 안티 패턴!

- Presentation (Controller) -> Business (Service) -> Persistence (Repository) : 레이어 아키텍처



**Layered system at DDD**

- 사용자 인터페이스 Controller
- 응용 계층 Service - 최대한 얇게 유지되어야 한다. 업무 규칙이나 지식이 포함되면 안되고, **오직 작업을 조정하고 아래에 위치한 계층에 도메인 객체의 협력자에게 작업을 위임한다.**
- 도메인(= 비즈니스 모델) 계층 Domain model
- 인프라 스트럭처 계층 Repository



### Transaction script

**Transaction script**

- 서비스 컴포넌트에 거의 모든 업무 규칙과 지식들이 들어가 있는 케이스.
- 사실상 **서비스는 트랜잭션을 실행하는 스크립트**의 역할일 뿐..
- 서비스가 비즈니스 로직을 들고 있음.
- 서비스는 작업을 조정하고, 비즈니스 로직을 도메인에게 위임해야 한다!

- 논리 로직 자체가 목적인 행위자: 도메인 서비스
  - 이름 추천: xxManager, xxCalculator, xxService..



## 어디까지 추상화해야 하는가?

**추상화**

- 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것. 
- 모듈을 격리하고 인터페이스를 만드는 과정.



**시스템 외부 연동은 추상화하자**

- ex) Repository 인터페이스를 비즈니스 레이어에 두자.

- 의존성 역전이 됨 -> 결합도가 낮아짐.
- 테스트가 쉬워짐
- 왜 비즈니스 레이어에 두어야 하나?
  - 의존성 역전의 핵심은 "고수준 모듈이 저수준 모듈을 의존하지 않게 하는 것". 영속성 레이어에 둔다면 비즈니스 레이어가 영속성 레이어에 의존하게 된다.
- 그럼 서비스 객체는 왜 추상화하지 않지?
  - Controller, Service, Entity, VO는 구현체로 구현되어도 상관없다. - 마티아스 노박
  - 서비스와 컨트롤러의 목적 자체가 한 번 생성하면 영원히 같은 일을 할 수 있는 객체여야 하기 때문.



**도메인 영역**

- 도메인 객체는 레포지토리 를 사용하지 못한다. 도메인 객체가 협력에 필요한 모든 객체는 애플리케이션 서비스에서 미리 다 준비해서 도메인에게 넘겨주어야 한다.
  - 원칙적으로 Domain service 는 Repository 를 알아선 안된다.
  - 그러나 도메인에서 Repository 에 접근할 수 없다면 불필요한 쿼리가 나가게 되는 상황이 생길 수 있다. 그래서 뭐가 맞는 지에 대해서는 갑론을박이 꽤 있다..



**정리**

- 시스템 외부 연동 추상화
- 서비스는 굳이 추상화하지 않아도 됨
- 도메인 계층을 만들고, 도메인 영역을 풍부하게 (서비스 레이어가 두꺼워지는 것을 지양하자)



## 서비스란 무엇인가?

**서비스?**

- 스프링 문서에서) 서비스는 DDD에서 가져온 개념이고, 비즈니스 서비스의 Facade 이다. 즉, DDD를 DDD답게 사용하기 위한 프레임워크.
- 도메인과 도메인 서비스에게 책임을 위임하는 Facade 패턴의 일종



**DDD에서 말하는 서비스**

- 엔티티나 VO에서 찾지 못하는 중요한 도메인 연산이 있다. 이들 중 일부는 본질적으로 사물이 아닌 **활동이나 행동**인데, 우리의 모델링 패러다임이 객체이므로 그러한 연산도 객체와 잘 어울리게끔 해야 한다.
- 이따금 서비스는 특정 연산을 수행하는 것 이상의 의미는 없는 모델 객체로 가장해서 나타나기도 한다. 이같은 행위자는 이름 끝에 `Manager` 같은 것이 붙는다. == 서비스
- 흔히 하는 실수는 행위를 적절한 객체로 다듬는 것을 너무나도 쉽게  포기해서 점점 절차 지향 프로그래밍으로 빠지는 것.



**애플리케이션 서비스와 도메인 서비스**

- 애플리케이션 서비스: 스프링 한정) 스프링의 서비스 컴포넌트에 종속되는 서비스
- 도메인 서비스: 스프링 한정) 스프링의 서비스 컴포넌트에 종속되지 않는 서비스



**더 중요한 것은**

- 풍부한 도메인을 만들 것.
- 서비스는 가능한 적게, 얇게 만들 것.



**서비스에 관한 조언**

- 서비스는 한 번 생성하면 특정 작업을 하는 작은 기계처럼 **영원히** 실행할 수 있어야 한다.
  - 영원히 == 불변성
  - 생성자 주입만을 사용해야 함.
- 정리
  - 서비스를 얇게 유지할 것
  - 서비스의 멤버 변수는 모두 final로 선언
  - 서비스에 setter가 있다면 지울 것
  - 반드시 생성자 주입!



## 기타 꿀팁

### JPA

**JPA는 기술 명세이다**

- Hibernate가 JPA의 구현체
- Spring-data-jpa: JPA를 더 쉽게 사용할 수 있도록 해주는 도구



**연관 관계의 주인**

- 관계를 표현하는 데 있어서 가장 중요한 것.
- 연관 관계의 핵심 = 외래키