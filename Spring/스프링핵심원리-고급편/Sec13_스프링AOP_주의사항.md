## 프록시와 내부 호출

### 문제

스프링은 프록시 방식의 AOP를 사용한다. 따라서 AOP를 적용하려면 항상 프록시를 통해서 대상 객체(Target)를 호출해야 한다. 프록시를 거치지 않으면 AOP가 적용되지 않음!!



내부 호출이 발생하면 프록시 객체 인스턴스 안에서 호출하게 된다. 따라서 AOP 적용 안됨.

- ex) `this.internal()`
- client -> proxy.external() -> **target.external() -> target.internal()(this.internal()**

- `this`는 자기 자신의 인스턴스를 의미하므로 프록시를 거치지 않게 된다.



프록시 방식의 AOP는 메서드 내부 호출에 프록시를 적용할 수 없다.!!



**참고**

실제 코드에 AOP를 직접 적용하는 AspectJ를 사용하면 위의 문제가 발생하지 않는다. 바이트 코드를 조작해서 코드를 앞단에 넣어버리니깐. 근데 AspectJ를 직접 사용하는 방법은 실무에서 거의 안쓴다.



### 대안1 - 자기 자신 주입

```java
/**
 * 참고: 생성자 주입은 순환 사이클을 만들기 때문에 실패한다.
 */
@Slf4j
@Component
public class CallServiceV1 {

  private CallServiceV1 callServiceV1;

  @Autowired
  public void setCallServiceV1(CallServiceV1 callServiceV1) {
    this.callServiceV1 = callServiceV1;
  }

  public void external() {
    log.info("call external");
    callServiceV1.internal(); //외부 메서드 호출
  }

  public void internal() {
    log.info("call internal");
  }
}
```

- 생성자 주입하면 오류 발생. 자기 자신 인스턴스 생성하면서 주입해야 하기 때문에 순환 참조가 만들어진다.
- 자기 자신의 프록시를 호출하도록 하면 됨.



**주의**

스프링 부트 2.6부터 순환 참조를 기본적으로 금지하도록 정책 변경됨.



### 대안2 - 지연 조회

스프링 빈 지연해서 조회하면 생성자 주입 가능.

`ObjectProvider(Provider)`, `ApplicationContext` 사용하면 된다.



### 대안3 - 구조 변경

가장 좋은 대안은 내부 호출이 발생하지 않도록 구조를 변경하는 것이다. 스프링에서도 이 방법을 가장 권장한다.

단순하게 분리하는 것 뿐만 아니라 클라이언트가 두 메서드를 다 호출한다든지 다양한 방법 있을 수 있다.



## 프록시 기술과 한계

### 타입 캐스팅



**JDK 동적 프록시의 한계**

인터페이스 기반으로 프록시를 생성하는 JDK 동적 프록시는 구체 클래스로 타입 캐스팅이 불가능하다. 당연! JDK 동적 프록시는 구현체는 알 방법이 없다.

반면에 CBLIG 프록시는 구체 클래스를 기반으로 프록시를 생성하기 때문에 부모 클래스, 구체 클래스로 타입 캐스팅이 모두 가능하다.



### 의존 관계 주입

JDK 동적 프록시를 사용하면 서 의존 관계 주입을 할 때 구체 클래스 주입이 안된다.



- `@Autowired MemberServiceImpl memberServiceImpl`: JDK 프록시는 `MemberService` 인터페이스를 기반으로 만들어지므로 구체 클래스 타입에 의존성을 주입할 수 없다.
- 개발할 때 인터페이스가 있으면 인터페이스를 기반으로 의존 관계 주입을 받는게 맞지만, 테스트나 다른 이유 등으로 AOP 프록시가 적용된 구체 클래스를 직접 의존 관계 주입받아야 하는 경우에는, CGLIB를 통해 AOP 프록시를 적용하면 된다.



### CGLIB

**CGLIB 구체 클래스 기반 프록시의 문제점**

- 대상 클래스에 기본 생성자 필수

  CGLIB는 구체 클래스를 상속받는데, 자식 클래스의 생성자를 호출할 때 자식 클래스의 생성자에서 부모 클래스의 생성자도 호출한다. CGLIB 프록시는 대상 클래스를 상속 받고, 생성자에서 대상 클래스의 기본 생성자를 호출하므로 대상 클래스에 기본 생성자를 만들어야 한다.

- 생성자 2번 호출 문제

  1. 실제 target의 객체 생성할 때
  2. 프록시 객체를 생성할 때 부모 클래스의 생성자 호출

- `final` 키워드 클래스, 메서드 사용 불가

  `final` 키워드가 클래스에 있으면 상속 불가 / 메서드에 있으면 오버라이딩 불가 하므로.



### 스프링의 해결책

- 스프링 3.2부터 CGLIB를 스프링 내부에 함께 패키징
- CGLIB 기본 생성자 필수 문제 해결
  - `objenesis`라는 라이브러리를 통해 생성자 호출 없이 객체 생성
- 생성자 2번 호출 문제
  - 역시 `objenesis` 라이브러리를 통해

=> **스프링 부트 2.0 부터 - CGLIB 기본으로 사용!**