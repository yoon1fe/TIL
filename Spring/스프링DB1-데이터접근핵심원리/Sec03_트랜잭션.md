## 트랜잭션 개념

DB는 **트랜잭션**이라는 개념을 지원한다. 트랜잭션이란 **하나의 거래를 안전하게 처리하도록 보장**해주는 것을 의미.

모든 작업이 성공해서 DB에 정상 반영하는 것을 커밋, 작업 중 하나라도 실패해서 거래 이전으로 되돌리는 것을 롤백이라고 한다.



**트랜잭션 ACID**

- **원자성(Atomicity)**: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.
- **일관성(Consistency)**: 모든 트랜잭션은 일관성있는 DB 상태를 유지해야 한다. ex) 무결성 제약 조건 항상 만족..
  - **격리성(Isolation)**: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. ex) 동시에 같은 데이터 수정 못하도록. 격리성은 동시성과 관련된 성능 이슈로 인해, 트		랜잭션 격리 수준을 선택할 수 있다.
- **지속성(Durability)**: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 DB 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.



**트랜잭션 격리 수준 - Iolation level**

- `READ UNCOMMITTED` (커밋되지 않은 읽기)
- `READ COMMITTED` (커밋된 읽기)
- `RETEATABLE READ` (반복 가능한 읽기)
- `SERIALIZABLE` (직렬화 가능)



## 데이터베이스 연결 구조와 DB 세션

- 사용자는 WAS나 DB 접근 툴같은 클라이언트를 통해 DB 서버에 접근한다. 
- 클라이언트는 DB 서버에 연결을 요청하고 **커넥션**을 맺는다. 이때 DB 서버에서는 내부에 **세션**을 생성하고, 해당 커넥션을 통한 모든 요청은 이 세션을 통해 실행된다.
- 세션은 **트랜잭션**을 시작하고, 커밋/롤백을 통해 트랜잭션을 종료한다.
- 사용자가 커넥션을 닫거나 DB 관리자가 세션을 강제로 종료하면 세션은 종료된다.
- 만약 커넥션 풀이 10개의 커넥션을 생성하면, 세션도 10개가 생성된다.



## 트랜잭션 - DB 예제

**트랜잭션 사용법**

- 데이터 변경 쿼리를 실행하고 DB에 결과를 반영하려면 `commit` 명령어 호출, 그렇지 않다면 `rollback` 명령어 호출
- 커밋을 호출하기 전까지는 임시로 데이터를 저장하는 것! 해당 트랜잭션을 시작한 세션(사용자)에게만 변경 데이터가 보이고, 다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.(`set autocommit true;`)
- 등록, 수정, 삭제 모두 같은 원리로 동작한다.



**커밋하지 않은 데이터를 다른 곳에서 조회할 수 있다면 어떤 문제가 발생할까??**

- 세션1에서 변경한 데이터를 세션2에서 조회했을 때 변경된 데이터가 보이면 그 데이터를 갖고 어떤 로직을 수행할 수 있다. 근데 세션1이 롤백해버리면 데이터 정합성에 큰 문제가 발생한다. 따라서 **커밋 전의 데이터는 다른 세션에 보여지면 안된다!**



**자동 커밋**

각각의 쿼리 실행 직후 자동으로 커밋 호출한다. 커밋/롤백을 직접 호출하지 않아도 되는 편리함이 있지만, 우리가 원하는 트랜잭션 기능을 제대로 사용할 수 없다.



**수동 커밋** `set autocommit false;`

보통 자동 커밋 모드가 디폴트이므로, **수동 커밋 모드로 설정하는 것을 트랜잭션의 시작**이라고 생각하면 된다.

수동 커밋 모드로 설정하면 이후에 꼭 `commit`, `rollback`을 호출해야 한다. 안그러면 트랜잭션 실행 타임아웃 시간이 지나면 롤백된다.



커밋 모드는 한 번 설정하면 해당 세션에서는 계속 유지된다.



## DB 락

세션이 트랜잭션을 시작하고 데이터를 수정하는 동안 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없도록 막는 것. 동시에 데이터를 수정하는 문제를 락으로 해결한다.



**락 동작 방식**

- 락을 획득해야 데이터 변경 가능

- 커밋으로 트랜잭션이 종료되면 락 반납

- 락 획득을 위해 대기하던 세션2에서 락을 획득



### 변경

**락 타임 아웃**

`SET LOCK_TIMEOUT <milliseconds>`



### 조회

**일반적인 조회는 락을 사용하지 않는다!**



**조회와 락**

- 데이터를 조회할 때도 락을 획득하고 싶다면, `select for update` 구문을 사용하면 된다.

  ex) `select * from member where member_id='memberA' for update;`

- 세션1이 조회 시점에 락을 가져가기 때문에 다른 세션에서 해당 데이터를 변경할 수 없다. 물론 트랜잭션을 커밋하면 락을 반납한다.



**조회할 때 락이 필요한 경우는 언제??**

- 트랜잭셕 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용



## 트랜잭션 적용