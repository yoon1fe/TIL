## Servlet Filter

로그인한 사용자만 상품 관리 페이지에 들어갈 수 있어야 한다.

상품 관리 컨트롤러 앞단에서 로그인 여부를 체크하는 로직을 추가해도 되지만, 모든 컨트롤러 로직에 공통으로 추가해주어야 한다. 나중에 로그인 관련 로직이 변경되면 로직이 있는 모든 부분을 수정해야 할 수도 있다..

이렇게 애플리케이션 여러 로직에서 공통으로 관심이 있는 것들을 **공통 관심사(cross-cutting concern)** 라고 한다.



공통 관심사는 AOP로도 해결 가능하지만, **웹과 관련된 부분은 서블릿 필터 / 스프링 인터셉터를 사용하는 것이 좋다!** 웹과 관련된 공통 관심사를 처리할 때는 HTTP의 헤더나 URL 정보가 필요한데, 서블릿 필터 / 스프링 인터셉터는 `HttpServletRequest`를 제공한다.



#### 서블릿 필터



**필터의 흐름**

```
HTTP 요청 -> WAS -> Filter -> Servlet -> 컨트롤러
```

- 필터를 적용하면 **필터가 먼저 호출된 다음** 서블릿이 호출된다.



**필터 제한**

```
HTTP 요청 -> WAS -> Filter -> Servlet -> 컨트롤러	// 로그인한 사용자
HTTP 요청 -> WAS -> Filter(적절치 않은 요청이라 판단, 서블릿 호출 X) // 로그인하지 않은 사용자
```

- 필터에서 적절치 않은 요청이라고 판단하면 거기서 끝낼 수도 있다. 그래서 로그인 여부 체크하기 좋음



**필터 체인**

```
HTTP 요청 -> WAS -> Filter1 -> Filter2 -> Filter3 -> Servlet -> 컨트롤러
```

- 필터는 체인으로 구성됨. 중간에 필터 추가 가능하다.
- ex) 로그남기는 필터 -> 로그인 여부 체크 필터



**필터 인터페이스**

```java
package javax.servlet;

import java.io.IOException;

public interface Filter {
  void init(FilterConfig var1) throws ServletException;

  void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException;

  void destroy();
}
```

필터 인터페이스를 구현하고 등록하면 **서블릿 컨테이너**가 필터를 싱글톤 객체로 생성하고 관리한다.

- `init()`: 필터 초기화 메서드. 서블릿 컨테이너가 생성될 때 호출된다.
- `doFilter()`: 고객의 요청이 올 때마다 호출되는 메서드. 필터의 로직 부분
- `destroy()`: 필터 종료 메서드. 서블릿 컨테이너가 종료될 때 호출된다.



### 필터로 요청 로그남기기

#### 필터 구현

```java
@Slf4j
public class LogFilter implements Filter {

  @Override
  public void init(FilterConfig filterConfig) throws ServletException {
    log.info("log filter init");
  }

  @Override
  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    log.info("log filter doFilter");

    HttpServletRequest httpRequest = (HttpServletRequest) request;

    String requestURI = httpRequest.getRequestURI();
    String uuid = UUID.randomUUID().toString();

    try {
      log.info("REQUEST [{}][{}]", uuid, requestURI);
      chain.doFilter(request, response);  // 다음 필터 호출. 호출할 다음 필터가 없으면 서블릿 호출
    } catch (Exception e) {
      throw e;
    } finally {
      log.info("RESPONSE [{}][{}]", uuid, requestURI);
    }
  }

  @Override
  public void destroy() {
    log.info("log filter destroy");
  }
}
```

- 필터를 사용하려면 `Filter` 인터페이스를 구현하면 된다. 
- `doFilter()` 메서드에 로직 구현. 
- 로직 끝에 `chain.doFilter(request, response);` 부분이 중요하다. 해당 로직이 있어야 다음 필터가 있으면 호출하고, 아니면 서블릿을 호출한다. 얘가 없으면 다음 단계로 진행되지 않는다.



#### 필터 설정 - WebConfig

```java
package hello.login;

import hello.login.web.filter.LogFilter;
import javax.servlet.Filter;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class WebConfig {

  @Bean
  public FilterRegistrationBean logFilter() {
    FilterRegistrationBean<Filter> filterRegistrationBean = new FilterRegistrationBean<>();
    filterRegistrationBean.setFilter(new LogFilter());
    filterRegistrationBean.setOrder(1);
    filterRegistrationBean.addUrlPatterns("/*");
    
    return filterRegistrationBean;
  }

}
```

- 필터를 사용하려면 먼저 등록을 해야 한다. 스프링 부트를 사용한다면 `FilterRegistrationBean`을 사용해서 등록하면 된다.
- `setFilter(new LogFilter())`: 등록할 필터 지정
- `setOrder(1)`: 필터는 체인으로 동작하므로 순서가 중요하다. 낮을수록 먼저 동작
- `addUrlPatterns("/*")`: 필터를 적용할 URL 패턴 지정. 한 번에 여러 패턴 지정 가능



**참고**

> `@ServletComponentScan`, `@WebFilter(filterName = "logFilter", urlPatterns = "/*")`로 필터 등록 가능하지만, 필터 순서 조절이 안된다. 따라서 `FilterRegistrationBean`을 사용하자



## Spring Interceptor

필터보다 훨씬 더 강력하다!!

스프링 인터셉터를 사용하면 서블릿 필터처럼 웹과 관련된 공통 관심 사항을 효과적으로 해결할 수 있다 (Spring MVC가 제공). 둘은 적용 순서, 범위, 사용 방법이 다르다.



**스프링 인터셉터 흐름**

```
HTTP 요청 -> WAS -> Filter -> Servlet -> Spring Interceptor -> 컨트롤러
```

- 스프링 인터셉터는 DispatcherServlet과 컨트롤러 사이에서 **컨트롤러 호출 직전에** 호출된다.
- 스프링 MVC의 시작점이 디스패처 서블릿이니깐 인터셉터는 디스패처 서블릿 이후에 등장하게 되는 것.
- URL 패턴 적용 가능한데, 서블릿 URL 패턴과는 다르고 매우 정밀하게 설정 가능하다.













### 요청 로그





### 인증 체크





## ArgumentResolver 활용





