## DB 연동

**`ItemRepositoryTest`**

`@SpringBootTest`: 상위 패키지로 올라가면서  `@SpringBootApplication` 애너테이션을 찾아서 해당 클래스에 설정되어 있는 config를 그대로 갖고 온다.



`findItems()` 테스트 실패! -> 이전 데이터들이 쌓여 있기 때문.

테스트에서는 **격리성**이 중요하다! 기존의 테스트 코드는 DB에 데이터가 없다는 가정하에 작성되었기 때문에 테스트가 실패했다.



## DB 분리

현재는 로컬에서 사용하는 애플리케이션 서버와 테스트에서 같은 DB를 사용하고 있기 때문에 테스트에서 문제가 발생한다.

가장 간단하게 테스트 전용 DB를 분리해보자.

- `jdbc:h2:tcp://localhost/~/test`: local에서 접근하는 서버 전용 DB
- `jdbc:h2:tcp://localhost/~/testcase`: test 케이스에서 사용하는 전용 DB



**접속 정보 변경**

`/test`에 있는 프로퍼티 파일에 접속 정보 변경!



처음 테스트는 성공하지만, 다시 실행하면 실패한다. 처음 테스트를 실행할 때 저장한 데이터가 계속 남아있기 때문!!

-> 이 문제를 해결하려면 각각의 테스트가 끝날 때마다 데이터를 삭제해주어야 한다. 그래야 다른 테스트에 영향을 주지 않는다!



테스트의 중요한 원칙

- 테스트는 다른 테스트와 격리해야 한다.
- 테스트는 반복해서 실행할 수 있어야 한다.



테스트가 끝날 때마다 `DELETE` 쿼리를 날려도 되지만, 궁극적인 해결책은 아니다. 특정 케이스에 `DELETE` 쿼리를 호출하지 못할 수도 있다.



## 데이터 롤백

이때 **트랜잭션**을 써먹으면 된다.

테스트 종료 후 트랜잭션을 강제로 롤백! 테스트가 실패해서 롤백을 호출하지 못하더라도, 트랜잭션을 커밋하지 않았으므로 DB에 해당 데이터가 반영되지 않는다.



```
1. 트랜잭션 시작
2. 테스트 A 실행
3. 트랜잭션 롤백

4. 트랜잭션 시작
5. 테스트 B 실행
6. 트랜잭션 롤백
```



각각의 테스트 실행 전 후로 동작하는 `@BeforeEach`, `@AfterEach` 사용하면 된다.



``` java
  @Autowired
  PlatformTransactionManager transactionManager;
  TransactionStatus status;

  @BeforeEach
  void beforeEach() {
    //트랜잭션 시작
    status = transactionManager.getTransaction(new DefaultTransactionDefinition());
  }

  @AfterEach
  void afterEach() {
    //MemoryItemRepository 의 경우 제한적으로 사용
    if (itemRepository instanceof MemoryItemRepository) {
      ((MemoryItemRepository) itemRepository).clearStore();
    }
    //트랜잭션 롤백
    transactionManager.rollback(status);
  }
```

- 트랜잭션 관리자는 `PlatformTransactionManager` 를 주입 받아서 사용하면 된다. 스프링 부트는 자동으로 적절한 트랜잭션 매니저를 스프링 빈으로 등록해준다.



## @Transactional

스프링은 테스트 데이터 초기화를 위해 트랜잭션을 적용하고 롤백하는 방식을 `@Transanctional` 애너테이션 하나로 깔끔하게 해결해준다.



`ItemRepositoryTest` 코드에 `@Transactional` 애너테이션 하나만 붙이면 된다.



**`@Transactional`의 원리**

원래 로직이 성공적으로 수행되면 **커밋하도록** 동작한다.

그런데 이 애너테이션을 테스트에서 사용하면, 스프링은 테스트를 트랜잭션 안에서 실행하고, 테스트가 끝나면 트랜잭션을 **자동으로 롤백**시킨다!!

트랜잭션을 테스트에서 시작하기 때문에 서비스, 리포지토리에 있는 `@Transactional` 도 테스트에서 시작한 트랜잭션에 참여한다.



**참고**

`@Commit` 애너테이션을 클래스나 메서드에 붙이면 테스트 종료 후 커밋이 호출된다. `@Rollback(value = false)`를 써도 된다.



## 임베디드 모드 DB

단순히 테스트를 검증할 용도로만 사용할거면 임베디드 모드 DB를 사용해도 좋겠다.



**임베디드 모드**

H2 데이터베이스는 JVM 안에서 메모리 모드로 동작하는 특별한 기능을 제공한다.



**ItemServiceApplication.java**

``` java
@Import(JdbcTemplateV3Config.class)
@Slf4j
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")
public class ItemServiceApplication {

  public static void main(String[] args) {
    SpringApplication.run(ItemServiceApplication.class, args);
  }

  @Bean
  @Profile("local")
  public TestDataInit testDataInit(ItemRepository itemRepository) {
    return new TestDataInit(itemRepository);
  }

  @Bean
  @Profile("test")
  public DataSource dataSource() {
    log.info("메모리 데이터베이스 초기화");
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName("org.h2.Driver");
    dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
    dataSource.setUsername("sa");
    dataSource.setPassword("");
    return dataSource;
  }
}
```

- `dataSource()`
  - `jdbc:h2:mem:db`: 데이터 소스를 만들 때 이렇게 적으면 임베디드 모드로 동작한다.
  - `DB_CLOSE_DELAY=-1`: 임베디드 모드에서는 DB 커넥션 연결이 모두 끊어지면 DB도 종료되는데, 이를 방지하는 설정

다만 이렇게 해두고 바로 실행하면 오류가 발생한다. 바로 `ITEM` 테이블이 없기 때문. 수동으로 테이블을 생성할 수도 있지만, 스프링 부트는 이 문제를 아주 편리하게 해결해준다.



**스프링 부트 - 기본 SQL 스크립트를 사용해서 DB를 초기화하는 기능**

다음 파일을 생성하면 된다.

**`src/test/resources/schema.sql`**

``` sql
drop table if exists item CASCADE;
create table item
(
 id bigint generated by default as identity,
 item_name varchar(10),
 price integer,
 quantity integer,
 primary key (id)
);
```





## 스프링 부트와 임베디드 모드

스프링 부트는 DB에 대한 별다른 설정이 없으면 임베디드 데이터베이스를 사용한다!!



`DataSource` 설정 부분, 프로퍼티 파일의 DB 접속 정보 등을 제거하면 스프링 부트가 알아서 임베디드 모드로 접근하는 데이터 소스를 만들어서 제공한다..