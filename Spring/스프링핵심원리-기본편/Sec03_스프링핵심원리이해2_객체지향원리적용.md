## 새로운 할인 정책 적용과 문제점

예제 코드에서 기존 할인 정책(`DiscountPolicy`) 인터페이스를 구현한 정액 할인 정책(`FixDiscountPolicy`) 클래스를 사용했는데, 이를 정률 할인 정책(`RateDiscountPolicy`) 로 바꿔 끼워보도록 한다.



정률 할인 정책을 애플리케이션에 적용하려면, 기존에 할인 정책이 필요한 `OrderServiceImpl` 코드를 수정해야 한다. 



```java
package hello.core.order;

public class OrderServiceImpl implements OrderService {

  private final MemberRepository memberRepository = new MemoryMemberRepository();
//  private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
  private final DiscountPolicy discountPolicy = new RateDiscountPolicy();

}
```



하지만 여기서 여러 문제점이 발생한다.

- DIP: 추상(인터페이스)뿐만 아니라, **구현체 클래스에도 의존**하고 있다. (`new ~~DiscountPolicy()`)
- OCP: 위 코드는 **기능을 확장해서 변경하면 클라이언트 코드에 영향을 주기 때문에** OCP를 위반한다.



이를 해결하기 위해서는, 추상(인터페이스)에만 의존하도록 변경해야 한다.



``` java
package hello.core.order;

public class OrderServiceImpl implements OrderService {

  private final MemberRepository memberRepository = new MemoryMemberRepository();
  private DiscountPolicy discountPolicy;

}
```



근데 이렇게 하면 구현체가 없기 때문에 실행이 안된다(NPE 발생).

-> 외부의 누군가가 클라이언트인 `OrderServiceImpl`에 `DiscountPolicy` 구현체를 넣어줘야 한다.



## 관심사의 분리

기존의 `OrderServiceImpl`코드는 직접 할인 정책 구현체를 선택하고 있었다. `new ~~~DiscountPolicy();`

-> 추가적인 책임을 갖고 있었던 것이다



**관심사를 분리하자**

- `OrderServiceImpl`은 어떤 할인 정책 구현체가 오든지 주문 데이터를 만들기만 하면 된다.



애플리케이션의 전체 동작 방식을 구성(Config)하기 위해, **구현 객체를 생성**하고, **연결**하는 책임을 갖는 별도의 설정 클래스를 만들어보자.

```java
package hello.core;

import hello.core.discount.FixDiscountPolicy;
import hello.core.member.MemberService;
import hello.core.member.MemberServiceImpl;
import hello.core.member.MemoryMemberRepository;
import hello.core.order.OrderService;
import hello.core.order.OrderServiceImpl;

public class AppConfig {

  public MemberService memberService() {
    return new MemberServiceImpl(new MemoryMemberRepository());
  }

  public OrderService orderService() {
    return new OrderServiceImpl(
        new MemoryMemberRepository(),
        new FixDiscountPolicy());
  }

}
```



이때, `MemberServiceImpl`와 `OrderServiceImpl`에서는 위에서처럼 `new ~~()` 를 통해 직접 구현체를 만드는 부분을 없애고, 구현체를 생성자를 통해서 받아오도록 한다. 이를 **생성자 주입**이라고 한다.

이렇게 되면 얘들은 모두 **의존 관계에 대한 고민은 외부(`AppConfig`)에 맡기고, 실행에만 집중**하게 된다.



클라이언트는 의존관계를 외부에서 주입해주는 것과 같다고 해서 DI(Dependency Injection), 의존관계 주입 또는 의존성 주입이라고 한다.



이제 `AppConfig`의 등장으로 애플리케이션이 크게 **사용 영역**과, 객체를 생성하고 **구성하는 영역**으로 분리되었다. 따라서 정액 할인 정책을 정률 할인 정책으로 바꾸려고 하면 구성 영역(`AppConfig`) 만 수정해주면 된다! 즉, 사용 영역은 아무런 수정을 할 필요가 없다!!







