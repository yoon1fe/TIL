### 빈 스코프란?

스코프는 빈이 존재할 수 있는 범위를 뜻한다. 스프링 빈은 기본적으로 스프링 컨테이너의 시작과 함께 생성되어, 컨테이너가 종료될 때까지 유지된다. 이는 스프링 빈은 기본적으로 싱글톤 스코프로 생성되기 때문이다.



#### 스프링이 지원하는 스코프

- **싱글톤**: 기본 스코프로, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
- **프로토타입**: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고, 더는 관리하지 않는 매우 짧은 범위의 스코프
- **웹 관련 스코프**
  - **request**: 웹 요청이 들어오고 나갈 때까지 유지되는 스코프
  - **session**: 웹 세션이 생성되고 종료될 때까지 유지되는 스코프
  - **application**: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프



빈 스코프는 다음과 같이 지정할 수 있다. 

컴포넌트 스캔 자동 등록 

``` java 
@Scope("prototype") 
@Component 
public class HelloBean {} 
```



수동 등록 

``` java
@Scope("prototype") 
@Bean PrototypeBean HelloBean() { return new HelloBean(); } 
```



### 프로토타입 스코프

싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환한다. 반면에 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 **새로운 인스턴스를 생성해서 반환**한다.



여기서 핵심은 **스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것**이다. 클라이언트에 빈을 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다. 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있다. 그래서 `@PreDestroy` 같은 종료 메서드가 호출되지 않는다.



### 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 문제점

스프링 컨테이너에 프로토타입 스코프의 빈을 요청하면 항상 새로운 객체 인스턴스를 생성해서 반환한다. 하지만 싱글톤 빈과 함께 사용할 때는 의도한 대로 잘 동작하지 않으므로 주의해야 한다.



#### 싱글톤 빈에서 프로토타입 빈 사용

스프링은 일반적으로 싱글톤 빈을 사용하므로, 싱글톤 빈이 프로토타입 빈을 사용하게 된다. 그런데 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 때문에, **프로토타입 빈이 새로 생성되기는 하지만, 싱글톤 빈과 함께 계속 유지**되는 것이 문제다. 즉, 해당 로직을 호출할 때마다 각각 생성되어 빈을 따로 사용하려 했던 원래 목적을 만족시키지 못하게 된다.



> 참고: 여러 빈에서 같은 프로토타입 빈을 주입 받으면, 주입 받는 시점에 각각 새로운 프로토타입 빈이 생성된다. 예를 들어서 clientA, clientB가 각각 의존관계 주입을 받으면 각각 다른 인스턴스의 프로토타입 빈을 주입 받는다.
>
> clientA prototypeBean@x01 
>
> clientB prototypeBean@x02 
>
> 물론 사용할 때 마다 새로 생성되는 것은 아니다.



### 프로토타입 스코프 - 싱글톤 빈과 함께 사용 시 Provider로 문제 해결

싱글톤 빈과 프로토타입 빈을 함께 사용할 때, 어떻게 하면 사용할 때 마다 항상 새로운 프로토타입 빈을 생성할 수 있을까?



#### 스프링 컨테이너에 요청

가장 간단한 방법은 싱글톤 빈이 프로토타입을 사용할 때 마다 **스프링 컨테이너에 새로 요청**(요청하는 시점에 새로 생성할거니깐)하는 것이다.



- 의존관계를 외부에서 주입(DI) 받는게 아니라 직접 필요한 의존관계를 찾는 것을 Dependency Lookup (DL) 의존관계 조회(탐색) 이라한다.

- 그런데 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다. 
- 지금 필요한 기능은 지정한 프로토타입 빈을 컨테이너에서 대신 찾아주는 딱! DL 정도의 기능만 제공하는 무언가가 있으면 된다. 



#### ObjectFactory, ObjectProvider

지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 것이 바로 `ObjectProvider` 이다. 참고로 과거에는 `ObjectFactory` 가 있었는데, 여기에 편의 기능을 추가해서 `ObjectProvider` 가 만들어졌다.



``` java
@Autowired 
private ObjectProvider prototypeBeanProvider; 

public int logic() { 
  PrototypeBean prototypeBean = prototypeBeanProvider.getObject(); 
  prototypeBean.addCount();
  
  int count = prototypeBean.getCount(); 
  
  return count; 
}
```



- 실행해보면 `prototypeBeanProvider.getObject()` 을 통해서 항상 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다. 
- `ObjectProvider` 의 `getObject()` 를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL) 
- 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다. `ObjectProvider` 는 지금 딱 필요한 DL 정도의 기능만 제공한다.





- `ObjectFactory`: 기능이 단순, 별도의 라이브러리 필요 없음, 스프링에 의존 

- `ObjectProvider`: `ObjectFactory` 상속, 옵션, 스트림 처리등 편의 기능이 많고, 별도의 라이브러리 필요 없음, 스프링에 의존



#### JSR-330 Provider

마지막 방법은 `javax.inject.Provider` 라는 JSR-330 자바 표준을 사용하는 방법이다. 이 방법을 사용하려면 `javax.inject:javax.inject:1` 라이브러리를 gradle에 추가해야 한다.



``` java
package javax.inject;
public interface Provider<T> {
 T get();
}
```



``` java
//implementation 'javax.inject:javax.inject:1' gradle 추가 필수
@Autowired
private Provider<PrototypeBean> provider;
public int logic() {
 PrototypeBean prototypeBean = provider.get();
 prototypeBean.addCount();
  
 int count = prototypeBean.getCount();
  
 return count;
}
```



- 실행해보면 `provider.get()` 을 통해서 항상 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다. 
- `provider` 의 `get()` 을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL) 
- 자바 표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다. 
- `Provider` 는 지금 딱 필요한 DL 정도의 기능만 제공한다.
- `get()` 메서드 하나로 기능이 매우 단순하다. 
- 별도의 라이브러리가 필요하다. 
- 자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용할 수 있다.



그러면 프로토타입 빈을 언제 사용할까? 

매번 사용할 때 마다 의존관계 주입이 완료된 새로운 객체가 필요하면 사용하면 된다. 그런데 실무에서 웹 애플리케이션을 개발해보면, 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에 **프로토타입 빈을 직접적으로 사용하는 일은 매우 드물다.**



### 웹 스코프

#### 웹 스코프의 특징

- 웹 환경에서만 동작한다
- 프로토타입과 다르게 스프링이 해당 스코프의 종료 시점까지 관리한다. 따라서 종료 메서드가 호출된다.



#### 스코프 종류 

- request: HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다. 
- session: HTTP Session과 동일한 생명주기를 가지는 스코프 
- application: 서블릿 컨텍스트( ServletContext )와 동일한 생명주기를 가지는 스코프 
- websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프



### request 스코프 예제 만들기





- `requestURL` 과 같은 웹과 관련된 정보는 서비스 계층에 넘기지 않는 것이 유지보수 관점에서 좋다.

스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만, request 스코프 빈은 아직 생성되지 않는다. 이 빈은 실제 고객의 요청이 와야 생성할 수 있다!



### 스코프와 Provider

`ObjectProvider`를 써서 `ObjectProvider.getObject()` 이 호출되는 시점에 request scope 빈이 생성된다. 이때는 HTTP 요청이 진행중이므로 빈 생성이 정상적으로 처리된다.



### 스코프와 프록시



`@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)`

- 적용 대상이 인터페이스가 아닌 클래스라면 `TARGET_CLASS`
- 인터페이스라면 `INTERFACES`
- 이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고, HTTP request와 상관없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.



`MyLogger` 빈은 CGLIB라는 라이브러리로 내 클래스를 상속받은 가짜 프록시 개체를 만들어 주입받은 빈이다.



- CGLIB 라는 바이트코드를 조작하는 라이브러리를 사용해서, MyLogger를 상속받은 가짜 프록시 객체를 생성한다. 
- 결과를 확인해보면 우리가 등록한 순수한 MyLogger 클래스가 아니라 `MyLogger$ $EnhancerBySpringCGLIB` 이라는 클래스로 만들어진 객체가 대신 등록된 것을 확인할 수 있다.
- 그리고 스프링 컨테이너에 "myLogger"라는 이름으로 진짜 대신에 이 가짜 프록시 객체를 등록한다. 
- `ac.getBean("myLogger", MyLogger.class)` 로 조회해도 프록시 객체가 조회되는 것을 확인할 수 있다. 그래서 의존관계 주입도 이 가짜 프록시 객체가 주입된다



**가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다.** 

- 가짜 프록시 객체는 내부에 진짜 myLogger를 찾는 방법을 알고 있다. 
- 클라이언트가 myLogger.logic() 을 호출하면 사실은 가짜 프록시 객체의 메서드를 호출한 것이다. 
- 가짜 프록시 객체는 request 스코프의 진짜 myLogger.logic() 를 호출한다. 
- 가짜 프록시 객체는 원본 클래스를 상속 받아서 만들어졌기 때문에 이 객체를 사용하는 클라이언트 입장에서는 사실 원본인지 아닌지도 모르게, 동일하게 사용할 수 있다.(다형성)





##### 특징 정리 

- 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 request scope를 사용할 수 있다. 
- 사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 **지연처리** 한다는 점이다. 
- 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. **이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다**. 
- 꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다. 



##### 주의점 

- 마치 싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 결국  주의해서 사용해야 한다.
- 이런 특별한 scope는 꼭 필요한 곳에만 최소화해서 사용하자, 무분별하게 사용하면 유지보수하기 어려워진다.
