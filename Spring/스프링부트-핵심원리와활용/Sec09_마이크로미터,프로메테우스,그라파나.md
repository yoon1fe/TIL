## 마이크로미터

모니터링 참 중요하다~! 어떤 지표?

- 애플리케이션 CPU
- 메모리
- 커넥션 사용량
- 고객 요청수 등등...



모니터링 툴이 동작하려면 시스템의 다양한 지표들을 각각의 모니터링 툴에 맞도록 만들어서 보내주어야 함. 

중간에 사용하는 모니터링 툴을 변경하면? 기존에 측정했던 코드를 모두 변경한 툴에 맞도록 변경해야 한다.. 이런 문제를 해결하는 것이 바로 **마이크로미터(Micrometer)**라는 라이브러리~ 추상화!



**마이크로미터 추상화**

- CPU, JVM 상태값 등을 마이크로미터 표준 측정 방식에 맞추어 측정하고, micrometer JMX 구현체, micrometer 프로메테우스 구현체 등을 구현.

- 마이크로미터는 애플리케이션 메트릭 파사드라고 불리는데, 애플리케이션의 메트릭(측정 지표)을 마이크로미터각 정한 표준 방법으로 모아서 제공해준다.

- 스프링 부트 액츄에이터가 마이크로미터 라이브러리를 기본으로 내장해서 사용중.

- 마이크로미터가 지원하는 모니터링 툴은 어어어엄청 많다.



## 메트릭 확인

CPU, JVM, 커넥션 사용량 등 수 많은 지표들을 어떻게 수집해야 할까?

마이크로미터는 다양한 지표 수집 기능을 만들어서 제공한다. + 스프링 부트 액츄에이터는 마이크로미터가 제공하는 지표 수집을 `@AutoConfiguration`을 통해 자동 등록해줌.



**metrics 엔드 포인트**

- `/metrics` 엔드 포인트를 사용하면 기본으로 제공하는 메트릭 확인 가능

- 다음과 같은 패턴으로 자세히 볼 수 있음

  `/metrics/{name}`



**Tag 필터**

- `availableTags`를 보면 다음과 같은 항목

  - `tag:area , values[heap, nonheap]`
  - `tag:id , values[G1 Survivor Space, ...]`

- 해당 Tag를 기반으로 정보를 필터링해서 조회 가능

  `/metrics/jvm.memory.used?tag=area:heap`



## 다양한 메트릭

- JVM 메트릭
- 시스템 메트릭
- 애플리케이션 시작 메트릭
- 스프링 MVC 메트릭
- 톰캣 메트릭
- 등등..
- 사용자가 메트릭을 직접 정의하는 것도 가능!



이러한 메트릭들은 DB 등에 과거의 데이터들도 확인할 수 있어야 함 + 그래프를 통해 쉽게 볼 수 있는 대시보드도 필요함!



## 프로메테우스, 그라파나

**프로메테우스**

- 위에서 말한 과거의 메트릭 데이터들을 보관하는 역할을 담당.



**그라파나**

- 매우 유연하고, 데이터를 그래프로 보여주는 대시보드 툴. 프로메테우스를 포함한 다양한 데이터 소스를 지원한다.



**전체 구조**

1. 스프링 부트 액츄에이터와 마이크로미터를 사용하면 수 많은 메트릭을 자동으로 생성한다. 
   - 마이크로미터 프로메테우스 구현체는 프로메테우스가 읽을 수 있는 포멧으로 메트릭을 생성한다. 
2. 프로메테우스는 이렇게 만들어진 메트릭을 지속해서 수집한다.
3. 프로메테우스는 수집한 메트릭을 내부 DB에 저장한다. 
4. 사용자는 그라파나 대시보드 툴을 통해 그래프로 편리하게 메트릭을 조회한다. 이때 필요한 데이터는 프로메테우스를 통해서 조회한다.



![Prometheus architecture](https://prometheus.io/assets/architecture.png)



### 프로메테우스

#### 애플리케이션 설정

프로메테우스가 우리 애플리케이션의 메트릭을 수집하도록 연동하려면 두 가지 작업이 필요함.

1. 애플리케이션 설정: 프로메테우스가 우리 애플리케이션의 메트릭을 가져갈 수 있도록 애플리케이션에서 프로메테우스 포맷에 맞추어 메트릭 생성
2. 프로메테우스 설정: 프로메테우스가 우리 애플리케이션의 메트릭을 주기적으로 수집하도록 설정



**애플리케이션 설정**

- 프로메테우스는 JSON 포맷 이해하지 못한다. 하지만 마이크로미터가 해결해줌.



```groovy
implementation 'io.micrometer:micrometer-registry-prometheus'
```

- build.gradle 에 마이크로미터 프로메테우스 구현 라이브러리 추가
- 추가하면 스프링 부트와 액츄에이터가 자동으로 마이크로미터 프로메테우스 구현체를 등록해서 동작하도록 설정해준다.
- 액추에이터에 `/actuator/prometheus` 엔드포인트가 자동으로 추가됨.



**포맷 차이**

- `.` -> `_` ex) `jvm.info` -> `jvm_info`
- `logback.events` -> `logback_events_total`: 프로메테우스는 카운터 메트릭(증가하는 지표)의 마지막에 관례상 `_total`을 붙인다.



#### 수집 설정

프로메테우스가 애플리케이션의 `/actuator/prometheus` 를 호출해서 메트릭을 주기적으로 수집하도록 설정해보자.

프로메테우스 폴더에 있는 `prometheus.yml` 파일 수정 필요.



**추가한 부분**

```yml
  # 추가
  - job_name: "spring-actuator"
    metrics_path: '/actuator/prometheus'
    scrape_interval: 1s
    static_configs:
      - targets: ['localhost:8080']
```

- `job_name`: 수집하는 임의의 이름.
- `metrics_path`: 수집할 경로 지정
- `scrape_interval`: 수집할 주기 설정. default: 1ms
- `targets`: 수집할 서버의 IP, PORT 지정

**연동 확인**

- `http://localhost:9090/config`
- `http://localhost:9090/targets`



#### 기본 기능

- 마이크로미터의 태그(Tag) == 프로메테우스의 레이블(Label)



#### 게이지와 카운터

**게이지(Gauge)**

- 임의로 오르내릴 수 있는 값
- CPU 사용량, 메모리 사용량, 커넥션 사용량
- 현재 상태를 그대로 출력하면 된다.



**카운터(Counter)**

- 단순하게 증가하는 단일 누적 값
- HTTP 요청 수, 로그 발생 건수

- 그래프로 보면 특정 시간대에 고객의 요청 등이 얼마나 들어왔는지 한 눈에 확인하기 어렵다.
  - 이러한 문제를 해결하기 위해 `increase()`, `rate()` 와 같은 함수를 지원한다.



**increase()**

- 지정한 시간 단위별로 증가를 확인할 수 있음.
- `increase(http_server_requests_seconds_count{uri="/log"}[1m])`



**rate()**

- 범위 벡터에서 초당 평균 증가율을 계산

- 초당 얼마나 증가하는지 나타내는 지표로 보면 된다.



**irate()**

- 범위 벡터에서 초당 순간 증가율을 계산
- 급격하게 증가한 내용을 확인하기 좋다.



프로메테우스의 단점은 한 눈에 들어오는 대시보드를 만들어보기 어렵다는 점이다.. 이 부분은 그라파나를 사용하면 된다!



### 그라파나

#### 연동

그라파나는 프로메테우스를 통해 데이터를 조회하고 보여준다. 즉 그라파나는 대시보드의 껍데기 역할.



#### 대시보드

다음 3가지 꼭 수행되어야 함

1. 애플리케이션 실행
2. 프로메테우스 실행
3. 그라파나 실행



**패널**

- 대시보드가 큰 틀이라면 패널은 그 안에 들어가는 모듈처럼 들어가는 실제 그래프를 보여주는 컴포넌트.

Data source 추가하고, 패널 생성해서 프로메테우스로 수집된 데이터를 그래프 형식으로 보여줄 수 있음.



#### 공유 대시보드 활용

https://grafana.com/grafana/dashboards/ 에 많음



#### 메트릭을 통한 문제 확인

다음 대표적인 4가지 케이스

- CPU 사용량 초과
- JVM 메모리 사용량 초과
- 커넥션 풀 고갈
- 에러 로그 급증