## 4.1 MySQL 엔진 아키텍처

MySQL 서버는 크게

- **MySQL 엔진** (머리)
- **스토리지 엔진** (손/발)

로 나뉜다.



![스크린샷 2022-02-17 오후 10 53 36](https://user-images.githubusercontent.com/66231761/154495756-a73e38e2-15d5-42d1-9a33-929f32bb6d91.png)

- MySQL 서버는 다른 DBMS들과는 다르게 독특한 구조를 갖고 있다. 이에 따른 장단점이 있음



**MySQL 엔진**

- 요청된 SQL 문장을 분석/최적화하는 역할을 수행

- 커넥션 핸들러: 클라이언트로부터의 접속 및 쿼리 요청 처리
- SQL 파서
- 전처리기
- 옵티마이저: 쿼리 최적화 실행



**스토리지 엔진**

- 실제 데이터를 디스크 스토리지에 저장/읽어오는 역할을 수행

- MySQL 엔진은 하나지만 스토리지 엔진은 여러 개 동시 사용 가능.

  `mysql > CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;` > `test_table` 테이블은 InnoDB 스토리지 엔진 사용하도록 정의

- 성능 향상을 위해 키 캐시(MyISAM)나 버퍼 풀(InnoDB) 기능 내장



**핸들러 API**

- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽을 때 각 스토리지 엔진에 요청(Handler)할 때 사용되는 API
- MySQL 엔진 <-> 스토리지 엔진



### 스레딩 구조

![스크린샷 2022-02-17 오후 10 54 05](https://user-images.githubusercontent.com/66231761/154495833-4b893782-b85c-4349-bdb5-801c89d037ae.png)

MySQL 은 프로세스 기반이 아니라 스레드를 기반으로 동작한다.



**포그라운드(foreground) 스레드(클라이언트 스레드, 사용자 스레드)**

- 최소 MySQL 서버에 접속된 클라이언트 수만큼 존재
- 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
- 데이터를 MySQL 데이터 버퍼나 캐시로부터 가져오고, 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어온다.
- MyISAM - 디스크 쓰기 작업까지 포그라운드 스레드가 처리
- InnoDB - 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리. 버퍼 ~ 디스크까지 기록하는 작업은 백그라운드 스레드가 처리.



**백그라운드(background) 스레드**

(MyISAM 스토리지 엔진은 해당 사항 별로 없음)

- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드



>  전통적인 스레드 모델 - 커넥션 별로 포그라운드 스레드 하나씩 생성/할당
>
> 스레드 풀 모델 - 하나의 스레드가 여러 개의 커넥션 요청을 담당



### 메모리 할당 / 사용 구조

- 글로벌 메모리 영역
- 로컬 메모리 영역

으로 구분.



**글로벌 메모리 영역**

글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 MySQL 시스템 변수로 설정한 값만큼의 메모리를 OS로부터 할당된다.

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두(re do) 로그 버퍼



**로컬 메모리 영역 (= 세션 메모리 영역, 클라이언트 메모리 영역)**

클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역.

클라이언트 <-> MySQL 서버와의 커넥션을 세션이라고 하기 때문에 세션 메모리 영역이라고도 함.

각 클라이언트 스레드 별로 독립적으로 할당되고 절대 공유되지 않는다.

- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼



### 플러그인 스토리지 엔진 모델

스토리지 엔진, 전문 검색 엔진을 위한 검색어 파서, 사용자 인증 위한 기능 등등이 플러그인으로 제공된다.



**쿼리가 실행되는 과정**

`{SQL 파서 - SQL 옵티마이저 - SQL 실행기} (MySQL 엔진 처리) - {데이터 R/W} (스토리지 엔진이 처리) - 디스크`

- MySQL 엔진 - (핸들러) - 스토리지 엔진
  - MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽거나 저장하도록 명령하려면 반드시 핸들러를 통해야 함
- `GROUP BY` 나 `ORDER BY` 등 복잡한 처리는 MySQL 엔진이 처리(쿼리 실행기)한다.
- 물론 데이터 읽기/쓰기 작업 처리 방식에 따라 쿼리 성능이 천차만별로 차이난다.



### 컴포넌트

8.0 부터 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 도입됨. 아래와 같은 플러그인 아키텍처의 단점을 보완해준다.

- MySQL 서버하고만 인터페이스할 수 있고, 플러그인끼리는 통신 불가
- MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
- 상호 의존 관계를 설정할 수 없어서 초기화 어려움

8.0 부터는 비밀번호 검증 기능이 컴포넌트로 개선됐다.



### 쿼리 실행 구조

![스크린샷 2022-02-17 오후 10 54 55](https://user-images.githubusercontent.com/66231761/154495992-9093bdc4-a539-4dc0-9ee1-e6d35a726d60.png)



**쿼리 파서**

- 요청 들어온 쿼리 문장을 MySQL이 인식할 수 있는 최소 단위의 어휘나 기호인 토큰으로 분리해 트리 구조로 만드는 작업
- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견된다.



**전처리기**

- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점 있는지 확인.
- 각 토큰을 테이블 이름, 컬럼 이름 등 개체를 매핑해 해당 객체의 존재 여부나 객체 접근 권한을 확인한다.
- 존재하지 않거나 권한이 없는 개체의 토큰은 여기서 걸러짐.



**옵티마이저**

- 요청 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리하는 방법을 결정. (DBMS의 두뇌)



**실행 엔진, 핸들러 (스토리지 엔진)**

ex) 옵티마이저가 `GROUP BY`를 처리하기 위해 임시 테이블을 사용하기로 결정했을 때

1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
2. `WHERE` 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블에 저장하라고 다시 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김



### 쿼리 캐시

SQL의 실행 결과를 메모리에 캐싱하고, 동일 쿼리가 요청오면 테이블을 읽지 않고 즉시 결과를 반환한다. 하지만 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들은 모두삭제해야 함. => 동시 처리 성능 저하 유발

**따라서 8.0 부터는 쿼리 캐시 기능은 제거됨!!**



### 스레드 풀

엔터프라이즈 버전만 스레드 풀 기능 제공.



## 4.2 InnoDB 스토리지 엔진 아키텍처





## 4.3 MyISAM 스토리지 엔진 아키텍처





## 4.4 MySQL 로그 파일