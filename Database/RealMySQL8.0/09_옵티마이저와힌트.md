MySQL로 요청된 쿼리는 결과는 동일하지만 내부적으로 그 결과를 만들어내는 방법은 매우 다양하다. 이 중에섯 어떤 방법이 최적이고 최소의 비용이 들지 결정해야 한다. MySQL에서는 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계 정보를 참조하여, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다. 대부분의 DBMS에서는 **옵티마이저**가 이러한 기능을 담당한다.



## 9.1 개요



### 쿼리 실행 절차

MySQL 서버에서 쿼리가 실행되는 과정은 크게 세 단계로 나눌 수 있다.

1. **SQL 파싱**: 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(parse tree) 한다.

   SQL 파서 모듈로 처리한다. 쿼리가 문법적으로 잘못되었다면 이 단계에서 걸러진다. MySQL 서버는 이 단계에서 만들어진 SQL 파스 트리를 이용해 쿼리를 실행한다.

2. **최적화 및 실행 계획 수립**: SQL의 파싱 정보(parse tree)를 확인하면서 **옵티마이저**가 다음과 같은 내용을 처리한다. 이 단계가 완료되면 **실행 계획**이 만들어진다.

   - 불필요한 조건 제거 및 복잡한 연산의 단순화
   - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
   - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
   - 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는지 결정

3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다. MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬한다.



1~2 단계는 거의 MySQL 엔진에서 처리하며, 세 번째 단계는 MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리한다.



### 옵티마이저의 종류

옵티마이저는 현재 대부분의 DBMS가 선택하고 있는 **비용 기반 최적화(Cost-Based Optimizer, CBO)**와 초기 버전의 오라클 DBMS에서 많이 사용했던 **규칙 기반 최적화(Rule-Based Optimizer, RBO)**로 나눌 수 있다.



- 규칙 기반 최적화: 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다. 이 방식에서는 레코드 건수나 칼럼값의 분포도같은 통계 정보를 조사하지 않기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어낸다. 하지만 사용자의 데이터는 분포도가 매우 다양하기 때문에 RBO는 거의 사장되었다.
- 비용 기반 최적화: 쿼리를 처리하기 위한 여러 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 각 실행 계획별로 비용을 산출한다. 이 중 비용이 최소로 소모되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.



## 9.2 기본 데이터 처리

모든 RDBMS는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 갖고 있다. MySQL 서버에서는 이런 기본적인 가공을 위해 어떤 알고리즘을 사용하는지 알아 보자.



### 풀 데이터 스캔과 풀 인덱스 스캔

풀 데이터 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 작업을 처리하는 작업이다. MySQL 옵타마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.

- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
- `WHERE` 절이나 `ON` 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우(인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)



일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 대부분의 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어온다. 하지만 MySQL에는 이러한 기능을 설정하는 시스템 변수가 따로 없다. 그래서 MySQL은 풀 테이블 스캔을 실행할 때 디스크로부터 페이지를 하나씩 읽어 오는 것으로 생각할 수 있지만, 이는 MyISAM 에는 맞는 얘기지만 InnoDB에서는 틀린 말이다.

InnoDB에서는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read ahead) 작업이 자동으로 시작된다. 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요할 것이라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 가져다 두는 것을 의미한다. 즉, 풀 테이블 스캔이 실행되면 처음 몇 개는 클라이언트 스레드가 페이지 읽기를 실행하지만, 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다. 백그라운드 스레드는 한 번에 4개 또는 8개씩 페이지를 읽으면서 그 수를 증가시키고, 한 번에 최대 64개의 데이터 페이지를 읽어서 버퍼 풀에 저장해 둔다. 클라이언트 스레드는 버퍼 풀에 있는 데이터를 읽기만 하면 돼서 쿼리가 빨리 처리되는 것이다. MySQL 서버에서는 `innodb_read_ahead_threshold` 시스템 변수로 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다.



리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용된다. 예를 들어 아래 쿼리처럼 레코드 건수만 조회하는 쿼리는 용량이 작은 인덱스를 스캔하는 것이 디스크 읽기 횟수를 줄일 수 있기 때문에 풀 인덱스 스캔을 선택할 가능성이 높다. 보통 인덱스는 칼럼 2~3개로 이루어져 있기 때문에 테이블 자체보다 용량이 작아서 훨씬 빠른 처리가 가능하다.

``` sql
SELECT COUNT(*) FROM employees;
```



### 병렬 처리

용도가 한정되어 있긴 하지만, 8.0부터 처음으로 쿼리의 병렬 처리(하나의 쿼리를 여러 스레드가 동시에 처리)가 가능해졌다. `innodb_parallel_read_threads` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경할 수 있다. 아래 예제와 같이 아무런 `WHERE` 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.

``` sql
SELECT COUNT(*) FROM salaries;
```



책을 보면 병렬 처리하는 스레드 수가 늘어날수록 쿼리 처리 속도가 빨라지는 것을 확인할 수 있다. 하지만 스레드 개수를 아무리 늘려도 서버의 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수 있다.



### ORDER BY 처리(Using filesort)

정렬을 처리하는 방법은 **인덱스를 이용하는 방법**과 **쿼리가 실행될 때 "Filesort"라는 별도의 처리를 이용하는 방법**으로 나뉜다.



인덱스 이용

- 장점
  - `INSERT`, `UPDATE`, `DELETE` 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.
- 단점
  - `INSERT`, `UPDATE`, `DELETE` 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하다.
  - 인덱스때문에 디스크 공간이 더 많이 필요하다.
  - 인덱스 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 많이 필요하다.



Filesort 이용

- 장점
  - 인덱스를 생성하지 않아도 돼서 인덱스 이용할 때의 단점이 장점이 된다.
  - 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.
- 단점
  - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리 응답 속도가 느리다.



레코드를 정렬할 때 항상 Filesort 정렬 작업을 거쳐야 하는 것은 아니지만, 다음과 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하는 것은 거의 불가능하다.

- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- `GROUPY BY`의 결과 또는 `DISTINCT` 같은 처리의 결과를 정렬해야 하는 경우
- `UNION`의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우



Filesort 정렬 처리를 수행했는지는 실행 계획의 `Extra` 칼럼에 "Using filesort" 메시지 표시 여부로 확인할 수 있다.



#### 소트 버퍼

소트 버퍼(Sort buffer)는 MySQL이 정렬을 수행할 때 할당받는 별도의 메모리 공간을 말한다. 소트 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적이지만 최대 사용 가능한 크기는 `sort_buffer_size`시스템 변수로 설정할 수 있다. 소트 버퍼 메모리 공간은 쿼리 실행이 끝나면 즉시 시스템으로 반납된다.



정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크면 MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 정렬 결과를 디스크에 저장한다. 그리고 다음 레코드를 가져와서 다시 정렬해서 다시 디스크에 임시 저장하고, 마지막으로 버퍼 크기만큼 정렬된 레코드들을 다시 병합하면서 정렬을 수행한다. 이 병합 작업을 멀티 머지(Multi-merge)라고 하며, 수행된 멀티 머지 횟수는 `Sort_merge_passes`라는 상태 변수에 누적해서 집계된다. 이 작업 모두 디스크 I/O를 유발하며, 레코드 건수가 많을수록 이러한 반복 작업의 횟수가 많아진다. 소트 버퍼 사이즈를 크게 설정하면 디스크를 덜 사용해서 더 빨라질 것으로 생각할 수도 있지만, 실제 벤치마크 결과로는 큰 차이가 없었다고 한다. 리눅스 계열에서는 오히려 너무 큰 `sort_buffer_size`는 큰 메모리 공간 할당때문에 성능이 훨씬 떨어질 수 있다.



소트 버퍼는 글로벌 메모리 영역과 세션(로컬) 메모리 영역 중 세션 영역에 해당한다. 즉, 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니다. 따라서 커넥션이나 정렬 작업이 많을수록 소트 버퍼로 소비되는 메모리 공간이 커진다. 운영체제가 메모리 부족 현상을 겪으면 OOM-Killer가 프로세스를 강제로 종료하는데, 일반적으로 메모리를 가장 많이 사용하는 MySQL 서버가 강제 종료 1순위가 될 것이다.



#### 정렬 알고리즘

레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지, 정렬 기준 칼럼만 담을지에 따라 "싱글 패스(Single-pass)"와 "투 패스(Two-pass)" 두 가지 정렬 모드로 나눌 수 있다. 정렬을 수행하는 쿼리가 어떤 정렬 모드를 사용하는지는 다음과 같이 옵티마이저 트레이스 기능으로 확인할 수 있다.



``` mysql
-- // 옵티마이저 트레이스 활성화
mysql> SET OPTIMIZER_TRACE="enabled=on", END_MARKERS_IN_JSON=on;
mysql> SET OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;

-- // 쿼리 실행
mysql> SELECT * FROM employees ORDER BY last_name LIMIT 100000, 1;

-- / 트레이스 내용 확인
mysql> SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE \G
...

				"filesort_summary" : {
					"memory_available" : 262144,
					"key_size" : 32,
					"row_size" : 169,
					...
					"sort_algorithm" : "std::stable_sort",			-- // 정렬 알고리즘
					"sort_mode" : "<fixed_sort_key, packed_additional_fields>"
				}	/* filesort_summary */
...
```



`sort_mode` 필드에서 정렬 방식을 확인할 수 있는데, 다음과 같이 세 가지가 있다.

- `<sort_key, rowid>`: 정렬 키와 레코드의 row id만 가져와서 정렬
- `<sort_key, additional_fields>`: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈로 메모리에 저장
- `<sort_key, packed_additional_fields>`: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 가변 사이즈로 메모리에 저장



여기서 첫 번째 방법을 "투 패스" 정렬 방식이라고 하고, 두 번째와 세 번째 방식을 "싱글 패스"라고 한다(정식 명칭 아님).



##### 싱글 패스 정렬 방식

소트 버퍼에 정렬 기준 칼럼을 포함해 `SELECT` 의 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 방식이다.

``` sql
SELECT emo_no, first_name, last_name
FROM employees
ORDER BY first_name;
```



위 쿼리를 싱글 패스 정렬 방식으로 처리하는 절차는 다음과 같다.

![img](https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2F1100bee2-1b93-4fe5-a67c-6385dfdc7fe5%2Fimage.png)



##### 투 패스 정렬 방식

정렬 대상 칼럼과 PK 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 PK로 테이블을 읽어서 필요한 칼럼을 가져오는 정렬 방식으로, 싱글 패스 정렬 방식이 도입되기 이전부터 사용하던 방식이다. 하지만 8.0에서도 다음과 같은 특정 조건에서는 이 정렬 방식을 사용한다.

- 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 칼럼이 `SELECT` 대상에 포함할 때



![img](https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2F0f2fcee3-d659-4b29-bac0-cf8f7f2660e4%2Fimage.png)



처음 읽을 때 정렬에 필요한 `first_name` 칼럼와 PK인 `emp_no`만 읽어서 정렬을 수행한다. 정렬이 끝나면 그 결과 순서대로 테이블을 한 번 더 읽어서 `last_name`을 가져오고 최종 결과를 클라이언트에게 넘겨준다.



투 패스 방식은 테이블을 두 번 읽어야 하는 불편함이 있지만, 싱글 패스는 한 번만 읽으면 된다. 하지만 싱글 패스 방식은 더 많은 소트 버퍼 공간이 필요하다. 싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 성능이 좋고, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이라고 볼 수 있다.



#### 정렬 처리 방법

쿼리에 `ORDER BY`가 사용되면 반드시 다음 세 가지 처리 방법 중 하나로 정렬이 처리된다. 일반적으로 아래로 갈수록 처리 속도가 떨어진다.



| 정렬 처리 방법                                  | 실행 계획의 Extra 칼럼 내용       |
| ----------------------------------------------- | --------------------------------- |
| 인덱스를 사용한 정렬                            | X                                 |
| 조인에서 드라이빙 테이블만 정렬                 | "Using filesort"                  |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | "using temporary; Using filesort" |



옵티마이저는 먼저 정렬을 위해 인덱스 사용 여부를 확인할 것이다. 인덱스를 이용할 수 있다면 별도의 filesort 과정 없이 처리가 가능하지만, 그렇지 않다면 `WHERE` 조건에 일치하는 레코드를 검색해서 소트 버퍼에 저장하면서 정렬을 처리(Filesort)한다. 이때 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음 두 가지 방법 중 하나를 선택한다.

- 조인에서 드라이빙 테이블만 정렬
- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬



일반적으로 조인이 수행되면서 레코드 건수와 크기는 거의 배수로 불어나기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 수행하는 방법이 효율적이다.



##### 인덱스를 이용한 정렬

인덱스를 이용한 정렬을 위해서는 반드시 `ORDER BY` 에 명시된 칼럼이 제일 먼저 읽는 테이블(조인의 경우 드라이빙 테이블)에 속하고, `ORDER BY`의 순서대로 생성된 인덱스가 있어야 한다. 또한 `WHERE` 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 `ORDER BY` 는 같은 인덱스를 사용할 수 있어야 한다. 그리고 B-Tree 계열 인덱스에서만(R-Tree 제외) 인덱스를 이용한 정렬을 사용할 수 있다. 여러 테이블이 조인되는 경우에는 Nested-loop 방식의 조인에서만 이 방식을 이용할 수 있다.



이 방식을 사용하는 경우, `ORDER BY`가 있든 없든 정렬된 결과를 얻을 수 있다. `ORDER BY` 절이 명시되어 있다고 해도 이미 정렬된 데이터를 한 번 더 정렬하진 않는다. 만약 어떤 이유로 실행 계획이 변경될 경우 정렬된 결과를 얻지 못할 수도 있으므로 `ORDER BY` 절을 명시해두는 것이 좋다.



##### 조인의 드라이빙 테이블만 정렬

이 방법으로 정렬이 처리되려면 첫 번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 `ORDER BY` 절을 작성해야 한다.



``` sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
	AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY e.last_name;
```



위 쿼리에서는 `WHERE` 절이 다음 두 가지 조건을 만족하기 때문에 옵티마이저는 `employees` 테이블을 드라이빙 테이블로 선택한다.

- `WHERE` 절의 검색 조건(`emp_no BETWEEN 100002 AND 100010`) 은 `employees` 테이블의 PK를 이용해 검색하면 작업량을 줄일 수 있다.
- 드리븐 테이블(`salaries`)의 조인 칼럼인 `emp_no` 칼럼에 인덱스가 있다.



옵티마이저는 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고, 그 결과와 `salaries` 테이블을 조인한다. 그 과정은 다음과 같다.

1. 인덱스를 이용해 `emp_no BETWEEN 100002 AND 100010` 조건을 만족하는 9건 검색
2. 검색 결과를 `last_name` 칼럼으로 정렬을 수행(filesort)
3. 정렬된 결과를 순서대로 읽으면서 `salaries` 테이블과 조인을 수행해 86건의 최종 결과를 가져옴(아래 그림의 오른쪽에 번호는 레코드가 조인되어 출력되는 순서를 의미).



![img](https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2F46a91502-b2c8-4a59-8e7b-0ec5910f9eae%2Fimage.png)



##### 조인에서 조인 결과를 임시 테이블로 저장 후 정렬

두 개 이상의 테이블을 조인해서 그 결과를 조인해야 하는 쿼리라면 임시 테이블이 필요할 수 있다. 이 방법은 정렬의 세 가지 방법 중 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느리다.



``` sql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
	AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY s.salary;
```



위의 쿼리 역시 `employees`가 드라이빙 테이블이 된다. 하지만 이 쿼리는 드리븐 테이블인 `salaries` 에 있는 칼럼을 기준으로 정렬하려 한다. 즉, 정렬이 수행되기 전에 `salaries` 테이블을 읽어야 하므로 이 쿼리는 조인된 데이터를 갖고 정렬할 수밖에 없다. 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬 처리하는 것이다.



![img](https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2Fe3ffb869-8f93-4ca3-8d7e-54bbb01d0743%2Fimage.png)



#### 정렬 처리 방법의 성능 비교

웹 서비스용 쿼리에서는 주로 `ORDER BY`와 함께 `LIMIT`가 많이 사용되는데, `ORDER BY`나 `GROUP BY` 절은 `WHERE` 조건을 만족하는 레코드를 `LIMIT` 건수만큼만 가져와서 처리할 순 없다. `WHERE` 조건이 아무리 인덱스를 잘 타도록 튜닝해도 잘못된 `ORDER BY`나 `GROUP BY` 때문에 쿼리가 느려질 수 있다.



쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 작동하는지 확인해보자. 이를 위해 쿼리가 처리되는 방법을 **스트리밍 처리**와 **버퍼링 처리**라는 두 가지 방식으로 구분한다.



##### 스트리밍 처리

서버쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식을 의미한다. 이 방식으로 쿼리를 처리할 경우 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 전달받는다.

웹 서비스같은 OLTP 환경에서는 쿼리의 요청에서부터 첫 번째 레코드를 받기까지의 응답 시간이 중요한데, 이 방식은 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간을 보장해준다. `LIMIT` 조건을 추가하면 가져오는 전체 레코드 건수가 줄어들기 때문에 마지막 레코드를 가져오기까지의 시간을 상당히 줄일 수 있다. 인덱스를 사용한 정렬 방식이 이 스트리밍 처리 방식이다.



##### 버퍼링 방식

`ORDER BY`나 `GROUP BY` 에 대한 결과는 스트리밍 처리가 될 수 없다. `WHERE` 조건에 일치하는 모든 레코드를 가져 온 후에 후처리를 하기 때문이다. 버퍼링으로 처리되는 쿼리는 먼저 결과를 모아서 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진에서 가져올 때까지 기다려야 한다. 그래서 버퍼링 방식에서는 `LIMIT` 처럼 결과 건수를 제한하는 조건이 있어도 성능 향상이 별로 없다. MySQL 서버가 해야 하는 작업량에는 별 변화가 없기 때문이다. 인덱스를 사용한 정려 방식을 제외한 나머지는 모두 버퍼링된 후에 정렬된다.





``` sql
SELECT *
FROM tb_test1 t1, tb_test2 t2
WHERE t1.col1=t2.col2
ORDER BY t1.col2
LIMIT 10;
```



`tb_test1` 테이블의 레코드가 100건이고, `tb_test2` 테이블의 레코드가 1,000건(`tb_test1`의 레코드 1건 당 `tb_test2`의 레코드가 10건씩 존재한다고 가정)이며, 두 테이블의 조인 결과는 전체 1,000건이라고 가정하고 정렬의 처리 방식별로 읽어야 하는 레코드 건수와 정렬을 수행해야 하는 레코드 건수를 비교해 보자.



- `tb_test1`이 드라이빙되는 경우

| 정렬 방식                | 읽어야 할 건수                     | 조인 횟수                                           | 정렬해야 할 대상 건수                               |
| :----------------------- | ---------------------------------- | --------------------------------------------------- | --------------------------------------------------- |
| 인덱스 사용              | tb_test1 : 1건 tb_test2 : 10건     | 1번                                                 | 0건                                                 |
| 드라이빙 테이블만 정렬   | tb_test1 : 100건 tb_test2 : 10건   | 10번                                                | 100건 (tb_test1 테이블의 레코드 건수만큼 정렬 필요) |
| 임시 테이블 사용 후 정렬 | tb_test1 : 100건 tb_test2 : 1000건 | 100번 (tb_test1 테이블의 레코드 건수만큼 조인 발생) | 1,000건(조인된 결과 레코드 건수를 전부 정렬해야 함) |



- `tb_test2`가 드라이빙되는 경우

| 정렬 방식                    | 읽어야 할 건수                     | 조인 횟수                                             | 정렬해야 할 대상 건수                                 |
| ---------------------------- | ---------------------------------- | ----------------------------------------------------- | ----------------------------------------------------- |
| 인덱스 사용                  | tb_test2 : 10건 tb_test1 : 10건    | 10번                                                  | 0건                                                   |
| 드라이빙 테이블만 정렬       | tb_test2 : 1000건 tb_test1 : 10건  | 10번                                                  | 1,000건 (tb_test2 테이블의 레코드 건수만큼 정렬 필요) |
| 임시 테이블을 사용한 후 정렬 | tb_test2 : 1000건 tb_test1 : 100건 | 1,000번 (tb_test2 테이블의 레코드 건수만큼 조인 발생) | 1000건 (조인된 결과 레코드 건수 를 전부 정렬해야 함)  |



어느 테이블이 먼저 드라이빙되어 조인되는지도 중요하지만 어떤 정렬 방식으로 처리되는지가 더 큰 성능 차이를 만든다. 가능하다면 인덱스를 사용한 정렬로 유도하고, 그렇게 못하면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법이라고 할 수 있다.



#### 정렬 관련 상태 변수

MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장한다. 정렬과 관련해서도 지금까지 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업(멀티 머지)은 몇 번이나 발생했는지 등을 다음과 같은 명령으로 확인해 볼 수 있다.



```sql
mysql > SHOW SESSION STATUS LIKE 'Sort%';
+---------------------+---------+
| Variable name       | Value   |
+---------------------+---------+
| Sort_merge_passes   | 56      |
| Sort_range          | 0       |
| Sort_rows           | 279408  |
| Sort_scan           | 1       |
+---------------------+---------+

mysql > SELECT first_name, last_name
        FROM employees
        GROUP BY first_name, last_name;

mysql > SELECT first_name, last_name
        FROM employees
        GROUP BY first_name, last_name;

mysql > SHOW SESSION STATUS LIKE 'Sort%';
+----------------------+------------+
| Variable name        | Value      |
+----------------------+------------+
| Sort_merge_passes    | 112        |
| Sort_range           | 0          |
| Sort_rows            | 558816     |
| Sort_scan            | 2          |
+----------------------+------------+
```



### GROUP BY 처리

`GROUP BY` 또한 스트리밍 처리를 할 수 없다. `GROUP BY` 가 있는 쿼리에서는 `HAVING` 절을 사용할 수 있는데, `HAVING` 절은 `GROUP BY` 결과에 대해 필터링 역할을 한다.`GROUP BY` 에 사용된 조건은 인덱스를 사용해서 처리될 수 없기 때문에 `HAVING` 절을 튜닝하려고 인덱스를 생성하거나 할 필요는 없다.



`GROUP BY` 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눌 수 있는데, 인덱스를 이용할 때는 인덱스를 차례대로 읽는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔 방법으로 나뉜다. 그리고 인덱스를 사용하지 못하는 경우에는 임시 테이블을 사용한다.



#### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)

`ORDER BY`와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 `GROUP BY` 칼럼으로 이미 인덱스가 있다면 그 인덱스를 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다. 이 경우에도 그룹 함수 등의 그룹값을 처리할 때는 임시 테이블이 필요할 때도 있다.



#### 루스 인덱스 스캔을 이용하는 GROUP BY

``` sql
EXPLAIN
	SELECT emp_no
	FROM salaries
	WHERE from_date='1985-03-01'
	GROUP BY emp_no;
```



`salaries` 테이블의 인덱스는 (`emp_no`, `from_date`) 로 생성되어 있기 때문에 위 쿼리는 원래대로라면 인덱스 레인지 스캔을 할 수 없다. 하지만 `Extra` 칼럼을 보면 `Using where; Using index for group-by` 를 확인할 수 있다. 위 쿼리를 실행한 순서는 다음과 같다.

1. (`emp_no`, `from_date`) 인덱스를 차례대로 스캔하면서, `emp_no`의 첫 번째 유일한 값(그룹 키) '10001'을 찾아낸다.
2. (`emp_no`, `from_date`) 인덱스에서 `emp_no`가 '10001'인 것 중에서 `from_date` 값이 '1985-03-01'인 레코드만 가져온다. 이 검색 방법을 1번 단계에서 알아낸 '10001' 값과 쿼리의 `WHERE` 절에 사용된 "from_date='1985-03-01" 조건을 합쳐서 "emp_no=10001 AND from_date='1985-03-01" 조건으로 (`emp_no`, `from_date`) 인덱스를 검색하는 것과 거의 흡사하다.
3. (`emp_no`, `from_date`) 인덱스에서 `emp_no`의 그 다음 유니크한(그룹 키) 값을 가져온다.
4. 3번 단계에서 결과가 더 없으며 처리를 종료하고, 결과가 있다면 2번 과정으로 돌아가서 반복 수행한다.



MySQL의 루스 인덱스 스캔은 단일 테이블에서 수행되는 `GROUP BY` 처리에만 사용할 수 있다. 또한, 칼럼값의 앞쪽 일부만으로 생성된 프리픽스 인덱스는 사용할 수 없다. 인덱스 레인지 스캔에서는 유니크한 값이 많을수록 성능이 향상되는 반면 루스 인덱스 스캔에서는 반대로 유니크한 값이 적을수록 성능이 향상된다.



다음의 쿼리는 루스 인덱스 스캔을 사용할 수 없는 쿼리 패턴이다.

```sql
-- // MIN()과 MAX() 이외의 집합 함수가 사용됐기 때문에 루스 인덱스 스캔은 사용 불가
SELECT col1, SUM(col2) FROM tb_test GROUP BY col1;

-- // GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않기 때문에 사용 불가
SELECT col1, col2 FROM tb_test GROUP BY col2, col3;

-- // SELECT 절의 칼럼이 GROUP BY와 일치하지 않기 때문에 사용 불가
SELECT col1, col3 FROM tb_test GROUP BY co1, col2;
```



#### 임시 테이블을 사용하는 GROUP BY

`GROUP BY`의 기준 칼럼이 어느 테이블에 있든 인덱스를 전혀 사용하지 못할 때 처리되는 방식이다.



``` sql
EXPLAIN
SELECT e.last_name, AVG(s.salary)
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
GROUP BY e.last_name;
```



위 쿼리는 인덱스를 사용할 수 없는 `GROUP BY` 절이 있기 때문에 실행 계획을 보면 "Using temporary" 메시지를 확인할 수 있다. 8.0 버전 이전까지는 `GROUP BY` 가 사용된 쿼리는 그루핑되는 칼럼을 기준으로 묵시적인 정렬까지 함께 정렬했었는데, 8.0 부터는 묵시적인 정렬은 더이상 실행되지 않는다.



8.0 에서는 `GROUP BY`가 필요한 경우 내부적으로 `GROUP BY` 절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행한다. 그리고 조인의 결과를 하나씩 가져와 임시 테이블에서 중복 체크를 하면서 `INSERT`나 `UPDATE`를 실행한다. 즉, 별도의 정렬 작업 없이 `GROUP BY`가 처리된다.



``` sql
CREATE TEMPORARY TABLE ... (
  	last_name VARCHAR(16),
  	salary INT,
  	UNIQUE INDEX ux_lastname (last_name)
)
```



### DISTINCT 처리

`DISTINCT`는 특정 칼럼의 유니크한 값을 조회할 때 사용한다. `MIN()`, `MAX()`, `COUNT()`같은 집합 함수와 함께 사용되는 경우와 그렇지 않은 경우 두 가지로 구분해서 살펴보자. 이렇게 나눈 이유는 각 경우에 `DISTINCT` 가 영향을 미치는 범위가 달라지기 때문이다. 또한, 집합 함수와 같이 `DISTINCT`가 사용되는 쿼리의 실행 계획에서 `DISTINCT` 처리가 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요하다. 하지만 실행 계획을 보면 "Using temporary" 메시지는 출력되지 않는다.



#### SELECT DISTINCT ...

단순 `SELECT DISTINCT ...` 쿼리는 `GROUP BY`와 동일한 방식으로 처리된다. 8.0부터는 `GROUP BY` 쿼리에서 기본적으로 정렬을 하지 않기 때문에 다음 두 쿼리는 내부적으로 같은 작업을 수행한다.



``` sql
SELECT DISTINCT emp_no FROM salaries;
SELECT emp_no FROM salaries GROUP BY emp_no;
```



`DISTINCT`를 사용할 때 자주 실수하는 것이 있는데, `DISTINCT`는 `SELECT`하는 레코드(튜플)를 유니크하게 `SELECT`하는 것이지 칼럼을 유니크하게 조회하는 것이 아니다. 즉, 다음 쿼리에서 `SELECT` 하는 결과는 `first_name`만 유니크한 것을 가져오는 것이 아니라 (`fist_name` + `last_name`) 전체가 유니크한 레코드를 가져오는 것이다.



```sql
SELECT DISTINCT first_name, last_name FROM employees;
```



또한, `DISTINCT` 는 함수가 아니다. 따라서 `SELECT DISTINCT(first_name), last_name FROM employees;` 와 같은 쿼리에서는 괄호를 그냥 의미 없는 것으로 해석하고 제거해버린다.

`SELECT` 절에 사용된 DISTINCT 키워드는 조회되는 모든 칼럼에 영향을 미친다. 절대로 `SELECT`하는 여러 칼럼 중에서 일부 칼럼만 유니크하게 조회하는 방법은 없다. 단, 이어서 설명할 `DISTINCT`가 집합 함수 내에 사용된 경우는 조금 다르다.



#### 집합 함수와 함께 사용된 DISTINCT

`COUNT()`, `MIN()`, `MAX()` 와 같은 집합 함수 내에서 `DISTINCT` 키워드가 사용될 수 있는데, 이 경우에는 일반적으로 `SELECT DISTINCT` 와 다른 형태로 해석된다. 집합 함수가 없는 쿼리에서는 `DISTINCT`는 조회하는 모든 칼럼의 조합이 유니크한 것들만 가져오지만, 집합 함수 내에서 사용된 `DISTINCT`는 그 집합 함수의 인자로 전달된 칼럼값이 유니크한 것들만 가져온다.



```sql
EXPLAIN
SELECT COUNT(DISTINCT s.salary)
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no
AND e.emp_no BETWEEN 100001 AND 100100;
```



위 쿼리는 `COUNT(DISTINCT s.salary)`를 처리하기 위해 내부적으로 임시 테이블을 사용한다. 하지만 실행 계획 이력을 보면 임시 테이블을 사용한다는 메시지가 없는데, MySQL 서버에서는 "Using tempoarary"를 표시하지 않고 있다.

위의 쿼리의 경우에는 `employees` 테이블과 `salaries` 테이블을 조인한 결과에서 `salary` 칼럼의 값만 저장하기 위한 임시 테이블을 만들어서 사용한다. 이때 임시 테이블의 `salary` 칼럼에는 유니크 인덱스가 생성되기 때문에 레코드 건수만 많아진다면 상당히 느려질 수 있다.



### 내부 임시 테이블 활용

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그룹핑할 때는 **내부적**인 임시 테이블을 사용한다. 여기서 말하는 임시 테이블은  `CREATE TEMPORARY TABLE`로 만든 임시 테이블과는 다르기 때문에 **내부적**이라고 표현했다. 일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음엔 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다. 특정 예외 케이스에서는 바로 디스크에 임시 테이블이 생성되기도 한다.

MySQL 엔진이 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수도 없고 사용할 수도 없다. 사용자가 생성한 임시 테이블과는 달리 내부적인 임시 테이블은 쿼리의 처리가 완료되면 자동으로 삭제된다.



#### 메모리 임시 테이블과 디스크 임시 테이블

8.0 버전 이전에는 원본 테이블의 스토리지 엔진과 관계없이 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진을, 디스크에 저장될 때는 MyISAM을 이용했다. 기존 MEMORY 스토리지 엔진은 `VARCHAR`같은 가변 길이 타입을 지원하지 못했기 때문에 임시 테이블이 메모리에 만들어지면 가변 길이 타입의 경우 최대 길이만큼 메모리를 할당해서 사용했다. 그리고 MyISAM 스토리지 엔진의 경우 트랜잭션을 지원하지 못한다는 단점이 있었다. 따라서 8.0 부터는 메모리는 TempTable이라는 스토리지 엔진을 사용하고, 디스크는 InnoDB를 사용하도록 개선됐다.



8.0부터는 `internal_tmp_mem_storage_engine` 시스템 변수를 이용해 메모리용 임시 테이블을 MEMORY와 TempTable 중에서 선택할 수 있게 하는데, 디폴트가 TempTable이다. 그리고 TempTable이 사용 가능한 최대 메모리 공간의 크기는 `temptable_max_ram` 시스템 변수로 제어하는데, 기본값은 1GB이다. 임시 테이블의 크기가 1GB보다 커지면 MySQL 서버는 메모리의 임시 테이블을 디스크에 기록하는데, 이때 MySQL 서버는 다음 두 가지 디스크 저장 방식 중 하나를 선택한다.

- MMAP 파일로 디스크에 기록 < InnoDB 테이블로 전환하는 것보다 오버헤드가 적기 때문에 기본값
- InnoDB 테이블로 기록



처음부터 디스크 테이블로 생성되는 경우에는 `internal_tmp_disk_storage_engine` 시스템 변수에 설정된 스토리지 엔진이 사용된다. 기본 값은 InnoDB이다.



#### 임시 테이블이 필요한 쿼리

다음과 같은 패턴의 쿼리는 MySQL 엔진에서 별도의 데이터 가공 작업이 필요하기 때문에 대표적으로 내부 임시 테이블을 생성하는 케이스다. 물론 이 밖에도 인덱스를 사용하지 못할 때는 내부 임시 테이블을 생성해야 할 때가 많다.

- `ORDER BY`와 `GROUP BY`에 명시된 칼럼이 다른 쿼리
- `ORDER BY`나 `GROUP BY`에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- `DISTINCT`와 `ORDER BY`가 동시에 쿼리에 존재하는 경우 `DISTINCT`가 인덱스로 처리되지 못하는 쿼리
- `UNION`이나 `UNION DISTINCT`가 사용된 쿼리 (`select_type` 칼럼이 UNION RESULT인 경우)
- 쿼리의 실행 계획에서 `select_type`이 DERIVED인 쿼리



쿼리의 실행 계획에서 임시 테이블을 사용하는지 여부는 Extra 칼럼에 "Using temporary" 키워드를 확인하면 된다. 하지만 "Using temporary"가 표시되지 않을 때도 임시 테이블을 사용할 수 있는데, 마지막 3개 패턴이 그런 예다. 첫 번째부터 네 번째는 유니크 인덱스를 가지는 내부 임시 테이블이 만들어진다. 그리고 마지막은 유니크 인덱스가 없는 내부 임시 테이블이 생성된다. 일반적으로 유니크 인덱스가 있는 내부 임시 테이블은 그렇지 않은 쿼리보다 상당히 처리 성능이 느리다.



#### 임시 테이블이 디스크에 생성되는 경우

내부 임시 테이블은 기본적으로 메모리 상에 만들어지지만 다음과 같은 조건을 만족하면 메모리에 임시 테이블을 생성할 수 없으므로 디스크상에 MyISAM 테이블로 만들어진다.

- `UNION`이나 `UNION ALL`에서 `SELECT` 되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- `GROUP BY`나 `DISTINCT` 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 
  - MEMORY 스토리지 엔진에서 `tmp_table_size` 또는 `max_heap_table_size` 시스템 변수보다 크거나
  - TempTable 스토리지 엔진에서 `temptable_max_ram` 시스템 변수보다 큰 경우



8.0.13 이전 버전까지는 BLOB이나 TEXT 칼럼이 있는 경우 임시 테이블을 디스크에만 생성할 수 있었지만 8.0.13 버전부터는 TempTable 스토리지 엔진에 한해서 메모리에 생성할 수 있게 개선됐다.



#### 임시 테이블 관련 상태 변수

실행 계획에 "Using temporary"가 있으면 임시 테이블을 사용했다는 것을 알 수 있지만, 메모리에서 처리됐는지 디스크에서 처리됐는지는 알 수 없고, 몇 개의 임시 테이블이 사용됐는지도 알 수 없다. 임시 테이블이 생성된 위치를 확인하려면 `SHOW SESSION STATUS LIKE 'Created_tmp%';` 를 확인해보면 된다.



```sql
mysql > SHOW SESSION STATUS LIKE 'Created_tmp%';
+---------------------------+--------+
| Variable name             | Value  |
+---------------------------+--------+
| Created_tmp_disk_tables   | 1      |
| Created_tmp_tables        | 3      |
+---------------------------+--------+
```



- `Created_tmp_tables`: 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값. 이 값은 내부 임시 테이블이 메모리에 만들어졌는지 디스크에 만들어졌는지를 구분하지 않고 모두 누적한다.
- `Created_tmp_disk_tables`: 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값



## 9.3 고급 최적화

MySQL 서버의 옵티마이저가 실행 계획을 수립할 때는 **통계 정보**와 **옵티마이저 옵션**을 결합해서 최적의 실행 계획을 수립한다. 옵티마이저 옵션은 크게 **조인 관련된 옵티마이저 옵션**과 **옵티마이저 스위치**로 구분할 수 있다. 옵티마이저 스위치는 5.5 버전부터 지원되기 시작했는데, 이는 고급 최적화 기능 활성화 여부를 제어하는 용도로 쓰인다.



### 옵티마이저 스위치 옵션

`optimizer_switch` 시스템 변수로 제어하는데, 여러 옵션을 세트로 묶어서 설정하는 방식으로 사용한다.



각각의 옵티마이저 스위치 옵션은 "default", "on", "off" 중 하나를 설정할 수 있다. 옵티마이저 스위치 옵션은 글로벌, 세션별 모두 설정할 수 있기 대문에 MySQL 서버 전체적으로 또는 현재 커넥션에 대해서만 설정할 수 있다. 또한, `SET_VAR` 옵티마이저 힌트를 이용해 현재 쿼리에만 설정할 수도 있다.



#### MRR(Multi-Range Read)과 배치 키 액세스(mrr & batched_key_access)

MySQL 서버 내부 구조상 조인 처리는 MySQL 엔진이 처리하지만, 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당한다. 이때 드라이빙 테이블의 레코드 건별로 드리븐 테이블의 레코드를 찾으면 레코드를 찾고 읽는 스토리지 엔진에서는 아무런 최적화를 할 수 없다.

이같은 단점을 보완하기 위해 MySQL 서버에서는 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고, 조인 대상을 조인 버퍼에 버퍼링한다. 조인 버퍼에 레코드가 가득 차면 MySQL 엔진이 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청한다. 이렇게 함으로써 스토리지 엔진은 읽어야 할 레코드들을 데이터 페이지에 정렬된 순서로 접근해서 디스크의 데이터 페이지 읽기를 최소화한다. 이러한 읽기를 MRR이라고 하며, MRR 을 응용해서 실행되는 조인 방식을 BKA 조인이라고 한다. BKA 조인 최적화는 기본값이 비활성화인데, 부가적인 정렬 작업때문에 오히려 성능이 더 안좋아지는 단점이 있기 때문이다.



#### 블록 네스티드 루프 조인(block_nested_loop)

MySQL에서 사용되는 대부분의 조인인 네스티드 루프 조인은 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다. 이러한 형태의 조인은 다음과 같이 중첩 반복문처럼 작동한다고 해서 Nested Loop Join 이라고 한다.

``` sql
for (row1 IN employees) {
    for (row2 IN salaries) {
        if (condition_matched)
            return (row1, row2);
    }
}
```



네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 조인 버퍼의 사용 여부와, 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되느냐다. 조인 알고리즘에서 "Block" 이란 단어는 조인용으로 별도의 버퍼가 사용됐다는 것을 의미하는데, 쿼리 실행 계획의 Extra 칼럼에 "Using Join buffer" 문구가 있으면 조인 버퍼를 사용한다는 의미이다.



조인은 드라이빙 테이블에서 일치하는 레코드 건수만큼 드리븐 테이블을 검색하면서 처리된다. 즉, 드라이빙 테이블은 한 번에 쭉 읽지만, 드리븐 테이블은 여러 번 읽는 것이다. 그래서 드리븐 테이블을 검색할 때 옵티마이저는 최대한 인덱스를 사용할 수 있도록 실행 계획을 수립한다.



만약 어떤 방식으로도 인덱스 레인지 스캔을 할 수 없다면, 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐싱한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다. 이때 사용하는 메모리의 캐시를 **조인 버퍼**라고 한다. 조인 버퍼는 `join_buffer_size` 시스템 변수로 크기를 지정할 수 있고, 조인이 완료되면 바로 해제된다.



두 테이블이 조인되는 다음 쿼리의 실행 단계는 다음과 같다.

``` sql
SELECT *
FROM dept_emp de, employees e
WHERE de.from_date > '1995-01-01' AND e.emp_no < 109004;
```



1. `dept_emp` 테이블의 `ix_fromdate` 인덱스를 이용해 `from_date > '1995-01-01'` 조건을 만족하는 레코드를 검색
2. 조인에 필요한 나머지 칼럼을 모두 `dept_emp` 테이블에서 읽어서 조인 버퍼에 저장
3. `employees` 테이블의 PK를 이용해 `emp_no < 109004` 조건을 만족하는 레코드 검색
4. 3번에서 검색된 결과에 2번의 캐시된 조인 버퍼의 레코드를 결합하여 반환



#### 인덱스 컨디션 푸시다운(index_condition_pushdown)





#### 인덱스 확장(use_index_extensions)





#### 인덱스 머지(index_merge)





#### 인덱스 머지 - 교집합(index_merge_intersection)





#### 인덱스 머지 - 합집합(index_merge_union)





#### 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)





#### 세미 조인(semijoin)





#### 테이블 풀-아웃(Table Pull-out)





#### 퍼스트 매치(firstmatch)





#### 루스 스캔(loosescan)





#### 구체화(Materialization)





#### 중복 제거(Duplicated Weed-out)





#### 컨디션 팬아웃(condition_fanout_filter)





#### 파생 테이블 머지(derived_merge)





#### 인비저블 인덱스(use_invisible_indexes)





#### 스킵 스캔(skip_scan)





#### 해시 조인(hash_join)





#### 인덱스 정렬 선호(prefer_ordering_index)





### 조인 최적화 알고리즘





#### Exhaustive 검색 알고리즘





#### Greedy 검색 알고리즘









## 9.4 쿼리 힌트

쿼리의 실행 계획 최적화가 많이 발전했지만, 여전히 MySQL 서버는 비즈니스적인 이해는 부족하다. 그래서 개발자난 DBA가 실행 계획을 임의로 수립해야 하는 경우가 있는데, 이런 경우에는 다양한 **쿼리 힌트**를 통해 실행 계획을 임의로 수립할 수 있다. MySQL 서버에서 사용 가능한 쿼리 힌트는 다음과 같다.

- 인덱스 힌트: `STRAIGHT_JOIN`, `USE INDEX`와 같은 힌트를 의미한다.
- 옵티마이저 힌트: 5.6버전부터 새롭게 추가된 힌트들을 의미한다.



### 인덱스 힌트

인덱스 힌트는 SQL의 문법에 맞게 사용해야 하므로 ANSI-SQL 표준 문법을 준수하지 못하는 단점이 있다. 그래서 가능하다면 옵티마이저 힌트를 사용할 것을 권장한다. 또한, 인덱스 힌트는 `SELECT`, `UPDATE` 문에만 쓸 수 있다.



#### STRAIGHT_JOIN

`STRAIGHT_JOIN`은 옵티마이저 인트인 동시에 조인 키워드이기도 하다. 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 한다. 보통 조인을 하기 위한 칼럼들의 인덱스 여부로 조인의 순서가 결정되며, 조인 칼럼의 인덱스에 아무 문제가 없는 경우에는 (`WHERE` 조건이 있는 경우는 그 조건을 만족하는) 레코드가 적은 테이블을 드라이빙 테이블로 선택하는데, 이때 `SELECT` 구문 뒤에 `STRAIGHT_JOIN` 을 붙이면 `FROM`절에 명시된 순서대로 조인을 수행하도록 유도한다.



주로 다음 기준에 맞게 조인 순서가 결정되지 않은 경우에만 `STRAIGHT_JOIN` 힌트로 조인 순서를 조정해주는 것이 좋다. 아래에서 말하는 레코드 건수는 `WHERE` 조건을 만족하는 레코드 건수를 의미한다.

- 임시 테이블과 일반 테이블의 조인: 임시 테이블을 드라이빙 테이블로
- 임시 테이블끼리 조인: 임시 테이블은 인덱스가 없기 때문에 크기가 작은 테이블을 드라이빙 테이블로
- 일반 테이블끼리 조인: 조인 칼럼에 인덱스가 없는 테이블 ->레코드 건수가 적은 테이블을 드라이빙 테이블로



`STRAIGHT_JOIN` 힌트와 비슷한 역할을 하는 옵티마이저 힌트로는 다음과 같은 것들이 있다.

- `JOIN_FIXED_ORDER`: `STRAIGHT_JOIN`과 마찬가지로 한 번 사용되면 `FROM` 절의 모든 테이블에 대해 조인 순서가 결정된다.
- `JOIN_ORDER`
- `JOIN_PREFIX`
- `JOIN_SUFFIX`



첫번째 `JOIN_FIXED_ORDER` 힌트는 `STRAIGHT_JOIN`과 마찬가지로 한 번 사용되면 `FROM` 절의 모든 테이블에 대해 조인 순서가 결정되고, 아래 세 개의 옵티마이저 힌트는 일부 테이블의 조인 순서에 대해서만 제안하는 힌트이다.



#### USE INDEX / FORCE INDEX / IGNORE INDEX

인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다. 대체로 옵티마이저가 어떤 인덱스를 사용할지 잘 선택하는 편이지만, 3~4개 이상의 칼럼을 포함하는 비슷한 인덱스가 여러 개 있는 경우에는 강제로 특정 인덱스를 사용하도록 힌트를 추가하면 된다.



인덱스 힌트는 다음과 같이 크게 세 종류가 있다. 키워드 뒤에 사용할 인덱스의 이름을 괄호쳐서 사용하는데, 이름이 유효하지 않은 경우 쿼리의 문법 오류로 처리된다. PK 인덱스는 `PRIMARY`라고 명시하면 된다.



- `USE INDEX`: 가장 자주 사용되는 인덱스 힌트로, MySQL 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트이다.
- `FORCE`: `USE INDEX`와 유사한데, 옵티마이저에게 미치는 영향이 보다 강력한 힌트이다. 하지만 `USE INDEX` 힌트도 충분한 영향력을 갖기 때문에 거의 사용될 일이 없다.
- `IGNORE INDEX`: 위의 힌트와 반대로 특정 인덱스를 사용하지 못하게 하는 용도로 사용한다. 가끔 풀 테이블 스캔을 유도하기 위해 사용할 수 있다.



위 인덱스 힌트는 모두 용도를 명시해줄 수 있다.

- `USE INDEX FOR JOIN`
- `USE INDEX FOR ORDER`
- `USE INDEX FOR GROUP BY`



#### SQL_CALC_FOUND_ROWS

`LIMIT`을 사용하는 경우, 만족하는 레코드를 명시된 수만큼 찾으면 즉시 검색 작업을 종료한다. 하지만 `SQL_CALC_FOUND_ROWS` 힌트가 포함되었다면 끝까지 검색을 수행한다. 사용하지 말자.



### 옵티마이저 힌트

인덱스 힌트와 다르게, MySQL 서버를 제외한 다른 RDBMS에서는 주석으로 해석되기 때문에 ANSI-SQL 표준을 준수한다고 볼 수 있다. 8.0 버전에서 사용 가능한 힌트는 종류도 매우 많고, 힌트가 미치는 영향 범위도 다양하다.



#### 옵티마이저 힌트 종류

영향 범위에 따라 다음 네 개의 그룹으로 나눌 수 있다.

- 인덱스: 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
- 테이블: 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
- 쿼리 블록: 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트로서, 특정 쿼리 블록의 이름을 명시하는 것이 아니라 힌트가 명시된 쿼리 블록에 대해서만 영향을 미친다.
- 글로벌(쿼리 전체): 전체 쿼리에 대해서 영향을 미치는 힌트
