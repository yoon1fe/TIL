## 4.1 MySQL 엔진 아키텍처

MySQL 서버는 크게

- **MySQL 엔진** (머리)
- **스토리지 엔진** (손/발)

로 나뉜다.



![스크린샷 2022-02-17 오후 10 53 36](https://user-images.githubusercontent.com/66231761/154495756-a73e38e2-15d5-42d1-9a33-929f32bb6d91.png)

- MySQL 서버는 다른 DBMS들과는 다르게 독특한 구조를 갖고 있다. 이에 따른 장단점이 있음



**MySQL 엔진**

- 요청된 SQL 문장을 분석/최적화하는 역할을 수행

- 커넥션 핸들러: 클라이언트로부터의 접속 및 쿼리 요청 처리
- SQL 파서
- 전처리기
- 옵티마이저: 쿼리 최적화 실행



**스토리지 엔진**

- 실제 데이터를 디스크 스토리지에 저장/읽어오는 역할을 수행

- MySQL 엔진은 하나지만 스토리지 엔진은 여러 개 동시 사용 가능.

  `mysql > CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;` > `test_table` 테이블은 InnoDB 스토리지 엔진 사용하도록 정의

- 성능 향상을 위해 키 캐시(MyISAM)나 버퍼 풀(InnoDB) 기능 내장



**핸들러 API**

- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽을 때 각 스토리지 엔진에 요청(Handler)할 때 사용되는 API
- MySQL 엔진 <-> 스토리지 엔진



### 스레딩 구조

![스크린샷 2022-02-17 오후 10 54 05](https://user-images.githubusercontent.com/66231761/154495833-4b893782-b85c-4349-bdb5-801c89d037ae.png)

MySQL 은 프로세스 기반이 아니라 스레드를 기반으로 동작한다.



**포그라운드(foreground) 스레드(클라이언트 스레드, 사용자 스레드)**

- 최소 MySQL 서버에 접속된 클라이언트 수만큼 존재
- 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
- 데이터를 MySQL 데이터 버퍼나 캐시로부터 가져오고, 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어온다.
- MyISAM - 디스크 쓰기 작업까지 포그라운드 스레드가 처리
- InnoDB - 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리. 버퍼 ~ 디스크까지 기록하는 작업은 백그라운드 스레드가 처리.



**백그라운드(background) 스레드**

(MyISAM 스토리지 엔진은 해당 사항 별로 없음)

- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드



>  전통적인 스레드 모델 - 커넥션 별로 포그라운드 스레드 하나씩 생성/할당
>
> 스레드 풀 모델 - 하나의 스레드가 여러 개의 커넥션 요청을 담당



### 메모리 할당 / 사용 구조

- 글로벌 메모리 영역
- 로컬 메모리 영역

으로 구분.



**글로벌 메모리 영역**

글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 MySQL 시스템 변수로 설정한 값만큼의 메모리를 OS로부터 할당된다.

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두(re do) 로그 버퍼



**로컬 메모리 영역 (= 세션 메모리 영역, 클라이언트 메모리 영역)**

클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역.

클라이언트 <-> MySQL 서버와의 커넥션을 세션이라고 하기 때문에 세션 메모리 영역이라고도 함.

각 클라이언트 스레드 별로 독립적으로 할당되고 절대 공유되지 않는다.

- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼



### 플러그인 스토리지 엔진 모델

스토리지 엔진, 전문 검색 엔진을 위한 검색어 파서, 사용자 인증 위한 기능 등등이 플러그인으로 제공된다.



**쿼리가 실행되는 과정**

`{SQL 파서 - SQL 옵티마이저 - SQL 실행기} (MySQL 엔진 처리) - {데이터 R/W} (스토리지 엔진이 처리) - 디스크`

- MySQL 엔진 - (핸들러) - 스토리지 엔진
  - MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽거나 저장하도록 명령하려면 반드시 핸들러를 통해야 함
- `GROUP BY` 나 `ORDER BY` 등 복잡한 처리는 MySQL 엔진이 처리(쿼리 실행기)한다.
- 물론 데이터 읽기/쓰기 작업 처리 방식에 따라 쿼리 성능이 천차만별로 차이난다.



### 컴포넌트

8.0 부터 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 도입됨. 아래와 같은 플러그인 아키텍처의 단점을 보완해준다.

- MySQL 서버하고만 인터페이스할 수 있고, 플러그인끼리는 통신 불가
- MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
- 상호 의존 관계를 설정할 수 없어서 초기화 어려움

8.0 부터는 비밀번호 검증 기능이 컴포넌트로 개선됐다.



### 쿼리 실행 구조

![스크린샷 2022-02-17 오후 10 54 55](https://user-images.githubusercontent.com/66231761/154495992-9093bdc4-a539-4dc0-9ee1-e6d35a726d60.png)



**쿼리 파서**

- 요청 들어온 쿼리 문장을 MySQL이 인식할 수 있는 최소 단위의 어휘나 기호인 토큰으로 분리해 트리 구조로 만드는 작업
- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견된다.



**전처리기**

- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점 있는지 확인.
- 각 토큰을 테이블 이름, 컬럼 이름 등 개체를 매핑해 해당 객체의 존재 여부나 객체 접근 권한을 확인한다.
- 존재하지 않거나 권한이 없는 개체의 토큰은 여기서 걸러짐.



**옵티마이저**

- 요청 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리하는 방법을 결정. (DBMS의 두뇌)



**실행 엔진, 핸들러 (스토리지 엔진)**

ex) 옵티마이저가 `GROUP BY`를 처리하기 위해 임시 테이블을 사용하기로 결정했을 때

1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
2. `WHERE` 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블에 저장하라고 다시 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김



### 쿼리 캐시

SQL의 실행 결과를 메모리에 캐싱하고, 동일 쿼리가 요청오면 테이블을 읽지 않고 즉시 결과를 반환한다. 하지만 테이블의 데이터가 변경되면 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들은 모두삭제해야 함. => 동시 처리 성능 저하 유발

**따라서 8.0 부터는 쿼리 캐시 기능은 제거됨!!**



### 스레드 풀

엔터프라이즈 버전만 스레드 풀 기능 제공.



## 4.2 InnoDB 스토리지 엔진 아키텍처

![스크린샷 2022-02-17 오후 10 55 20](https://user-images.githubusercontent.com/66231761/154496080-77edecf8-4d3e-46ed-bb84-e39972951b3d.png)

InnoDB 스토리지 엔진은 거의 유일하게 **레코드 기반 잠금**을 제공하고, 때문에 높은 동시성 처리가 가능하다.



### PK에 의한 클러스터링

InnoDB의 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장된다(== PK 값 순서대로 디스크에 저장). 모든 세컨더리 인덱스는 레코드의 주소 대신 PK 값을 논리 주소로 사용. 따라서,

- PK를 이용한 레인지 스캔이 매우 빠름
- 쿼리 실행 계획에서 PK가 다른 보조 인덱스보다 선택될 확률이 높음
- 오라클 DB의 Index Organized Table과 동일한 구조



### FK 지원

외래 키에 대한 지원은 InnoDB 스토리지 엔진 차원에서 지원하는 기능임. 운영 환경에서는 DB 운영의 불편함 등으로 인해 FK 잘 안쓴다.



### MVCC(Multi Version Concurrency Control)

MVCC: 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS에서 동시성 제어를 위해 사용되는 기술. 여러 트랜잭션들이 동시에 데이터베이스에 접근하고 변경할 때 발생할 수 있는 충돌을 효과적으로 관리하는 방법 중 하나. 가장 큰 목적은 **잠금을 사용하지 않는 일관된 읽기를 제공하는 것**이다.

InnoDB는 언두 로그(Undo log)를 이용해서 구현한다.



**예시**

`member` 테이블에 레코드 하나를 `INSERT` 한 다음 `UPDATE`해서 발생하는 변경 작업



`INSERT INTO member VALUES(1, '동동', '서울')`가 실행되면

- InnoDB 버퍼 풀
- 데이터 파일(디스크)

에 해당 값이 저장됨.



`UPDATE member SET m_area='경기' WHERE m_id=1` 이 실행되면 

- InnoDB 버퍼 풀: 커밋 실행 여부과 관계없이 새로운 값인 '경기'로 업데이트
- 데이터 파일: 알 수 없음. 다만 InnoDB는 ACID를 보장하므로 일반적으로는 버퍼 풀과 동일한 상태라고 가정해도 무방.
- 언두 로그: `m_id=12, m_area=서울` 데이터가 저장.



커밋이나 롤백이 되지 않은 상태에서 다른 사용자가 작업중인 레코드를 조회하면 어디에 있는 데이터를 조회할까??

-> MySQL 서버에 설정된 격리 수준에 따라 다르다.

- READ_UNCOMMITTED: 버퍼 풀에서 읽어서 반환
- READ_COMMITTED 이상(REPEATABLE_READ, SERIALIZABLE): 언두 로그의 데이터 반환

=> 이러한 과정을 DBMS에서 **MVCC**라고 표현한다. 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 상황에 따라 달라지는 구조.



`COMMIT` 실행: 지금 상태 그대로 영구적인 데이터로 만듦. 언두 영역의 백업 데이터가 바로 삭제되는 것은 아니고, 언두 영역을 필요로 하는 트랜잭션이 없을 때 삭제된다.

`ROLLBACK` 실행: 언두 영역에 있는 백업 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 데이터 삭제



### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

InnoDB 스토리지 엔진은 MVCC 기술을 이용해 (격리 수준 `SERIALIZABLE` 을 제외하고는) 잠금을 걸지 않고 읽기 작업을 한다. 변경되지 전의 데이터를 언두 로그에서 읽어온다.

트랜잭션이 오랫동안 활성 상태로 있으면 일관된 읽기를 위해 언두 로그를 삭제하지 못하므로 MySQL 서버가 느려지거나 문제가 발생할 수 있다. 트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋해서 트랜잭션 완료하는 것이 좋다.



### 자동 데드락 감지

InnoDB 스토리지 엔진이 갖고 있는 **데드락 감지 스레드**가 주기적으로 잠금 대기 그래프를 검사해서 데드락에 빠진 트랜잭션을 찾아서 그 중 하나를 강제 종료시킨다.

- 강제 종료할 트랜잭션 판단 기준: 트랜잭션의 언두 로그 양.
  - 언두 로그 레코드가 더 적은 트랜잭션이 롤백의 대상 == 언두 처리할 내용이 적다



동시 처리 스레드가 너무 많으면 데드락 감지 스레드가 더 많은 리소스를 잡아먹게 됨.

- 시스템 변수로 데드락 감지 스레드 작동X
- 데드락 상황에서 일정 시간이 지나면 자동으로 요청 실패시키는 기능 활성화 후 적당한 값으로 타임아웃을 주는 것이 좋다.



### InnoDB 버퍼 풀

디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간.

+) 쓰기 작업 지연시켜 일괄 작업으로 처리시키는 버퍼 역할도 함



### 언두 로그

트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 백업해 놓는 데이터.

- 트랜잭션 보장
- 격리 수준 보장



### 체인지 버퍼

레코드가 `INSERT` 되거나 `UPDATE` 될 때 해당 테이블에 있는 인덱스를 업데이트하는 작업도 필요한데, 이 작업은 디스크를 랜덤하게 읽는 작업이다. InnoDB는 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하고, 디스크로부터 읽어와야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환한다. 이때 사용하는 임시 메모리 공간이 체인지 버퍼.



### 리두 로그 및 로그 버퍼

ACID의 D(Durable, 영속성)과 밀접한 연관있음. MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치이다.

리두 로그를 통해 장애 직전 시점까지의 복구가 가능해짐



### 어댑티브 해시 인덱스

InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스.

B-Tree 검색 시간을 줄여주는 기능이다. 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만듦. B-Tree를 루트 노드 ~ 리프 노드까지 찾아가는 비용이 없어지게 된다.

`B-Tree 인덱스의 고유번호(ID) : B-Tree 인덱스의 실제 키 값` 쌍으로 이루어짐. 

버퍼 풀에 올려진 데이터 페이지에 대해서만 관리된다.



다음 경우 성능 향상이 크지 않을 수 있다.

- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우



어댑티브 해시 인덱스를 활성화해놓는 경우, 해시 인덱스의 효율이 없는 경우에도 InnoDB 는 계속 해시 인덱스를 검색해볼 것이기 때문에 활성화 여부를 잘 고려해야 한다.



## 4.3 MyISAM 스토리지 엔진 아키텍처





## 4.4 MySQL 로그 파일