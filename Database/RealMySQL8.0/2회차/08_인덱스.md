## 8.1 디스크 읽기 방식

랜덤 I/O 보다 순차 I/O가 더 빠르다. 하지만 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행하는 방법은 그리 많지 않음.

일반적인 쿼리 튜닝: **랜덤 I/O 자체를 줄이는 것. == 쿼리 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것.**

참고) 인덱스 레인지 스캔은 주로 랜덤 I/O를 사용하고, 풀 테이블 스캔은 순차 I/O를 사용한다. 그래서 큰 테이블의 레코드 대부분을 읽는 작업은 인덱스를 사용하지 않고 풀 스캔하도록 유도하는 경우도 있음. 웹서비스보다 데이터 웨어하우스나 통계 작업에서 주로 사용됨.



## 8.2 인덱스란?

- 인덱스 == 책 맨 뒤에 있는 찾아보기

- 데이터 파일 == 책의 내용
- 레코드 주소 == 페이지 번호

- 정렬되어 있음

원하는 검색 결과를 빠르게 가져오기 위해 <칼럼의 값, 레코드 주소> 를 키-값 쌍으로 삼아 인덱스를 만들어 두는 것.



**인덱스의 장단점**

- 항상 정렬된 결과를 유지해야 하므로 `INSERT`, `UPDATE`, `DELETE` 문장의 처리가 느림
- `SELECT` 쿼리는 매우 빠르게 처리 가능
- **결론) DBMS에서 인덱스는 데이터의 저장 성능을 희생하고, 그 대신 데이터의 읽기 속도를 높이는 기능**



**인덱스의 구분**

- 역할에 따른 구분

  - PK(Primary Key): 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스. NOT NULL, 중복 허용 X
  - PK를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류한다. 유니크 인덱스는 PK와 성격이 비슷해 대체 키라고도 하는데, 별도로 분류하기도 하고 세컨더리 인덱스로 분류하기도 함.

- 데이터 저장 방식(알고리즘)에 따른 구분

  - B-Tree 인덱스: 가장 일반적으로 사용됨. 칼럼의 값을 변형하지 않고 원래의 값으로 인덱싱. MySQL 에서 위치 기반 검색을 지원하기 위해 사용하는 R-Tree 인덱스 알고리즘이 있는데, 얘도 결국 B-Tree의 응용 알고리즘이다.
  - Hash 인덱스: 칼럼의 값으로 해싱하여 인덱싱. 검색이 매우 빠르지만 값을 변형해서 인뎅식하므로 prefix 검색 등 값의 일부만 검색하거나 범위를 검색할 때는 사용 불가.

- 데이터 중복 허용 여부에 따른 구분

  - 유니크 인덱스
  - 유니크하지 않은 인덱스

  인덱스의 유니크 여부는 옵티마이저에게 큰 힌트가 된다. `=`로 검색하는 건 항상 한 건의 레코드만 찾으면 된다는 것을 알려주는 효과가 있음.

- 기능에 따른 구분

  - 전문 검색용 인덱스
  - 공간 검색용 인덱스



## 8.3 B-Tree 인덱스

DBMS에선 보통 B-Tree 의 변형 알고리즘인 B+-Tree나 B*-Tree 알고리즘을 사용한다. 여기서 B는 Binary가 아니라 Balanced.



### 구조 및 특성

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/400px-B-tree.svg.png)

- 트리 구조 최상위에 하나의 루트 노드가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태. 

- 최하단의 리프 노드는 실제 데이터 레코드를 찾아가기 위한 **주솟값**을 갖고 있다.

- **인덱스의 키 값만 정렬**되어 있고, 데이터 파일의 레코드는 정렬되어 있지 않다.
  - 참고) InnoDB 테이블에서는 레코드가 클러스터되어 디스크에 저장되므로 기본적으로 PK 기준으로 정렬되어 저장된다! (클러스터링: 비슷한 값을 최대한 모아서 저장하는 방식)
  - InnoDB 테이블에서는 인덱스에 저장되어 있는 PK 값을 이용해 PK 인덱스를 한 번 더 검색한 후, PK 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽어 온다.



### B-Tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**

- 스토리지 엔진에 따라 새로 들어온 키 값이 즉시 인덱스에 저장될 수도 있고 아닐 수도 있음

- 키 추가 순서

  1. B-Tree 상에 저장될 키 값이 들어갈 위치를 검색

  2. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장

     (리프 노드가 꽉 차면 분리되어야 하는데 처리 범위가 상위 브랜치 노드까지 넓어짐)

- MyISAM이나 MEMORY 테이블에서는 `INSERT` 문이 실행되면 바로 B-Tree 인덱스에 반영하는데, InnoDB 스토리지 엔진은 이 작업을 좀 더 똑똑하게 처리한다. 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수도 있음. 다만 유니크 인덱스는 중복 체크가 필요하기 때문에 즉시 B-Tree에 반영한다.



**인덱스 키 삭제**

- 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마크만 하면 끝. 삭제 마킹된 공간은 그대로 방치하거나 재활용할 수 있다. 마킹 작업 역시 디스크 I/O가 필요하므로 InnoDB에선  이 작업 또한 버퍼링되어 지연 처리할 수 있다. 다른 스토리지 엔진은 체인지 버퍼같은 기능이 없으므로 키 삭제가 바로 진행된다.



**인덱스 키 변경**

- 키 값 삭제 -> 다시 새로운 키 값 추가하는 형태로 처리.



**인덱스 키 검색**

- 인덱스 트리 탐색은 `SELECT` 문 뿐만 아니라 `UPDATE`, `DELETE`를 처리하기 위해 해당 레코드를 먼저 검색해야 할 경우에도 사용된다.

- B-Tree 이덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우 사용할 수 있음.

- 함수나 연산을 수행해 값이 변형된 값은 B-Tree에 존재하는 값이 아니므로 인덱스를 사용할 수 없다.

- InnoDB 테이블에서 지원하는 레코드 잠금이나 NX_LOCK 은 검색에 사용된 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식이다. 따라서 `UPDATE`나 `DELETE` 문을 수행할 때 테이블에 적절히 사용할 인덱스가 없으면 불필요하게 많은 레코드를 잠그게 된다.



### B-Tree 인덱스 사용에 영향을 미치는 요소

인덱스를 구성하는 칼럼의 크기, 레코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색/변경 작업의 성능이 영향받는다.



**인덱스 키 값의 크기**

- 페이지(== 블록): InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 기본 단위. 디스크 I/O 작업의 최소 작업 단위이자 버퍼 풀에서 데이터를 버퍼링하는 기본 단위.
- 인덱스도 결국은 페이지 단위로 관리된다.
- B-Tree의 자식 노드의 개수는 가변적인데, 가질 수 있는 자식 노드의 최대 개수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.



**B-Tree 깊이**

- 직접 제어할 순 없음.
- 인덱스 키 값의 평균 크기가 늘어나면 -> 하나의 인덱스 페이지가 담을 수 있는 키 값의 개수가 적어지고 -> 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 됨



**선택도(기수성, Cardinality)**

- 기수성: 모든 인덱스 키 값 가운데 유니크한 값의 개수.

  ex) 전체 인덱스 키 값 100개 / 유니크 값의 개수 10 = 기수성: 10

- 중복된 값이 많아질수록 선택도와 기수성이 낮아지고, 선택도가 낮아질수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

- 유니크한 값이 적을수록 (중복된 값이 많을수록) 불필요하게 읽어들일 대상이 줄어듬.



**읽어야 하는 레코드 건수**

- 보통 인덱스를 통해 레코드 1건을 읽는 것은 테이블에서 직접 읽는 것보다 4~5배 비용이 더 드는 작업이라고 예측함. 따라서 전체 레코드의 20~25% 이상의 레코드를 읽어야 하는 작업이라면 인덱스를 이용하지 않고 테이블을 직접 다 읽어서 필요한 레코드만 가려내는 필터링 방식이 효율적!



### B-Tree 인덱스를 통한 데이터 읽기

**인덱스 레인지 스캔**

- 가장 대표적인 인덱스 접근 방법. 뒤의 두 가지 방법보다 빠름.

- 검색해야 할 인덱스의 범위(Range)가 결정됐을 때 사용하는 방식
- 범위의 시작 위치를 찾으면 리프 노드의 레코드만 순서대로 읽으면 된다(Scan).
- 리프 노드의 주소를 갖고 디스크에 가서 데이터를 읽어온다. 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 크기 때문에 위에서 말했듯이 전체 레코드의 일정 범위를 넘으면 테이블의 데이터를 직접 읽는 것이 더 효율적이다.



**인덱스 풀 스캔**

- 인덱스의 처음 ~ 끝 까지 모두 읽는 방식

- 쿼리 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 주로 사용된다.

  ex) idx(A, B, C) 인데 `WHERE B = 'bb' AND C = 'cc';`

- 인덱스는 보통 테이블보다 작기 때문에, 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있다면 주로 이 방식이 사용된다.

- 일반적으로 인덱스를 생성하는 목적은 아님. 인덱스 풀 스캔 방식을 사용하는 경우 인덱스를 타지 못한거나 다름 없다.



**루스(loose) 인덱스 스캔**

- 이름 그대로 느슨하게, 듬성듬성 인덱스를 읽는 방식. 인덱스 레인지 스캔과 비슷하지만 중간에 불필요한 인덱스 키 값은 무시하고 넘어간다.
- 일반적으로 GROUP BY 또는 MAX(), MIN() 함수 최적화에 사용된다.

- 위 두 방식은 루스 인덱스 스캔과 상반된 의미에서 타이스(tight) 인덱스 스캔이라고 분류



**인덱스 스킵 스캔**

- 조회 조건에 한 개의 칼럼만 있는 쿼리는 두 개 이상의 컬럼으로 이루어진 인덱스를 사용하지 못함.

  ex) WHERE birth_date >= '1999-01-01' // idx(gender, birth_date) 인덱스 사용 못함

- 8.0 부터 옵티마이저가 gender 칼럼을 건너뛰고 birth_date 칼럼만으로도 인덱스 검색이 가능한 인덱스 스킵 스캔 도입됨

- 루스 인덱스 스캔은 GROUP BY 작업에만 적용되기 때문에 인덱스 스킵 스캔을 사용해서 WHERE 조건 절 검색 효율성을 높일 수 있다.

- 조건절에 없는 칼럼에서 유니크한 값을 먼저 조회한 뒤 조건절에 있는 칼럼으로 조회한다.

- 단점

  - WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
  - 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함



### 다중 칼럼 인덱스(복합 칼럼 인덱스)

- 2개 이상 칼럼이 연결된 인덱스
- 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬되어 있다. 따라서 인덱스 내에서 각 칼럼의 순서가 매우 중요함.



### B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 있음.
- 인덱스를 어느 방향으로 읽을지는 옵티마이저가 만드는 실행 계획에 따라 결정된다.



### B-Tree 인덱스의 가용성과 효율성

- 쿼리의 WHERE 조건이나 GROUP BY, ORDER BY 절 등이 어떤 경우에 인덱스를 사용할 수 있고, 어떤 방식으로 사용되는지 이해해야 쿼리 최적화, 인덱스 생성 최적화가 가능함.



**비교 조건의 종류와 효율성**

- `WHERE dept_no = 'd002' AND emp_no >= 10114`
  - 케이스 A) INDEX(dept_no, emp_no): "dept_no = 'd002' AND emp_no >= 10114" 인 레코드를 찾고, dept_no가 'd002'가 아닐 때까지 인덱스를 읽기만 하면 된다. 조건을 만족하는 레코드가 5건이라면 5번의 비교 작업만 수행하면 다 찾을 수 있음.
  - 케이스 B) INDEX(emp_no, dept_no): "emp_no >= 10114 AND dept_no = 'd002' " 에 해당하는 레코드를 찾고, 이후 모든 레코드에 대해 dept_no = 'd002' 비교 과정을 거쳐야 한다.
    - 필터링: 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하는 작업
  - 다중 칼럼 인덱스에서 칼럼 순서가 중요한 이유!! A 케이스에서의 dept_no = 'd002' 는 비교 작업의 범위를 좁히는데 도움을 준다. (작업 범위 결정 조건)



**인덱스의 가용성**

- B-Tree 인덱스는 왼쪽 값에 기준해서 오른쪽 값이 정렬되어 있음. 하나의 칼럼 뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 동일하다.
- 인덱스가 있는 칼럼으로 검색해도 값의 왼쪽 부분 (ex. `LIKE %mer`)이 없으면 인덱스 레인지 스캔 방식 검색 불가능. 다중 칼럼 인덱스에서도 왼쪽 칼럼의 값을 모르면 동일하다.



**가용성과 효율성 판단**

- 기본적으로 B-Tree 인덱스는 다음 조건에서 사용 불가. (== 작업 범위 결정 조건으로 사용 X)
- NOT-EQUAL로 비교 (`<>`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL`)
- LIKE '%??'
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교 (SUBSTRING(column, 1, 1) = 'X')
- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용
- 데이터 타입이 서로 다른 비교 (인덱스 칼럼의 타입을 변환해야 비교 가능한 경우)
- 문자열 데이터 타입의 콜레이션이 다른 경우
- MySQL 에서는 `NULL` 값도 인덱스에 저장되므로 `WHERE column IS NULL` 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.













## 8.4 R-Tree 인덱스





## 8.5전문 검색(Full Text Search) 인덱스





## 8.6 함수 기반 인덱스







## 8.7 멀티 밸류(Multi-Value) 인덱스





## 8.8 클러스터링 인덱스





## 8.9 유니크 인덱스





## 8.10 외래키