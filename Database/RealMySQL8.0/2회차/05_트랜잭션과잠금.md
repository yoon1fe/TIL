동시성에 영향을 미치는 요소

- 잠금(Lock) - 동시성 제어
- 트랜잭션 - 작업의 완전성을 보장해주는 것.
- 트랜잭션의 격리 수준 - 데이터 정합성 보장



## 5.1 트랜잭션

> MyISAM, MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않음.



### MySQL에서의 트랜잭션

`tab` 테이블에 `3` 레코드가 있는 상황에서`INSERT INTO tab (fdpk) VALUES (1), (2), (3);`하면

- MyISAM: 1, 2, 3 모두 INSERT 됨. 

- InnoDB: 3만 INSERT 됨.

InnoDB 스토리지 엔진은 트랜잭션을 지원한다. 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다는 트랜잭션의 원리를 따르기 때문에 앞서 INSERT되었던 1과 2가 롤백됨

MyISAM 테이블에서 발생하는 이러한 현상을 부분 업데이트(Partial Update)라고 하고, 이 현상은 테이블 데이터의 정합성을 맞추는데 어려움을 야기시킨다. 부분 업데이트 현상이 발생하면 실패 쿼리로 인해 남은 레코드를 다시 삭제하는 재처리 작업이 필요할 수 있음.



DB 커넥션과 마찬가지로 트랜잭션은 프로그램 코드에서 활성화되어 있는 범위를 최소화해야 한다.

- 트랜잭션에 포함시킬 필요 없는 작업은 포함하지 말자.
- 외부 서버와 통신하는 작업은 DBMS의 트랜잭션 내에서 제거하는 것이 좋다. 외부 서버와 통신이 불가능할 때 DBMS 서버에까지 영향을 미칠 수 있기 때문
- 데이터 단순 조회는 트랜잭션에 포함시킬 필요 없다.
- 작업의 성격이 다르다면 별도의 트랜잭션으로 분리하는 것이 좋다.



## 5.2 MySQL 엔진의 잠금

- 스토리지 엔진 레벨의 잠금

- MySQL 엔진 레벨의 잠금

  - 글로벌 락

  - 테이블 락
  - 메타데이터 락 - 테이블의 구조 데이터
  - 네임드 락 - 사용자의 필요에 맞게 설정 가능



**글로벌 락(GLOBAL LOCK)**

- MySQL이 제공하는 잠금 중 가장 범위가 크다.
- MySQL 서버 전체에 영향을 끼침

- MyISAM이나 MEMORY 테이블에 대해 일관된 백업을 받을 때 사용했음
- 8.0부터 글로벌 락보다 가벼운 백업 락이 도입됨 - 일반적인 테이블 데이터 변경은 허용



**테이블 락**

- 개별 테이블 단위로 설정되는 잠금
- 명시적 테이블 락(`LOCK TABLES ...`)은 애플리케이션에서 사용할 일 거의 없다.
- 묵시적 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행할 때 발생
- InnoDB에서는 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하기 때문에 묵시적 테이블 락 설정되어도 대부분의 데이터 변경(DML) 쿼리에서는 무시되고, 스키마 변경하는 쿼리(DDL)에만 영향을 미친다.



**네임드 락**

- `GET_LOCK()` 함수를 이용해 임의의 문자열에 대한 잠금 설정
- 여러 클라이언트가 상호 동기화를 처리해야 하는 경우



**메타데이터 락**

- DB 객체(테이블이나 뷰 등)의 이름, 구조 등을 변경할 때 획득하는 잠금



## 5.3 InnoDB 스토리지 엔진 잠금

InnoDB 스토리지 엔진은 내부에서 **레코드 기반 잠금** 기능을 갖고 있다. 때문에 다른 스토리지 엔진보다 훨씬 뛰어난 동시성 처리를 제공한다.



### InnoDB 스토리지 엔진의 잠금

레코드 기반 잠금 기능은 잠금 정보가 매우 작기 때문에 레코드 락 -> 페이지 락/테이블 락으로 레벨업(락 에스컬레이션)되는 경우는 없다.

레코드 - 레코드 사이의 간격을 잠그는 갭 락이란 것도 있다.



**레코드 락**

- 다른 DBMS와 달리 레코드 자체가 아니라 인덱스의 레코드를 잠그는 락
- 인덱스가 없는 테이블이라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금 설정
- PK나 유니크 인덱스에 의한 변경 작업에서는 갭 락 등을 걸지 않고 레코드 자체에 대해서만 락을 건다.



**갭 락**

- 레코드와 바로 인접한 레코드 사이의 간격을 잠그는 락
- 레코드들 사이에 새로운 레코드가 생성되는 것을 제어하는 역할
- 갭 락 자체보다는 넥스트 키 락의 일부로 주로 사용된다.



**넥스트 키 락**

- 레코드 락 + 갭 락 = 넥스트 키 락
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들도록 보장한는 것이 주목적



**자동 증가 락**

- `AUTO_INCREMENT` 속성이 적용된 컬럼에서 사용되는 락
- 동시에 여러 레코드가 `INSERT` 될 때, 중복된 일련번호 값을 가지지 않도록 하는 테이블 수준의 잠금
- `INSERT`, `REPLACE` 와 같이 새 레코드를 저장하는 쿼리에만 쓰인다.
- 트랜잭션과 관곙벗이 `AUTO_INCREMENT` 값을 가져오는 순간에만 락이 걸렸다가 즉시 해제됨
- 5.1 이상부터 `innodb_autoinc_lock_mode` 시스템 변수로 자동 증가 락 작동 방식 설정
  - = 0: 모든 `INSERT` 쿼리에 한해 자동 증가 락 사용
  - = 1: 동시에 수많은 레코드가 `INSERT`되지 않는 테이블의 경우 자동 증가 락 대신 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해 동시성 처리.
  - = 2: 자동 증가 락을 절대 사용하지 않고 경량화된 래치(뮤텍스) 사용. 하나의 `INSERT` 쿼리로 저장되는 레코드라도 연속된 자동 증가 값을 보장하지 않는다.



### 인덱스와 잠금

- InnoDB의 잠금은 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식이다. 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드에 모두 락을 걸어야 함.
- `UPDATE employees SET hire_date = NOW() WHERE first_name='MINSU' AND last_name='KIM';` 
  - first_name에만 인덱스가 있는 경우 first_name이 `MINSU` 인 모든 레코드에 락이 걸린다.



## 5.4 MySQL의 격리 수준





