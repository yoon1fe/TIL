동시성에 영향을 미치는 요소

- 잠금(Lock) - 동시성 제어
- 트랜잭션 - 작업의 완전성을 보장해주는 것.
- 트랜잭션의 격리 수준 - 데이터 정합성 보장



## 5.1 트랜잭션

> MyISAM, MEMORY 스토리지 엔진은 트랜잭션을 지원하지 않음.



### MySQL에서의 트랜잭션

`tab` 테이블에 `3` 레코드가 있는 상황에서`INSERT INTO tab (fdpk) VALUES (1), (2), (3);`하면 (fdpk: PK)

- MyISAM: 1, 2 모두 새로 INSERT 됨. 

- InnoDB: 아무 것도 INSERT 되지 않음.

InnoDB 스토리지 엔진은 트랜잭션을 지원한다. 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다는 트랜잭션의 원리를 따르기 때문에 앞서 INSERT되었던 1과 2가 롤백됨. 반면에 MyISAM 은 3(INSERT 오류 이전에 INSERT 된 1, 2는 그대로 남아 있음)

MyISAM 테이블에서 발생하는 이러한 현상을 부분 업데이트(Partial Update)라고 하고, 이 현상은 테이블 데이터의 정합성을 맞추는데 어려움을 야기시킨다. 부분 업데이트 현상이 발생하면 실패 쿼리로 인해 남은 레코드를 다시 삭제하는 재처리 작업이 필요할 수 있음.



DB 커넥션과 마찬가지로 트랜잭션은 프로그램 코드에서 활성화되어 있는 범위를 최소화해야 한다.

- 트랜잭션에 포함시킬 필요 없는 작업은 포함하지 말자.
- 외부 서버와 통신하는 작업은 DBMS의 트랜잭션 내에서 제거하는 것이 좋다. 외부 서버와 통신이 불가능할 때 DBMS 서버에까지 영향을 미칠 수 있기 때문
- 데이터 단순 조회는 트랜잭션에 포함시킬 필요 없다.
- 작업의 성격이 다르다면 별도의 트랜잭션으로 분리하는 것이 좋다.



## 5.2 MySQL 엔진의 잠금

- 스토리지 엔진 레벨의 잠금

- MySQL 엔진 레벨의 잠금

  - 글로벌 락

  - 테이블 락
  - 메타데이터 락 - 테이블의 구조 데이터
  - 네임드 락 - 사용자의 필요에 맞게 설정 가능



**글로벌 락(GLOBAL LOCK)**

- MySQL이 제공하는 잠금 중 가장 범위가 크다.
- MySQL 서버 전체에 영향을 끼침

- MyISAM이나 MEMORY 테이블에 대해 일관된 백업을 받을 때 사용했음
- 8.0부터 글로벌 락보다 가벼운 백업 락이 도입됨 - 일반적인 테이블 데이터 변경은 허용



**테이블 락**

- 개별 테이블 단위로 설정되는 잠금
- 명시적 테이블 락(`LOCK TABLES ...`)은 애플리케이션에서 사용할 일 거의 없다.
- 묵시적 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행할 때 발생
- InnoDB에서는 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하기 때문에 묵시적 테이블 락 설정되어도 대부분의 데이터 변경(DML) 쿼리에서는 무시되고, 스키마 변경하는 쿼리(DDL)에만 영향을 미친다.



**네임드 락**

- `GET_LOCK()` 함수를 이용해 임의의 문자열에 대한 잠금 설정
- 여러 클라이언트가 상호 동기화를 처리해야 하는 경우



**메타데이터 락**

- DB 객체(테이블이나 뷰 등)의 이름, 구조 등을 변경할 때 획득하는 잠금



## 5.3 InnoDB 스토리지 엔진 잠금

InnoDB 스토리지 엔진은 내부에서 **레코드 기반 잠금** 기능을 갖고 있다. 때문에 다른 스토리지 엔진보다 훨씬 뛰어난 동시성 처리를 제공한다.



### InnoDB 스토리지 엔진의 잠금

레코드 기반 잠금 기능은 잠금 정보가 매우 작기 때문에 레코드 락 -> 페이지 락/테이블 락으로 레벨업(락 에스컬레이션)되는 경우는 없다.

레코드 - 레코드 사이의 간격을 잠그는 갭 락이란 것도 있다.



**레코드 락**

- 다른 DBMS와 달리 레코드 자체가 아니라 인덱스의 레코드를 잠그는 락
- 인덱스가 없는 테이블이라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금 설정
- PK나 유니크 인덱스에 의한 변경 작업에서는 갭 락 등을 걸지 않고 레코드 자체에 대해서만 락을 건다.



**갭 락**

- 레코드와 바로 인접한 레코드 사이의 간격을 잠그는 락
- 레코드들 사이에 새로운 레코드가 생성되는 것을 제어하는 역할
- 갭 락 자체보다는 넥스트 키 락의 일부로 주로 사용된다.



**넥스트 키 락**

- 레코드 락 + 갭 락 = 넥스트 키 락
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들도록 보장한는 것이 주목적



**자동 증가 락**

- `AUTO_INCREMENT` 속성이 적용된 컬럼에서 사용되는 락
- 동시에 여러 레코드가 `INSERT` 될 때, 중복된 일련번호 값을 가지지 않도록 하는 테이블 수준의 잠금
- `INSERT`, `REPLACE` 와 같이 새 레코드를 저장하는 쿼리에만 쓰인다.
- 트랜잭션과 관곙벗이 `AUTO_INCREMENT` 값을 가져오는 순간에만 락이 걸렸다가 즉시 해제됨
- 5.1 이상부터 `innodb_autoinc_lock_mode` 시스템 변수로 자동 증가 락 작동 방식 설정
  - = 0: 모든 `INSERT` 쿼리에 한해 자동 증가 락 사용
  - = 1: 동시에 수많은 레코드가 `INSERT`되지 않는 테이블의 경우 자동 증가 락 대신 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해 동시성 처리.
  - = 2: 자동 증가 락을 절대 사용하지 않고 경량화된 래치(뮤텍스) 사용. 하나의 `INSERT` 쿼리로 저장되는 레코드라도 연속된 자동 증가 값을 보장하지 않는다.



### 인덱스와 잠금

- InnoDB의 잠금은 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식이다. 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드에 모두 락을 걸어야 함.
- `UPDATE employees SET hire_date = NOW() WHERE first_name='MINSU' AND last_name='KIM';` 
  - first_name에만 인덱스가 있는 경우 first_name이 `MINSU` 인 모든 레코드에 락이 걸린다.



## 5.4 MySQL의 격리 수준

트랜잭션의 격리 수준: 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 할지/말지 결정하는 것.



READ UNCOMMITTED나 SERIALIZABLE 은 잘 쓰지 않는다. 일반적으로 트랜잭션 간의 게이터 격리(고립) 정도가 높아질수록 동시 처리 성능이 떨어진다. 사실 SERIALIZABLE 격리 수준이 아니면 성능의 저하는 크게 없다.



**부정합 문제점**

|                  | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ     |
| ---------------- | ---------- | ------------------- | ---------------- |
| READ UNCOMMITTED | O          | O                   | O                |
| READ COMMITTED   | X          | O                   | O                |
| REPEATABLE READ  | X          | X                   | O(InnoDB는 없음) |
| SERIALIZABLE     | X          | X                   | X                |



**DBMS별 디폴트 격리 수준**

오라클: READ COMMITTED

MySQL: REPEATABLE READ



### READ UNCOMMITTED

![img](https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2Fa1257c5b-e23b-47c7-87fa-56f1a1623f9b%2Fimage.png)

- 각 트랜잭션에서의 변경 내용을 `COMMIT`이나 `ROLLBACK` 여부에 상관없이 다른 트랜잭션에서 볼 수 있다. (= DIRTY READ)
- 사용자 A가 커밋하지 않은 레코드를 B가 읽을 수 있음.
- **문제**: A가 처리 도중 `INSERT`된 내용을 롤백한다면?? B는 여전히 신규 레코드를 정상 데이터라고 생각하고 처리할 것.
- 따라서 이러한 DIRTY READ를 유발하는 READ UNCOMMITTED 격리 수준은 RDBMS 표준에서는 트랜잭션의 격리 수준으로도 인정하지 않음. 정합성에 문제가 많다.



### READ COMMITTED

![img](https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2Fe8e8c26b-4b80-4eff-8b4e-e9e33966d1fa%2Fimage.png)

- 오라클 디폴트 격리수준이자 온라인 서비스에서 가장 많이 선택되는 격리 수준.
- `COMMIT`이 완료된 데이터만 다른 트랜잭션에서 조회 가능
- 변경된 레코드를 읽을 때 커밋되기 전 언두 영역에 백업된 레코드를 읽음
- `NON-REPEATABLE READ` 문제 발생(**하나의 트랜잭션 내에서** 똑같은 `SELECT`쿼리를 실행했을 때는 항상 같은 결과가 나와야 한다). 동일한 쿼리로 조회했을 때, 두 쿼리 사이 다른 사용자가 레코드를 `UPDATE`하고 커밋할 경우 REPEATABLE READ 정합성에 어긋나게 된다.



### REPEATABLE READ

![img](https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2Fe0e49a47-21de-4f3b-827a-d680b5047c7c%2Fimage.png)
![img](https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2F0749f532-2eb9-4c01-91bb-ae477d89f9d2%2Fimage.png)

- MySQL InnoDB 스토리지 엔진 디폴트 격리 수준.
- InnoDB는 트랜잭션이 롤백될 가능성에 대비해 변경되기 전 레코드를 언두 영역에 백업해두고 실제 레코드 값을 변경한다. -> MVCC
-  REPEATABLE RAD와 READ COMMITTED 모두 MVCC를 이용해 커밋전의 데이터를 보여주지만,
- 언두 영역에 백업된 레코드의 여러 버전 중 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 차이가 있다.
- 모든 InnoDB의 트랜잭션은 순차 증가하는 트랜잭션 번호가 있는데, 언두 영역에 백업된 레코드에는 변경을 발생시킨 트랜잭션의 번호가 있음. REPEATABLE READ 격리 수준에서는 실행 중인 트랜잭션 중 가장 오래된 트랜잭션 번호보다 앞선 언두 영역의 데이터를 삭제할 수 없다.
- 따라서 한 트랜잭션(1) 내에서 동일한 쿼리를 조회했을 때, 중간에 새로운 트랜잭션(2)이 들어와 해당 레코드를 변경하더라도 1번 트랜잭션에서는 2번 트랜잭션이 변경시킨 레코드를 읽지 못하므로 같은 결과가 나오게 된다.
- PHANTOM READ 문제 발생. 동일한 쿼리를 조회했을 때, 다른 트랜잭션에서 추가된 새로운 레코드가 결과에 추가될 수 있다.
- InnoDB 스토리지 엔진에서는 갭 락 + 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 PHANTOM READ 문제가 발생하지 않는다.



### SERIALIZABLE

- 가장 단순하면서 가장 엄격한 격리 수준. 동시 처리 성능도 제일 떨어진다.
- InnoDB 테이블에서의 `SELECT` 쿼리는 레코드 잠금을 하지 않는데, SERIALIZABLE 격리 수준에서는 읽기 작업도 공유 잠금을 획득해야 한다. == 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근 불가
- PHANTOM READ 문제 발생하지 않음.
