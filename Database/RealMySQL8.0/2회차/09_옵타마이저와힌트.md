쿼리를 처리하는 방법은 내부적으로 매우 다양함. MySQL을 포함한 대부분의 DBMS에서는 **옵티마이저**가 쿼리를 최소 비용으로 실행하기 위해 테이블의 데이터가 어떤 분포로 저장되어 있는지 등의 통계 정보를 참조해서 최적의 실행 계획을 수립한다.

- `EXPLAIN` 명령어로 쿼리 실행 계획 확인 가능



## 9.1 개요

**쿼리 실행 절차**

1. **SQL 파싱**: SQL 문장을 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(parse tree)

   - **SQL 파서 모듈**이 처리함.
   - 쿼리문의 문법이 잘못됐다면 여기서 걸러진다.
   - **SQL parse tree** 가 생성됨. MySQL 서버는 쿼리문 자체가 아닌 SQL 파스 트리를 이용해 쿼리를 실행한다.

2. **최적화 및 실행 계획 수립**: 파싱 정보(parse tree)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용할지 선택

   - **옵티마이저**가 처리함.

   - 불필요한 조건 제거 및 복잡한 연산 단순화
   - 여러 테이블 조인할 경우 어떤 순서로 읽을지 결정
   - 각 테이블에 사용된 조건과 인덱스 통계 정보를 바탕으로 사용할 인덱스 결정
   - 이 단계가 완료되면 **실행 계획**이 생성됨.

3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴.

   - 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청
   - MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인/정렬 등의 작업 수행



**옵티마이저의 종류**

- 규칙 기반 최적화 방식 (Rule-Based Optimizer, RBO)
  - 레코드 건수, 선택도 등을 고려하지 않고, 옵티마이저에 내장된 우선순위에 따라 실행 계획 수립
  - 통계 정보를 활용하지 않기 때문에 동일한 쿼리에 대해서는 거의 항상 같은 실행 밥법을 만든다.
  - 요새 잘 안씀
- 비용 기반 최적화 방식 (Cost-Based Optimizer, CBO)
  - 대부분의 DBMS가 CBO 방법을 채택중.
  - 쿼리를 처리하는 여러 방법을 만들고, 각 단위 작업의 비용 정보와 테이블의 통계 정보를 이용해 실행 계획 별 비용을 계산, 최소 비용 처리 방식을 선택



## 9.2 기본 데이터 처리

### 풀 테이블 스캔, 풀 인덱스 스캔

다음 조건일 때 옵티마이저는 주로 풀 테이블 스캔을 선택한다.

- 테이블의 레코드 건수가 너무 적어서 인덱스를 통해 읽는 것보다 테이블을 통째로 읽는 것이 더 빠른 경우 (보통 테이블이 페이지 1개로 구성된 경우)
- `WHERE` 절이나 `ON` 절에 인덱스를 이용할만한 조건이 없는 경우
- 인덱스 레인지 스캔이 가능하더라도 옵티마이저가 판단하기에 조건 일치 레코드 건수가 너무 많은 경우



InnoDB 에서는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드가 리드 어헤드(read ahead) 작업(어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 버퍼 풀에 적재해두는 것)을 자동으로 시작한다. 따라서 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드(클라이언트) 스레드가 페이지 읽기를 실행하지만, 특점 시점부터는 읽기 작업을 백그라운드 스레드가 하게 되므로 쿼리 실행 속도가 향상된다.

- innodb_read_ahead_threshold: 몇 개의 연속된 데이터 페이지가 읽혔을 때 리드 어헤드 작업을 할지 설정하는 시스템 변수



리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용됨.

``` sql
SELECT COUNT(*) FROM employees;
```

- 단순히 레코드 건수만 필요로 하는 쿼리라면 테이블 자체보다 용량이 적은 인덱스를 선택해서 디스크 IO 횟수를 줄일 수 있다.



**병렬 처리**

- 8.0부터 **하나의 쿼리**를 여러 스레드가 작업을 나누어 동시에 처리하는 것이 가능해짐.
- 아직 아무 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리 가능



### ORDER BY 처리 (Using filesort)

정렬 처리 하는 방법

- 인덱스 이용

  장점

  - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어서 매우 빠름

  단점

  - INSERT, UPDATE, DELETE 작업시 부가적인 인덱스 추가/삭제 작업이 필요해서 느림.
  - 디스크 공간이 더 많이 필요
  - 인덱스 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 많이 필요함

- Filesort 이용

  장점

  - 인덱스 생성하지 않아도 되므로 인덱스 이용시의 장단점 바뀜

  단점

  - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 응답 속도가 느려짐



### 정렬 처리 방법

- ORDER BY 가 사용되면 반드시 다음 세 가지 처리 방법 중 하나로 정렬이 처리된다. 일반적으로 아래로 갈수록 처리 속도가 떨어짐.
  - 인덱스 사용한 정렬: 실행계획 Extra 칼럼에 별도 표기 없음
  - 조인에서 드라이빙 테이블만 정렬: "Using filesort"
  - 조인에서 조인 결과를 임시 테이블로 저장 후 정렬: "Using temporary; Using filesort"



**인덱스 이용한 정렬**

- ORDER BY 에 명시된 칼럼이 제일 먼저 읽는 테이블(조인있는 경우 드라이빙 테이블)에 속하고, ORDER BY 순서대로 생성된 인덱스가 있어야 함.
- WHERE 절에서 처음 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY 는 같은 인덱스를 사용할 수 있어야 함.
- 여러 테이블이 조인되는 경우 Nested-loop 방식의 조인에서만 사용 가능



**조인의 드라이빙 테이블만 정렬**

- 조인에서 처음 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 ORDER BY 절을 작성해야 함



**임시 테이블을 이용한 정렬**

- 두 개 이상의 테이블을 조인한 결과를 정렬해야 하면 임시 테이블이 필요할 수도 있음.
- 세 가지 방법 중 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느리다.
- 정렬 수행되기 전에 드리븐 테이블을 읽어야 하므로 조인된 데이터로만 정렬 가능



### GROUP BY 처리









## 9.3 고급 최적화





## 9.4 쿼리 힌트