옵티마이저가 항상 좋은 실행 계획을 만들어내진 못하기 때문에 DBMS 서버는 사용자가 보완할 수 있도록 `EXPLAIN` 명령으로 옵티마이저가 수립한 실행 계획을 확인할 수 있게 해준다. 실행 계획을 읽고 이해하려면 MySQL 서버가 데이터를 처리하는 로직을 이해해야 한다.



## 10.1 통계 정보

MySQL 서버는 5.7 버전까지는 테이블과 인덱스에 대한 대략적인 정보를 가지고 실행 계획을 수립했다. 하지만 이는 테이블 칼럼의 값들이 실제 어떻게 분포되어 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다. 그래서 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 **히스토그램** 정보가 도입되었다.



### 테이블 및 인덱스 통계 정보

CBO에서 가장 중요한 것은 통계 정보다. MySQL 서버에서는 다른 DBMS보다 통계 정보의 정확도가 높지 않고 통계 정보가 메모리에 관리되었기 때문에 휘발성이 강했다. 그래서 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용했다.



#### MySQL 서버의 통계 정보

5.6 버전부터 InnoDB 테이블에 대한 통계 정보를 영구적으로 관리할 수 있도록 개선되었다. `mysql` 테이블의 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 되었다.

특정한 이벤트가 발생하면 자동으로 통계 정보가 갱신되는데, 자주 통계 정보가 갱신되면 응용 프로그램의 쿼리를 인덱스 레인지 스캔으로 잘 처리하던 것을 갑자기 풀 테이블 스캔으로 실행되는 상황이 발생할 수도 있다.



영구적인 통계 정보를 사용한다면 MySQL 서버의 점검이나 사용량이 많지 않은 시간을 이용해 더 정확한 통계 정보를 수집할 수도 있다. 더 정확한 통계 정보를 수집하고자 한다면 `innodb_stats_persistent_sample_pages` 시스템 변수에 높은 값을 설정하면 된다. 이 시스템 변수의 기본값은 20이며, 임의로 20개 페이지만 샘플링해서 분석하고 그 결과를 영구적인 통계 정보 테이블에 저장함을 의미한다. 하지만 이 값을 너무 높이면 통계 정보 수집 시간이 길어지므로 주의해야 한다.



### 히스토그램

5.7버전까지는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 통계 정보로 갖고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다. 그래서 옵티마이저는 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조한다. 8.0버전으로 업그레이드되면서 MySQL 서버도 **칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보**를 활용할 수 있게 되었다.



#### 히스토그램 정보 수집 및 삭제

히스토그램의 정보는 칼럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTORGRAM` 명령을 수행해 수동으로 수집/관리된다. 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema` DB의 `column_statistics` 테이블로 로드한다.



8.0 버전에서는 다음과 같이 두 종류의 히스토그램 타입이 지원된다. 히스토그램은 버킷 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리된다.

- Singleton(싱글톤 히스토그램): 칼럼값 개별로 레코드 건수를 관리하는 히스토그램으로, Value-Based 히스토그램 또는 도수 분포라고도 한다.
  - 칼럼이 가지는 값별로 버킷이 할당된다.
  - 각 버킷이 칼럼의 값과 발생 빈도의 비율 두 개의 값을 가진다.
  - 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은(히스토그램의 버킷 수보다 적은) 경우 사용된다.
- Equi-Height(높이 균형 히스토그램): 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로, Height-Balanced 히스토그램이라고도 한다.
  - 개수가 균등한 칼럼값의 범위별로 하나의 버킷이 할당된다.
  - 각 버킷이 범위 시작 값과 마지막 값, 그리고 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 등 네 개의 값을 가진다.



생성된 히스토그램은 다음과 같이 삭제할 수 있다. 삭제할 때 테이블의 데이터를 참조하는 것이 아니라 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주진 않는다. 하지만 히스토그램이 삭제되면 쿼리의 실행 계획이 달라질 수 있으므로 주의해야 한다.



``` sql
ANALYZE TABLE employees.emplyees
DROP HISTOGRAM ON gender, hire_date;
```



#### 히스토그램의 용도

히스토그램이 도입되기 전에 사용되던 통계 정보 테이블의 전체 레코드 건수와 인덱스된 칼럼이 가지는 유니크한 값의 개수 정도였다. 실제 응용 프로그램의 데이터는 균등한 분포도를 가지지 않기 때문에 이러한 부분을 고려하지 못했다. 반면에 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지진 못하지만, 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다. 특정 범위의 데이터가 많고 적음을 식별할 수 있는 것이다. 이러한 정보를 바탕으로 조인의 드라이빙 테이블을 결정하는 등 쿼리 성능에 큰 영향을 끼칠 수 있다.



#### 히스토그램과 인덱스

MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종정긍로 가장 나은 실행 계획을 선택한다. 이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴본다. 이 작업을 인덱스 다이브라고 한다.



8.0 버전에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우, 그 칼럼의 히스토그램은 사용하지 않고 인덱스 다이브를 통해 직접 수집한 정보를 활용한다. 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이기 때문에 항상 히스토그램보다 정확한 결과를 기대할 수 있기 때문이다. 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.



### 코스트 모델

MySQL 서버가 쿼리를 처리하려면 다음과 같은 다양한 작업을 필요로 한다.

- 디스크로부터 데이터 페이지 읽기
- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
- 인덱스 키 비교
- 레코드 평가
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업



MySQL 서버는 사용자의 쿼리에 대해 이러한 작업이 얼마나 필요한지 예측하고 전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾는다. 이렇게 전체 쿼리의 비용을 계산하는 데 필요한 단위 작업을의 비용을 **코스트 모델**이라고 한다. 5.7 이전까지는 이런 비용을 MySQL 서버 소스 코드에 상수화해서 사용했는데, 이러한 비용은 하드웨어에 따라에 달라질 수 있기 때문에 고정된 비용을 적용하는 것은 최적의 실행 계획을 수립하는데 방해 요소였다.

5.7버전부터는 상수화되어 있던 각 단위 작업의 비용을 DBMS 관리자가 조정할수 있게 되었다. 하지만 5.7버전에서도 인덱스되지 않은 칼럼의 데이터 분포나 메모리에 있는 페이지의 비율 등과 같은 정보가 부족했는데, 8.0 버전부터 히스토그램과 각 인덱스별 메모리에 적재된 페이지의 비율이 관리되고 옵티마이저의 실행 계획 수립에 사용되기 시작했다.



8.0 버전의 코스트 모델은 다음 두 개의 테이블에 저장되어 있는 설정값을 사용하는데, 두 테이블 모두 `mysql` DB에 존재한다.

- `server_cost`: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- `engine_cost`: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리



## 10.2 실행 계획 확인

실행 계획은 `DESC`나 `EXPLAIN` 명령으로 확인할 수 있다. 그리고 8.0 버전부터는 `EXPLAIN` 명령에 사용할 수 있는 새로운 옵션이 추가되었는데, **실행 계획의 출력 포맷**과 **실제 쿼리의 실행 결과**까지 확인할 수 있는 기능을 구분해서 살펴 보자.



### 실행 계획 출력 포맷

8.0 버전부터는 `EXPLAIN EXTENDED`, `EXPLAIN PARTITIONS` 명령이 통합되어 보이도록 개선되었다. 그리고 `FORMAT` 옵션을 사용해 실행 계획의 표시 방법을 JSON이나 TREE, 단순 테이블 형태로 선택할 수 있다.



### 쿼리의 실행 시간 확인

8.0.18 버전부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가됐다. `EXPLAIN` 과 달리, 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여주는 명령이다. 명령의 결과는 항상 TREE 포맷이기 때문에 `FORMAT` 옵션을 줄 순 없다. `SHOW PROFILE` 명령으로도 어떤 부분에서 시간이 많이 소요되는지 확인할 수 있지만, 실행 계획의 단계별로 소요된 시간 정보를 보여주진 않는다.



TREE 포맷의 실행 계획에서 들여쓰기는 호출 순서를 의미하고, 실제 실행 순서는 다음 기준으로 읽으면 된다.

- 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
- 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행



``` bash
A)-> Table scan on <temporary>  (actual time=0.001..0.004 rows=48 loops=1)
B)    -> Aggregate using temporary table  (actual time=3.088..3.095 rows=48 loops=1)
C)        -> Nested loop inner join  (cost=618.92 rows=135) (actual time=0.303..2.991 rows=48 loops=1)
D)            -> Index lookup on e using ix_first_name (first_name='Matt')  (cost=166.76 rows=233) (actual time=0.286..0.736 rows=233 loops=1)
E)            -> Filter: ((s.salary > 50000) and (s.from_date <= DATE'1990-01-01') and (s.to_date > DATE'1990-01-01'))  (cost=0.98 rows=10) (actual time=0.008..0.009 rows=0 loops=233)
F)                -> Index lookup on s using PRIMARY (emp_no=e.emp_no)  (cost=0.98 rows=10) (actual time=0.005..0.008 rows=10 loops=233)
```



위 실행 계획의 순서는 다음과 같다.

1. D) Index lookup on e using ix_first_name
2. F) Index lookup on s using PRIMARY
3. E) Filter
4. C) Nested loop inner join
5. B) Aggregate using temporary table
6. A) Table scan on \<temporary\>



`EXPLAIN ANALYZE` 명령의 결과에는 단계별로 실제 소요된 시간(`actual time`)과 처리한 레코드 건수(`rows`), 반복 횟수(`loops`)가 표시된다.

- `actual time`: 테이블에서 일치하는 값을 가져오는 데 걸린 시간(ms). 첫 번째 숫자는 첫 레코드를 가져오는 데 걸린 평균 시간이고, 두 번째 숫자는 마지막 레코드를 가져오는 데 걸린 평균 시간이다.
- `rows`: A 테이블과 B 테이블이 조인할 때의 조건 K가 있을 때, K를 만족하는 B 테이블의 평균 레코드 건수를 의미한다.
- `loops`: B 테이블의 레코드를 찾는 작업이 반복된 횟수를 의미한다.



## 10.3 실행 계획 분석

8.0 버전부터는 `EXPLAIN` 명령의 결과로 출력되는 실행 계획의 포맷을 기존 테이블 포맷과 JSON, TREE 형태로 선택할 수 있다.



```mysql
EXPLAIN
SELECT *
FROM employees e
INNER JOIN salaries s ON s.emp_no=e.emp_no
WHERE first_name='ABC';
```





| id   | select_type | table | partitions | type  | possible_keys        | key          | key_len | ref                 | rows | filtered | Extra |
| ---- | ----------- | ----- | ---------- | ----- | -------------------- | ------------ | ------- | ------------------- | ---- | -------- | ----- |
| 1    | SIMPLE      | e     | NULL       | index | PRIMARY,ix_firstname | ix_firstname | 58      | const               | 1    | 100.00   | NULL  |
| 1    | SIMPLE      | s     | NULL       | ref   | PRIMARY              | PRIMARY      | 4       | employees. e.emp_no | 10   | 100.00   | NULL  |



아무 옵션없이 `EXPLAIN` 을 실행하면 쿼리 문장의 특성에 따라 표 형태로 된 한 줄 이상의 결과가 표시된다. 표의 각 라인은 쿼리 문장에서 사용된 테이블(서브쿼리로 임시 테이블을 생성한 경우도 포함)의 개수만큼 출력된다. 실행 순서는 위에서 아래로 순서대로 표시된다. 출력된 실행 계획에서 위쪽일수록(`id` 칼럼의 값이 작을수록) 퀴리의 바깥 부분이거나 먼저 접근한 테이블이다.



### id 칼럼

하나의 `SELECT` 문장은 다시 한 개 이상의 하위(SUB) `SELECT` 문장을 포함할 수 있다. `id` 칼럼은 각 단위 `SELECT` 쿼리별로 부여되는 식별자 값이다. 하나의 `SELECT` 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 `id` 값이 부여된다. 여기서 주의해야 할 것으 `id` 칼럼이 테이블의 접근 순서를 의미하지는 않는다.



### select_type 칼럼

각 단위 `SELECT` 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다. 해당 칼럼이 표시될 수 있는 값은 다음과 같다.

- SIMPLE: 서브쿼리가 없는 단순한 `SELECT` 의 경우이다. 복잡한 쿼리라도 SIMPLE 단위 쿼리는 하나만 존재한다. 보통 제일 바깥 쿼리가 해당한다.
- PRIMARY: `UNION`이나 서브 쿼리를 가지는 `SELECT` 의 경우이다. SIMPLE과 마찬가지로 하나만 존재하고, 쿼리의 제일 바깥쪽에 있는 단위 쿼리가 해당한다.
- UNION: `UNION`으로 결합하는 단위 `SELECT` 쿼리 중 두 번째 이후의 경우. 첫 단위 `SELECT`는 DERIVED로 표시된다.
- DEPENDENT UNION: UNION과 마찬가지로 `UNION`이나 `UNION ALL`로 집합을 결합하는 쿼리에서 표시된다. DEPENDENT는 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.
- UNION RESULT: `UNION` 결과를 담아두는 테이블을 의미한다. 8.0 버전부터는 `UNION ALL`의 경우 임시 테이블을 사용하지 않도록 개선되었다. 실제 쿼리에서의 단위 쿼리는 아니기 때문에 별도의 `id`값은 부여되지 않는다.
- SUBQUERY: `FROM` 절 이외에서 사용되는 서브쿼리만을 의미한다.
- DEPENDENT SUBQUERY: 서브쿼리가 바깥쪽 `SELECT` 쿼리에서 정의된 칼럼을 사용하는 경우이다. 
- DERIVED: 단위 `SELECT` 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.
- DEPENDENT DERIVED: 8.0 버전부터 래터럴 조인(LATERAL JOIN) 기능이 추가되면서 `FROM` 절의 서브 쿼리에서도 외부 칼럼을 참조할 수 있게 되었다. 래터럴 조인으로 사용된 것을 의미한다.
- UNCACHEABLE SUBQUERY: 하나의 서브 쿼리는 실제로는 두 번 이상 실행될 수 있는데, 조건이 똑같은 서브 쿼리가 실행될 때는 이전의 실행 결과를 그대로 사용할 수 있게 캐싱한다. 서브 쿼리에 포함된 요소에 의해 캐시 자체가 불가능할 수 있는데, 해당 경우에 표시되는 타입이다. 캐시를 사용하지 못하게 하는 요소로는 크게 다음과 같은 것들이 있다.
- UNCACHEABLE UNION
- MATERIALIZED: `FROM`절이나 `IN(subquery)` 형태의 쿼리에 사용된 서브 쿼리의 최적화를 위해 사용된다. 서브 쿼리의 내용을 임시 테이브로 구체화(Materialization)한 후, 이 임시 테이블과 조인하는 형태로 최적화되어 처리되는 것이다.



### table 칼럼

