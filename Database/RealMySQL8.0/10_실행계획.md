옵티마이저가 항상 좋은 실행 계획을 만들어내진 못하기 때문에 DBMS 서버는 사용자가 보완할 수 있도록 `EXPLAIN` 명령으로 옵티마이저가 수립한 실행 계획을 확인할 수 있게 해준다. 실행 계획을 읽고 이해하려면 MySQL 서버가 데이터를 처리하는 로직을 이해해야 한다.



## 10.1 통계 정보

MySQL 서버는 5.7 버전까지는 테이블과 인덱스에 대한 대략적인 정보를 가지고 실행 계획을 수립했다. 하지만 이는 테이블 칼럼의 값들이 실제 어떻게 분포되어 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다. 그래서 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 **히스토그램** 정보가 도입되었다.



### 테이블 및 인덱스 통계 정보

CBO에서 가장 중요한 것은 통계 정보다. MySQL 서버에서는 다른 DBMS보다 통계 정보의 정확도가 높지 않고 통계 정보가 메모리에 관리되었기 때문에 휘발성이 강했다. 그래서 쿼리의 실행 계획을 수립할 때 실제 테이블의 데이터를 일부 분석해서 통계 정보를 보완해서 사용했다.



#### MySQL 서버의 통계 정보

5.6 버전부터 InnoDB 테이블에 대한 통계 정보를 영구적으로 관리할 수 있도록 개선되었다. `mysql` 테이블의 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 되었다.

특정한 이벤트가 발생하면 자동으로 통계 정보가 갱신되는데, 자주 통계 정보가 갱신되면 응용 프로그램의 쿼리를 인덱스 레인지 스캔으로 잘 처리하던 것을 갑자기 풀 테이블 스캔으로 실행되는 상황이 발생할 수도 있다.



영구적인 통계 정보를 사용한다면 MySQL 서버의 점검이나 사용량이 많지 않은 시간을 이용해 더 정확한 통계 정보를 수집할 수도 있다. 더 정확한 통계 정보를 수집하고자 한다면 `innodb_stats_persistent_sample_pages` 시스템 변수에 높은 값을 설정하면 된다. 이 시스템 변수의 기본값은 20이며, 임의로 20개 페이지만 샘플링해서 분석하고 그 결과를 영구적인 통계 정보 테이블에 저장함을 의미한다. 하지만 이 값을 너무 높이면 통계 정보 수집 시간이 길어지므로 주의해야 한다.



### 히스토그램

5.7버전까지는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 통계 정보로 갖고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다. 그래서 옵티마이저는 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조한다. 8.0버전으로 업그레이드되면서 MySQL 서버도 **칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보**를 활용할 수 있게 되었다.



#### 히스토그램 정보 수집 및 삭제

히스토그램의 정보는 칼럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 `ANALYZE TABLE ... UPDATE HISTORGRAM` 명령을 수행해 수동으로 수집/관리된다. 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema` DB의 `column_statistics` 테이블로 로드한다.



8.0 버전에서는 다음과 같이 두 종류의 히스토그램 타입이 지원된다. 히스토그램은 버킷 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리된다.

- Singleton(싱글톤 히스토그램): 칼럼값 개별로 레코드 건수를 관리하는 히스토그램으로, Value-Based 히스토그램 또는 도수 분포라고도 한다.
  - 칼럼이 가지는 값별로 버킷이 할당된다.
  - 각 버킷이 칼럼의 값과 발생 빈도의 비율 두 개의 값을 가진다.
  - 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은(히스토그램의 버킷 수보다 적은) 경우 사용된다.
- Equi-Height(높이 균형 히스토그램): 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램으로, Height-Balanced 히스토그램이라고도 한다.
  - 개수가 균등한 칼럼값의 범위별로 하나의 버킷이 할당된다.
  - 각 버킷이 범위 시작 값과 마지막 값, 그리고 발생 빈도율과 각 버킷에 포함된 유니크한 값의 개수 등 네 개의 값을 가진다.



생성된 히스토그램은 다음과 같이 삭제할 수 있다. 삭제할 때 테이블의 데이터를 참조하는 것이 아니라 딕셔너리의 내용만 삭제하기 때문에 다른 쿼리 처리의 성능에 영향을 주진 않는다. 하지만 히스토그램이 삭제되면 쿼리의 실행 계획이 달라질 수 있으므로 주의해야 한다.



``` sql
ANALYZE TABLE employees.emplyees
DROP HISTOGRAM ON gender, hire_date;
```



#### 히스토그램의 용도

히스토그램이 도입되기 전에 사용되던 통계 정보 테이블의 전체 레코드 건수와 인덱스된 칼럼이 가지는 유니크한 값의 개수 정도였다. 실제 응용 프로그램의 데이터는 균등한 분포도를 가지지 않기 때문에 이러한 부분을 고려하지 못했다. 반면에 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지진 못하지만, 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다. 특정 범위의 데이터가 많고 적음을 식별할 수 있는 것이다. 이러한 정보를 바탕으로 조인의 드라이빙 테이블을 결정하는 등 쿼리 성능에 큰 영향을 끼칠 수 있다.



#### 히스토그램과 인덱스

MySQL 서버에서는 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종정긍로 가장 나은 실행 계획을 선택한다. 이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴본다. 이 작업을 인덱스 다이브라고 한다.



8.0 버전에서는 인덱스된 칼럼을 검색 조건으로 사용하는 경우, 그 칼럼의 히스토그램은 사용하지 않고 인덱스 다이브를 통해 직접 수집한 정보를 활용한다. 실제 검색 조건의 대상 값에 대한 샘플링을 실행하는 것이기 때문에 항상 히스토그램보다 정확한 결과를 기대할 수 있기 때문이다. 히스토그램은 주로 인덱스되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.



### 코스트 모델





## 10.2 실행 계획 확인



### 실행 계획 출력 포맷



### 쿼리의 실행 시간 확인







## 10.3 실행 계획 분석





